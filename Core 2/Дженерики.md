#### **1. Что такое дженерики?**
Дженерики в Java — это мощный инструмент, который позволяет создавать обобщенные типы данных. Они позволяют работать с разными типами данных, но при этом обеспечивают безопасность типов.

До введения дженериков в Java, программистам приходилось использовать коллекции (например, списки, множества, карты и т. д.) без установки ограничений на типы данных, с которыми они работают. Это приводило к необходимости явного приведения типов (casting) при извлечении объектов из коллекций, что могло вызывать ошибки во время выполнения программы и усложнять код.
#### **2. Для чего нужны дженерики? Параметр vs Аргумент. (в дженериках)?**
Дженерики позволяют создавать универсальные классы и интерфейсы, которые могут работать с разными типами данных. Вместо того чтобы писать отдельные классы для каждого типа (например, `List<Integer>`, `List<String>`), вы можете создать обобщенный класс `List<T>`, где T — это параметр типа. Это делает код более гибким и повышает его переиспользуемость.

Дженерики обеспечивают безопасность типов. Компилятор проверяет, что вы используете правильные типы данных, и предотвращает ошибки времени выполнения. Например, если вы пытаетесь добавить `String` в `List<Integer>`, компилятор выдаст ошибку.

Дженерики позволяют избежать неявных приведений типов. Вместо использования общего типа Object, вы можете точно указать, какой тип данных ожидается.

***Параметр типа (Type Parameter)*** - это символ, который используется в определении обобщенного класса или метода. Например, в `List<T>`, T — это параметр типа. Параметр типа указывает, что класс или метод будет работать с неизвестным типом данных.

***Аргумент типа (Type Argument)*** - это конкретный тип данных, передаваемый при создании экземпляра обобщенного класса. Например, если вы создаете `List<Integer>`, `Integer` — это аргумент типа. Аргумент типа указывает, с каким конкретным типом данных будет работать класс.

**Ограничения дженериков:**
1. **Ограничения на параметры типа:** В Java, например, дженерики не могут использоваться с примитивными типами данных, такими как `int`, `char`, `double` и т.д. Вы можете использовать только ссылочные типы или классы-обертки для примитивных типов данных (например, `Integer`, `Character`, `Double`, и т.д., в том числе массивы). Это может вызвать дополнительные расходы памяти и накладные расходы на производительность из-за автобоксинга и автораспаковки.

2. **Ограничения на параметры типа в сравнении:** При сравнении параметров типа, используемых в дженериках, вы не можете использовать операторы сравнения, такие как `==` или `!=`, для параметров типа, поскольку они теряют информацию о типе во время выполнения. Вместо этого вам нужно использовать методы сравнения, такие как `equals()`.

3. **Ограничения на статические переменные и методы:** Дженерики в Java не могут быть непосредственно использованы с статическими переменными и методами. Это связано с тем, что параметры типа принадлежат экземпляру класса, а не классу в целом. Однако можно использовать дженерики с методами и переменными экземпляра.

4. Нельзя создать объект Т внутри параметризованного класса T t = new T(); (стирание типов)

**Стирание типов (Type Erasure)** - это процесс, при котором информация о параметрах типа (дженериках) удаляется из байт-кода после компиляции. В Java информация о параметрах типа нужна только на этапе компиляции для проверки типов, но она не сохраняется в байт-коде из-за соображений обратной совместимости.

Когда вы объявляете параметризованный тип, например, `ArrayList<T>`, `T` является параметром типа. При компиляции Java создает файл .class, который содержит байт-код вашего класса. Однако информация о параметре типа `T` удаляется из этого байт-кода. Вместо этого компилятор заменяет все вхождения параметра типа `T` на его ограничивающий тип (если он есть. ограничение это extends) или на тип `Object`.

Это означает, что во время выполнения программы Java не знает о параметрах типа, использованных при создании объекта. Например, если у вас есть `ArrayList<Integer>`, после стирания типов она будет восприниматься как `ArrayList<Object>`.
#### 3. Типизированные методы (Generic Methods) 
**Типизированные методы** - это методы, которые могут принимать параметры типа (типизированные), аналогично обобщённым классам. Они позволяют создавать методы, которые могут работать с различными типами данных без потери безопасности типов.
Допускаются статические и нестатические универсальные методы, а также конструкторы универсальных классов.

**Синтаксис Generic methods:**
1) включает список типизированных параметров **ВНУТРИ** угловых скобок `<>`
2) список типизированных параметров идёт **ДО** типа возвращаемого значения метода
![[Pasted image 20240315224032.png]]
![[Pasted image 20240315224055.png]]
  
**Type inference, или вывод типа** - это механизм, используемый компилятором, чтобы автоматически определить типы параметров при вызове универсальных (generic) методов в Java. Это позволяет вызывать универсальные методы, не указывая явно типы параметров, так как компилятор может вывести их на основе контекста вызова.
#### 4. Типизированные классы (Generic Types) 
Это классы, которые могут работать с различными типами данных, предоставленными в виде параметров типа (типизированных параметров). Они позволяют создавать обобщенные (generic) классы, которые могут быть использованы с разными типами данных без необходимости дублирования кода.

При использовании шаблонов, поля класса не могут быть статическими. Т.к она является общей для объекта, компилятор не может определить, какой тип использовать.

**Можно ли параметризовать массив?**
Нет, т.к. неизвестен тип и не понятно, сколько памяти выделить.
#### 5. Что такое сырые типы (raw type)? 
**Raw Types или сырые типы** – это типы без указания "уточнения" параметризованного
типа в угловых скобках <…>. Говоря о дженериках, мы имеем две категории: "сырые"
типы (Raw Types) и типизированные типы (Generic Types).

Сырые типы были введены в Java для обеспечения обратной совместимости с более ранними версиями языка до появления обобщенных типов в Java 5. Они позволяют использовать обобщенный код с необобщенным кодом, который не знает о параметрах типа.

Однако использование сырых типов не рекомендуется, так как они обходят проверку типов на этапе компиляции и могут привести к ошибкам времени выполнения из-за неправильного приведения типов. Вместо этого рекомендуется использовать параметризацию типов (generic types) для обеспечения безопасности типов на этапе компиляции.

**Diamond оператор** (`<>`) был введен в Java 7. Он позволяет опускать явное указание типов в правой части оператора new, когда тип параметра можно вывести из контекста. Это делает код более чистым и читаемым.

Прежде чем появился diamond оператор, при создании объектов обобщенных классов требовалось указывать тип параметра дважды: при объявлении переменной и при создании объекта. Это могло привести к избыточному коду и усложнению чтения.

#### 6. Можно ли выбрасывать исключение generic-типа? 
Да, мы можем создавать и выбрасывать исключения с параметризованным типом (generic типом). Несмотря на то, что на этапе выполнения параметризованные типы стираются (type erasure), исключения с параметризованным типом могут быть полезны для передачи дополнительной информации о типе данных, вызвавших исключение.

Например, вы можете определить собственный класс исключения с параметризованным типом, который содержит дополнительные данные о типе объекта, вызвавшего исключение. Это может быть полезно для обработки ошибок в более обобщенном и информативном виде.

Чтобы объявить, что метод выбрасывает исключение обобщенного типа T, этот тип T должен быть объявлен расширяющим Throwable. Именно в Throwable в таком случае сотрется T при
компиляции. Также в качестве типа-верхней границы можно использовать любого наследника Throwable.
#### 7. Дженерики в исключениях – что можно, а что нельзя? 
1. Можно выбрасывать исключение generic-типа. Тип-параметр T может использоваться в throws, переменная типа T может использоваться в throw. 
2. Нельзя использовать дженерик в catch. Множественные блоки catch должны идти без повторений, в определенном порядке – от специфичного класса к более базовому. Стирание типов-параметров в связи с этими правилами добавило бы путаницу, не неся особой пользы.
3. Нельзя параметризовать класс-исключение типами. Если вы попытаетесь скомпилировать конструкцию вида `class MyException<T> extends` Throwable {}, то увидите ошибку generic class may not extend java.lang.Throwable.
4. Можно реализовывать исключением generic-интерфейс.
Исключение вполне может быть, например Comparable или Iterable. Когда говорят о том, что "можно реализовывать исключением generic-интерфейс", это означает, что вы можете определять методы, которые могут выбрасывать исключения в границах generic-интерфейса. Например, если у вас есть generic-интерфейс `Comparable<T>`, который предполагает сравнение объектов типа T, вы можете определить метод, который выбрасывает исключение, если объекты не могут быть сравнены.
#### 8. Что такое wildcards? 
Wildcards (шаблоны) - это механизм, который позволяет работать с обобщенными типами в более гибком и универсальном виде. Wildcards позволяют вам создавать обобщенные типы, которые могут принимать любой тип данных или ограничивать типы данных внутри коллекций.
```java
List<String> strings = new ArrayList<String>(); 
// ошибка компиляции! 
List<Object> objects = strings;
```

Между объектом и коллекцией объектов есть важное различие. Если класс `B` является наследником класса `А`, то `Collection<B>` при этом — не наследник `Collection<A>`. Именно по этой причине мы не смогли привести наш `List<String>` к `List<Object>`. `String` является наследником `Object`, но `List<String>` не является наследником `List<Object>`.

Wildcards можно использовать как тип параметра, поля или локальной переменной,
иногда как возвращаемый тип.
#### Типы Wildcards:
1. **Неограниченные wildcards (Unbounded Wildcards)**: Представлены символом `?`. Этот тип wildcard означает, что параметр типа может быть любым. Он используется, когда код не зависит от конкретного типа данных и должен работать с любым типом.
2. **Ограниченные сверху wildcards (Upper Bounded Wildcards)**: Представлены как `<? extends Тип>`. Этот тип ограничивает тип данных до конкретного класса или его подкласса. Он используется, когда код должен работать с классом или его подклассами.
3. **Ограниченные снизу wildcards (Lower Bounded Wildcards)**: Представлены как `<? super Тип>`. Этот тип ограничивает тип данных до конкретного класса или его суперкласса. Он используется, когда код должен работать с классом и его суперклассами(предками).
#### 9. Расскажите про принцип PECS
Это акроним, означающий «Producer Extends Consumer Super». У нас есть некая коллекция, типизированная wildcard с верхней границей (_extends_) – то это, «продюсер». «Он только «продюсирует», предоставляет элемент из контейнера, а сам ничего не принимает». Если же у нас коллекция, типизированная wildcard по нижней границе (_super_) – то это, «потребитель», который «только принимает, а предоставить ничего не может».
Все это из-за ограничений java по приведению типов. К предкам приводить явно не нужно, а к наследникам - явно.

Дженерики инвариантны. Это означает, что, даже если A — подтип B, дженерик от A не является подтипом дженерика от B. При этом они оба наследники Object.
Для сравнения, массивы в Java ковариантны: если A — подтип B, A[] — подтип B[].
![[Pasted image 20240319035416.png]]![[Pasted image 20240319035451.png]]