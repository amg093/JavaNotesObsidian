#### 1. Какие нововведения появились в java 8? 
##### Методы интерфейсов по умолчанию:
- Методы интерфейсов по умолчанию;
- Функциональные интерфейсы;
- Ссылки на методы и конструкторы;
##### Расширения в работе с аннотациями:
- Повторяемые аннотации;
- Аннотации на типы данных;
##### Улучшения в работе с коллекциями и потоками данных:
- Stream API для работы с коллекциями;
- Параллельная сортировка массивов;
##### Новое API и улучшения в работе с датами и временем:
- Новое API для работы с датами и временем;
##### Улучшения в работе с языками и средами выполнения:
- Новый движок JavaScript Nashorn;
- Инструменты для анализа кода и выполнения JavaScript: утилита jjs и команда java для JavaFX;
- Добавлена утилита jdeps для анализа .class-файлов.
##### Улучшения в безопасности и производительности
- Добавлено несколько новых классов для потокобезопасной работы;
- Добавлен стандартный класс для работы с Base64;
- Добавлена поддержка беззнаковой арифметики;
- Улучшена производительность конструктора java.lang.String(byte[], *) и метода java.lang.String.getBytes();
- Новая реализация AccessController.doPrivileged;
- Password-based алгоритмы стали более устойчивыми;
- Добавлена поддержка SSL/TLS Server Name Indication (NSI) в JSSE Server;
- Улучшено хранилище ключей (KeyStore);
- Добавлен алгоритм SHA-224;
##### Изменения в структуре и возможностях платформы Java SE:
- Удален мост JDBC - ODBC;
- Удален PermGen, изменен способ хранения мета-данных классов;
- Возможность создания профилей для платформы Java SE, которые включают в себя не всю платформу целиком, а некоторую ее часть.

#### 2. Нововведения Java 17 (посмотреть видео по ссылке) 
Java 17 была выпущена в сентябре 2021 года и включает в себя несколько значимых нововведений и улучшений. Вот некоторые из них:

1. **Улучшения в языке и компиляторе:**
    
    - В Java 17 были добавлены новые ключевые слова, такие как `sealed`, `pattern`, `record` в качестве ключевого слова для модификатора класса.
    - Появились улучшения для обработки аннотаций и поддержка класса-записи для аннотаций.
    - Улучшена поддержка документации и дополнительные возможности для диагностики и логирования.
C версии Java 14 была введена новая особенность языка - **записи (records)**. Записи - это специальный тип классов, предназначенных для представления данных. Они облегчают создание классов, которые просто хранят данные, без необходимости явного определения методов `equals()`, `hashCode()`, `toString()` и других. Нет необходимости явного определения методов доступа (getter) или других стандартных методов. Поля записи (record) по умолчанию являются неизменяемыми (final), что обеспечивает безопасность их использования.

`sealed class` (закрытый класс) - это особый вид класса, который ограничивает иерархию наследования. В отличие от обычных классов, экземпляры закрытых классов могут быть созданы только внутри класса-потомка. Это позволяет контролировать все возможные подклассы внутри класса-предка.
    
5. **Улучшения в API:**
    
    - Были внесены изменения в API, такие как добавление новых методов к классам, таким как `List`, `Optional`, `Stream`, и другим.
    - В Java 17 добавлены новые классы и методы для поддержки встроенных примитивных векторных операций.
    - Были внесены улучшения в API для работы с файловой системой, включая новые методы для работы с файлами и каталогами.
3. **Улучшения в JVM:**
    
    - В Java 17 внесены изменения в виртуальную машину, например, добавление новых опций командной строки для управления памятью и производительностью.
    - Внесены улучшения в механизмы сборки мусора и оптимизации кода для повышения производительности и эффективности работы приложений.
4. **Улучшения в безопасности:**
    
    - Java 17 включает в себя улучшения в области безопасности, такие как обновления в механизмах шифрования и проверки сертификатов, а также исправления уязвимостей.
5. **Улучшения во встроенных библиотеках:**
    
    - В Java 17 были внесены улучшения во встроенные библиотеки, такие как улучшения в работе с коллекциями, потоками, регулярными выражениями и т. д.
    - Добавлены новые методы и классы для обработки дат и времени, JSON, HTTP-запросов и других типов данных.
6. **Удаление устаревших и устаревших функций:**
    
    - Java 17 также включает в себя удаление устаревших и устаревших функций, что помогает поддерживать чистоту языка и упрощает его использование.

#### 3. Какие новые классы для работы с датами появились в java 8? 
- LocalDate – дата без времени и временных зон;
- LocalTime – время без даты и временных зон;
-  LocalDateTime – дата и время без временных зон;
-  ZonedDateTime – дата и время с временной зоной;
-  DateTimeFormatter – форматирует даты в строки и наоборот, только для классов
java.time;

#### 4. Расскажите про класс Optional 
`Optional` - это класс, введенный в Java 8, который представляет собой контейнер, который может содержать или не содержать значение null. Такая обертка является удобным средством предотвращения NullPointer, т.к имеет некоторые функции высшего порядка, избавляющие от добавления повторяющихся if null/not null проверок.
```java
Optional<String> optional = Optional.of("hello");  
optional.isPresent(); //true  
optional.ifPresent(s -> System.out.println(s.length())); //5  
optional.get(); //"hello"  
optional.orElse("ops"); //"hello"
```
`Optional` является иммутабельным, что означает, что его содержимое нельзя изменить после его создания. Методы класса `Optional`, такие как `orElse`, `orElseGet, orElseThrow` и т. д., возвращают новый объект `Optional` с другим содержимым, не изменяя исходный объект.

#### 5. Что такое Nashorn? 
**Nashorn** – это движок JavaScript, разрабатываемый на Java компанией Oracle.
Призван дать возможность встраивать код JavaScript в приложения Java. В сравнении
с Rhino, который поддерживается Mozilla Foundation, Nashorn обеспечивает от 2 до 10 раз более высокую производительность, так как он компилирует код и передает байт-код виртуальной машине Java непосредственно в памяти.
Nashorn умеет компилировать код JavaScript и генерировать классы Java, которые
загружаются специальным загрузчиком. Так же возможен вызов кода Java прямо из
JavaScript.

#### 6. Что такое jjs? 
`jjs` - это интерпретатор JavaScript, встроенный в Java Development Kit (JDK) начиная с версии 8. Он основан на движке Nashorn JavaScript Engine.

С помощью утилиты `jjs` можно выполнять JavaScript код непосредственно из командной строки или сценариев командной строки, а также использовать взаимодействие с Java кодом. Например, вы можете запускать JavaScript файлы, создавать интерактивную среду выполнения JavaScript и тестировать JavaScript код.

#### 7. Какой класс появился в Java 8 для кодирования/декодирования данных? 
В Java 8 был добавлен новый класс для кодирования и декодирования данных в формате Base64. Этот класс называется `java.util.Base64`.

`java.util.Base64` предоставляет методы для кодирования байтовых массивов в строку Base64 и декодирования строк Base64 обратно в байтовые массивы. Этот класс имеет два подкласса: `java.util.Base64.Encoder` и `java.util.Base64.Decoder`, которые предоставляют методы для кодирования и декодирования данных соответственно.

`getEncoder () / getDecoder()` - возвращает кодировщик/декодировщик base64, соответствующий стандарту `RFC 4648`; 
`getUrlEncoder() / getUrlDecoder()` - возвращает URL-safe кодировщик/декодировщик base64, соответствующий стандарту `RFC 4648`; 
`getMimeEncoder() / getMimeDecoder()` - возвращает MIME кодировщик/декодировщик, соответствующий стандарту `RFC 2045`.


Вот более подробное описание методов `getEncoder()`, `getDecoder()`, `getUrlEncoder()`, `getUrlDecoder()`, `getMimeEncoder()` и `getMimeDecoder()` в классе `java.util.Base64`:

1. **`getEncoder()`:** Этот метод возвращает кодировщик Base64, соответствующий стандарту RFC 4648. Кодировщик, возвращаемый этим методом, используется для преобразования байтовых массивов или строк в строки Base64.
    
2. **`getDecoder()`:** Этот метод возвращает декодировщик Base64, соответствующий стандарту RFC 4648. Декодировщик, возвращаемый этим методом, используется для преобразования строк Base64 обратно в байтовые массивы или строки.
    
3. **`getUrlEncoder()`:** Этот метод возвращает URL-safe кодировщик Base64, соответствующий стандарту RFC 4648. URL-safe кодировщик заменяет символы, которые могут быть неправильно интерпретированы в URL, что делает результатные строки Base64 безопасными для использования в URL.
    
4. **`getUrlDecoder()`:** Этот метод возвращает URL-safe декодировщик Base64, соответствующий стандарту RFC 4648. URL-safe декодировщик используется для декодирования строк Base64, которые могут быть закодированы с использованием URL-safe формата.
    
5. **`getMimeEncoder()`:** Этот метод возвращает MIME кодировщик Base64, соответствующий стандарту RFC 2045. MIME кодировщик добавляет разделители строк и может выполнять другие специфические преобразования, чтобы соответствовать стандарту MIME.
    
6. **`getMimeDecoder()`:** Этот метод возвращает MIME декодировщик Base64, соответствующий стандарту RFC 2045. MIME декодировщик используется для декодирования строк Base64, которые соответствуют стандарту MIME и могут содержать разделители строк и другие дополнительные символы.

#### 8. Как создать Base64 кодировщик и декодировщик? 
![[Pasted image 20240325154609.png]]

#### 9. Какие дополнительные методы для работы с ассоциативными массивами (maps) появились в Java 8? 
1. **`forEach`**: Добавляет возможность итерации по элементам мапы с помощью функции обратного вызова.
```java
void forEach(BiConsumer<? super K, ? super V> action);
```

2. **`compute` и `computeIfAbsent`**: Позволяют вычислять значение для указанного ключа или добавлять новое значение, если ключ отсутствует.
```java
V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction);
V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction);
```

3. **`computeIfPresent`**: Позволяет вычислять новое значение для указанного ключа только в том случае, если ключ уже присутствует в мапе.
```java
V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction);
```

4. **`merge`**: Позволяет объединять значения для указанного ключа, используя заданную функцию объединения.
```java
V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction);
```

5. **`getOrDefault`**: Возвращает значение по указанному ключу, либо заданное значение по умолчанию, если ключ отсутствует в мапе.
```java
V getOrDefault(Object key, V defaultValue);
```

6. **`replaceAll`**: Заменяет каждое значение в мапе на результат применения заданной функции к текущему значению.
```java
void replaceAll(BiFunction<? super K, ? super V, ? extends V> function)
```

#### 10. Что такое LocalDateTime? 
`LocalDateTime` объединяет вместе `LocaleDate и LocalTime`, содержит дату и время в календарной системе ISO-8601 без привязки к часовому поясу.
Время хранится с точностью до наносекунды. Содержит множество удобных методов,
таких как `plusMinutes, plusHours, isAfter, toSecondOfDay и т.д.`
Объекты `LocalDateTime` являются неизменяемыми, что означает, что после создания объекта его значения не могут быть изменены. 

#### 11. Что такое ZonedDateTime?
`ZonedDateTime` - это класс в пакете `java.time`, представляющий собой дату и время с учетом часового пояса. Он расширяет функциональность класса `LocalDateTime`, добавляя информацию о временной зоне.

Важные особенности класса `ZonedDateTime`:
1. **Учет часового пояса:** `ZonedDateTime` хранит дату, время и информацию о часовом поясе, что позволяет точно определить момент времени относительно всемирного времени.
    
2. **Манипуляции с временем и временными зонами:** Класс `ZonedDateTime` предоставляет методы для выполнения операций с датой и временем, а также с временными зонами, такие как конвертация из одной временной зоны в другую, добавление или вычитание дней, часов, минут и т.д.
    
3. **Устойчивость к изменениям временных зон:** При использовании `ZonedDateTime` можно быть уверенным, что время будет корректно отображено, даже если произойдут изменения в правилах временных зон (например, из-за перехода на летнее/зимнее время).

#### 12. Что такое Guava?
По сути — это набор основных библиотек Google для Java с открытым исходным кодом.
Внутри можно встретить библиотеку графов, новые типы коллекций (multiset etc.),
различные функциональные типы, богатый набор утилит для параллелизма, обработки строк, хэширования.
	• использовать firstNonNull из класса Objects библиотеки Guava вместо записи “if else”
	• использовать Object.equals(a, b) для безопасной проверки на равенство.
	• использовать Multimap вместо Map со значениями List или Set.
	• использовать Multiset для подсчета количества вхождений объекта