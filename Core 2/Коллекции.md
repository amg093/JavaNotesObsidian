#### 1. Что такое «коллекция»? 
Для хранения наборов данных в Java предназначены массивы. Однако их не всегда
удобно использовать, прежде всего потому, что они имеют фиксированную длину.
Кроме того, у массивов нет никакой защиты от изменений.
Эту проблему в Java решают коллекции.

**Коллекции** – это "контейнер" или группа, т.е. совокупность объектов, которые мы
храним вместе. Или так: коллекции — это наборы однородных элементов (например,
страницы в книге, яблоки в корзине или люди в очереди).

Инструменты для работы с такими структурами в Java содержатся в Java Collections
Framework, классы коллекций располагаются в пакете java.util
Классы коллекций являются дженериками и параметризируются типом хранимых
внутри элементов. В качестве значения дженерик параметра может использоваться
только ссылочный тип, поэтому все коллекции в java работают со ссылочными типами.

Интерфейс Collection является базовым для всех коллекций, определяя основной функционал. Он обобщенный и расширяет интерфейс Iterable, поэтому все объекты коллекций можно перебирать в цикле по типу for-each.

#### 2. Расскажите про иерархию коллекций 
![[Pasted image 20240319045713.png]]
![[Pasted image 20240319045728.png]]

#### 3. Почему Map — это не Collection, в то время как List и Set являются Collection? 
Однако интерфейс `Map` не расширяет интерфейс `Collection`. Вместо этого он представляет собой отдельный тип коллекции, который ассоциирует ключи с значениями. **Ключи в `Map` должны быть уникальными, в отличие от элементов в `Collection`, которые могут дублироваться.**

Этот дизайн сделан для того, чтобы отразить различия в структурах данных: списки и множества предназначены для хранения коллекций объектов, в то время как карты предназначены для хранения пар "ключ-значение". Каждый из этих типов обеспечивает разные возможности и операции, и поэтому они представлены отдельными интерфейсами.

#### 4. В чем разница между java.util.Collection и java.util.Collections? 
1. **java.util.Collection**:
    - `java.util.Collection` является интерфейсом, определяющим общие методы для всех коллекций в Java Collections Framework.
    - Этот интерфейс определяет операции, которые можно выполнять с коллекциями, такие как добавление, удаление, проверка на наличие элемента, итерация и т.д.
    - Конкретные реализации этого интерфейса включают в себя классы `ArrayList`, `LinkedList`, `HashSet`, `TreeSet` и другие.
Методы:
1. `add(E element)`: Добавляет элемент в коллекцию.
2. `addAll(Collection<? extends E> collection)`: Добавляет все элементы из указанной коллекции в данную коллекцию.
3. `remove(Object object)`: Удаляет первое вхождение указанного объекта из коллекции, если он присутствует.
4. `removeAll(Collection<?> collection)`: Удаляет из коллекции все элементы, которые содержатся в указанной коллекции.
5. `retainAll(Collection<?> collection)`: Удаляет из коллекции все элементы, которые не содержатся в указанной коллекции.
6. `contains(Object object)`: Возвращает true, если коллекция содержит указанный объект.
7. `containsAll(Collection<?> collection)`: Возвращает true, если коллекция содержит все элементы из указанной коллекции.
8. `isEmpty()`: Возвращает true, если коллекция не содержит элементов.
9. `size()`: Возвращает количество элементов в коллекции.
10. `clear()`: Удаляет все элементы из коллекции.

1. **java.util.Collections**:
    - `java.util.Collections` является утилитарным классом, предоставляющим различные статические методы для работы с коллекциями.
    - Этот класс предоставляет методы для выполнения различных операций над коллекциями, таких как сортировка, перетасовка, поиск максимального и минимального элементов, создание неизменяемых коллекций и многое другое.
    - Методы этого класса обычно принимают коллекцию в качестве параметра и возвращают новую коллекцию или изменяют переданную коллекцию в соответствии с выполненной операцией.
    - Все методы этого класса вызывают исключение NullPointerException, если
	  предоставленные им коллекции или объекты класса имеют значение null.
Методы:
1. `sort(List<T> list)`: Сортирует список с использованием естественного порядка.
2. `shuffle(List<T> list)`: Перемешивает элементы списка.
3. `reverse(List<T> list)`: Разворачивает порядок элементов в списке.
4. `binarySearch(List<? extends Comparable<? super T>> list, T key)`: Производит бинарный поиск указанного элемента в списке с использованием алгоритма двоичного поиска.
5. `max(Collection<? extends T> coll)`: Возвращает максимальный элемент в коллекции, используя естественный порядок сравнения.
6. `min(Collection<? extends T> coll)`: Возвращает минимальный элемент в коллекции, используя естественный порядок сравнения.

>[!NOTE] 
>Все классы реализации Collection общего назначения (которые обычно реализуют Collection косвенно через один из его под-интерфейсов) должны предоставлять два «стандартных» конструктора:
	• конструктор void (без аргументов), который создает пустую коллекцию
	• и конструктор с одним аргументом типа Коллекция, которая создает новую коллекцию с теми же элементами, что и ее аргумент

#### 5. Какая разница между итераторами с fail-fast и fail-safe поведением? (с примерами) 
*Короткий ответ:* **Fail-fast** итератор генерирует исключение `ConcurrentModificationException`, если коллекция меняется во время итерации, а **fail-safe** – нет.

1. **Fail-Safe Итераторы**: В контексте Java, fail-safe итераторы предназначены для обеспечения безопасного итерирования (прохода) по коллекциям (например, спискам, множествам) в случае, если коллекция изменяется другими процессами или потоками во время итерации. Эти итераторы создают копию исходной коллекции и итерируются по этой копии, что позволяет избежать `ConcurrentModificationException`. Такие итераторы отражают состояние коллекции на момент создания итератора и не обнаруживают изменения, произведенные в коллекции после создания итератора. Эти коллекции включают в себя классы из пакета `java.util.concurrent`, такие как `ConcurrentHashMap` и `CopyOnWriteArrayList`.
    
2. **Fail-Fast Итераторы**: Эти итераторы, напротив, обнаруживают («fail-fast») любые изменения, произведенные в коллекции во время итерации. Если коллекция модифицируется во время итерации, эти итераторы немедленно выбрасывают `ConcurrentModificationException`. Они предпочитают обеспечить консистентность, вместо того чтобы продолжать работу с возможно устаревшими данными. В стандартной библиотеке Java, итераторы для коллекций, таких как `ArrayList`, `HashMap`, `HashSet` и т. д., обычно являются fail-fast.
##### **Примеры итераторов, реализующих поведение fail-safe
1. **ConcurrentHashMap**: Предоставляет fail-safe итераторы для итерирования по ключам и значениям коллекции.
    
2. **ConcurrentSkipListMap и ConcurrentSkipListSet**: Эти коллекции реализуют структуры данных на основе skip list и также обеспечивают fail-safe итераторы.
    
3. **CopyOnWriteArrayList и CopyOnWriteArraySet**: Эти коллекции создают копию элементов при каждой модификации, что позволяет безопасно итерироваться по ним даже во время изменения.

#### 6. Чем различаются Enumeration и Iterator? 
Это два интерфейса в пакете java.util используются для обхода элементов коллекции.
Хотя они выполняют одну и ту же функцию, между ними существуют некоторые различия.

Используя Enumeration, вы можете только перемещаться по коллекции, а с помощью
Итератора можете также удалить элемент при обходе коллекции.

Методы – это основное различие между интерфейсами `Enumeration` и `Iterator`.
Можно сказать, что `Iterator` – это расширенная версия `Enumeration`.

**Enumeration** — это устаревший интерфейс, используемый для обхода только устаревших
классов, таких как Vector, HashTable и Stack.

Поскольку Iterator НЕ является устаревшим, то именно он используется для обхода
большинства классов в Collection Framework. Например, для обхода ArrayList, LinkedList,
HashSet, LinkedHashSet, TreeSet, HashMap, LinkedHashMap, TreeMap и т. д.

**Итератор** является *«быстрым» fail-fast итератором*, то есть будет выброшено исключение
ConcurrentModificationException, если коллекция изменится во время итерации с
применением собственного метода remove(). Напротив, Enumeration не выбросит никаких
исключений, даже если коллекция изменяется во время итерации.
![[Pasted image 20240319061827.png]]
>[!TIP]
>Согласно Java API Docs, итератор всегда предпочтительнее перечисления:
Функции Enumeration дублируются интерфейсом Iterator. Кроме того, Iterator добавляет операцию удаления и имеет более короткие имена методов.
В новых реализациях следует рассмотреть возможность использования Iterator вместо Enumeration.

#### 7. Как избежать ConcurrentModificationException во время перебора коллекции? 
1. Попробовать подобрать другой итератор, работающий по принципу fail-safe.
К примеру, для `List` можно использовать `ListIterator`.
2. Использовать `ConcurrentHashMap` и `CopyOnWriteArrayList`
3. Преобразовать список в массив и перебирать массив
4. Блокировать изменения списка на время перебора с помощью блока `synchronized`
Отрицательная сторона последних двух вариантов – это ухудшение производительности 

#### 8. Как между собой связаны Iterable, Iterator и «for-each»? 
`Interface Iterable<T>` – это интерфейс, который реализуют коллекции, у него есть метод
`iterator<T>`, который возвращает объект Итератор по элементам типа T.

Iterator — объект с состоянием итерации (бегунок, курсор, указатель).
Он позволяет проверить, есть ли еще больше элементов, используя `hasNext()`, и перейти
к следующему элементу (если есть), используя `next()`. Так же есть метод `remove()`.

`forEach` — это разновидность цикла for, метод интерфейса Iterable. Выполняет
заданное действие для каждого элемента Iterable до тех пор, пока все элементы не будут
обработаны или действие не вызовет исключение. Также помимо этого метода, есть for-each loop.

>[!TIP]
>Под капотом `for-each` (enhanced for loop) использует итератор. Хотя это выглядит как упрощенный синтаксис, на самом деле он скрывает работу с итератором и автоматически выполняет итерацию по элементам коллекции или массива.
>
Внутренне компилятор Java преобразует конструкцию `for-each` в использование итератора, что делает код более читабельным и удобным для программиста.
>
Вот как работает `for-each` под капотом:
>1. Компилятор Java генерирует код, который использует итератор для перебора элементов коллекции или массива.
>2. Для коллекций компилятор вызывает метод `iterator()` для получения объекта `Iterator`.
>3. Затем компилятор использует цикл `while` и методы `hasNext()` и `next()` итератора для перебора элементов.
>4. Для массивов компилятор создает временный объект `Iterator`  и использует его для перебора элементов.

#### 9. Можно ли, обходя ArrayList, удалить элемент? Какое вылетит исключение? 
Чтобы безопасно удалять элементы из `ArrayList` во время его обхода, вам следует использовать метод `Iterator.remove()`. Этот метод является частью интерфейса `Iterator` и предназначен для удаления текущего элемента, который был возвращен последним вызовом метода `next()` итератора.
Т.е явно создаем экземпляр `Iterator`, и уже через него `iterator.remove()` удаляем элемент.
![[Pasted image 20240319063819.png]]
#### 10. Как удалить элемент из ArrayList при итерации? 
**Единственный способ удалить элемент из коллекции при обходе, не получив при**
**этом `ConcurrentModificationException` или неопределенное поведение – удалить с**
**помощью `remove()` того же инстанса итератора. Вариант `ListIterator` поможет, если в**
**теле цикла требуется и работа с индексами.**

Обычно формулируется в виде задачи на внимательность «что здесь не так», например →
![[Pasted image 20240322024720.png]]
Подвох в том, что итератор `ArrayList`, который используется в таком варианте цикла for,
является fail-fast, то есть не поддерживает итерацию с параллельной модификацией.
А параллельная модификация случается даже в одном потоке, что демонстрирует этот
пример. Следующий шаг итератора после удаления элемента выбросит `ConcurrentModificationException`.

Не исключение, но неожиданный результат получится если пользоваться не итератором,
а обычным циклом for – при каждом удалении нумерация элементов будет сдвигаться.

Некоторые коллекции `(CopyOnWriteArrayList и ConcurrentHashMap)`, адаптированные
под многопоточную среду и имеют fail-safe итераторы
#### 11. Как поведёт себя коллекция, если вызвать iterator.remove()? 
Если вызову `iterator.remove()` предшествовал вызов `iterator.next() или iterator.previous()`, то `iterator.remove()` удалит элемент коллекции, на который указывает итератор, в противном случае будет выброшено `IllegalStateException()`.
#### 12. Чем Set отличается от List? 
**List** – упорядоченный список с возможностью содержания дубликатов и доступа по
индексу (random access, произвольно получить элемент по индексу).
**Set** – не обязательно упорядоченное множество уникальных (с точки зрения equals)
значений. Чтобы из Set получить элемент, используется Iterator.

1. **Уникальность элементов**: Элементы в `Set` должны быть уникальными, тогда как в `List` могут содержаться дубликаты элементов.
    
2. **Упорядоченность**: В `List` порядок элементов обычно определяется порядком вставки элементов или в соответствии с некоторым критерием (например, сортировкой). В `Set` нет гарантии относительного порядка элементов, хотя некоторые реализации `Set`, такие как `LinkedHashSet`, сохраняют порядок вставки элементов.
    
3. **Доступ по индексу**: `List` предоставляет методы для доступа к элементам по их индексу (например, `get(index)`), тогда как в `Set` нет прямой поддержки доступа к элементам по индексу, потому что элементы не имеют определенного порядка.
    
4. **Использование итератора**: Как `List`, так и `Set` предоставляют методы для итерации по элементам (например, `iterator()`), но для `List` порядок итерации соответствует порядку вставки элементов, в то время как для большинства реализаций `Set` порядок итерации не определен.

#### 13. Расскажите про интерфейс Set. 
**Set** — переводится как "множество". От очереди и списка Set отличается более абстрактным подходом к хранению элементов. 
Set - это "коллекция, которая не содержит дублирующихся элементов". Интересно, что сам интерфейс Set не добавляет новых методов к интерфейсу Collection, а лишь уточняет требования относительно отсутствия дубликатов.

В основе Set лежит Map, где ключи представляют собой элементы множества Set, а значения - это константа-заглушка, обычно объект класса Object, каждый раз выступающий в роли значения в Map. 
***Почему так?*** *Поскольку Map хранит пары ключ-значение, а набору Set нужны только значения, то элемент Set занимает место ключа, а место значения Java заполняет пустым объектом (new Object).

Метод add у множеств возвращает `true` если элемент был добавлен, и `false` если элемент уже есть в множестве.

#### 14. Расскажите про реализации интерфейса Set 
`Set` имеет несколько связанных интерфейсов.

**SortedSet**:
- Дают линейный порядок множества, элементы упорядочены по возрастанию.
- Порядок определяется натуральным или переданным Comparator.
- Добавляют методы для получения подмножества (tailSet, headSet, subSet).
- Расширяются интерфейсом **NavigableSet** для итерации по порядку и получения ближайших элементов.

**NavigableSet**:
- Добавляет методы для навигации и итерации в обратном порядке (descendingIterator).
- Позволяет получить вид на себя в обратном порядке через метод descendingSet.
- Умеет получать и убирать минимальный и максимальный элементы через pollFirst и pollLast.

**Другие реализации**:
- **HashSet**: Основан на хэш-коде, не гарантирует порядок элементов.
- **LinkedHashSet**: Хранит порядок вставки элементов, использует двусвязный список.
- **TreeSet**: Хранит элементы в отсортированном порядке с помощью красно-черного дерева.

##### **Для множеств ENUM-ов есть специальный класс java.util.EnumSet? Зачем? Чем авторов не устраивал HashSet или TreeSet?**
`EnumSet` является специализированной реализацией интерфейса `Set` для использования с перечислениями (`Enum`). Он использует массив битов (битовый вектор) для хранения значений, что обеспечивает высокую компактность и эффективность.(каждое значение занимает 1 бит)

#### 15. Зачем нужны и чем отличаются интерфейсы Comparable и Comparator? 
**Интерфейс Comparable** (сравнимый) - содержит один единственный метод `int compareTo(E item)`, который сравнивает текущий объект с объектом, переданным в качестве параметра. Если этот метод возвращает отрицательное число, то текущий объект будет располагаться перед тем, который передается через параметр. Если метод вернет положительное число, то, наоборот, после второго объекта. Если метод возвратит ноль, значит, оба объекта равны.

**Интерфейс Comparator** - содержит ряд методов, ключевым из которых является метод `compare()`, который возвращает числовое значение - если оно отрицательное, то объект a предшествует объекту b, иначе - наоборот. А если метод возвращает ноль, то объекты равны. Для применения интерфейса нам сначала надо создать класс компаратора, который реализует этот интерфейс. 
Например, сортируем дома по цене → Создадим объект класса `PriceComparator`, а потом вызовем у `ArrayList` метод `sort()`, который принимает на вход объект класса, реализующего интерфейс `Comparator` и отсортируем `ArrayList`.

**РАЗНИЦА:**
1. **Comparable**:
    - Реализуется внутри самого класса.
    - Определяет естественный порядок сравнения объектов того же типа.
    - Включает только один метод `compareTo()`.
    - Используется для сравнения объектов по умолчанию.
2. **Comparator**:
    - Реализуется вне класса.
    - Позволяет определить пользовательские способы сравнения объектов.
    - Может быть использован для сравнения объектов разных типов или для определения нескольких способов сортировки одного типа объектов.
    - Включает несколько методов, но ключевым из них является метод `compare()`.
    - Обычно передается в качестве аргумента при сортировке с использованием методов из классов Collections или Arrays.

#### 16. В чем отличия TreeSet и HashSet? 
**Класс HashSet** реализует интерфейс **Set**, основан на хэш-таблице (оптимизирован для быстрого поиска). Не запоминает порядок добавления элементов. Может хранить null.

**Класс TreeSet** реализует интерфейс **SortedSet** реализован на основе красно-чёрного дерева (самобалансирующееся)(хранит элементы в отсортированном по возрастанию порядке).

1. **Внутренняя структура данных**:
    - `HashSet`: Основан на хэш-таблице, которая использует хэш-функцию для быстрого доступа к элементам. Это обеспечивает высокую производительность при добавлении, удалении и поиске элементов.
    - `TreeSet`: Основан на красно-черном дереве, которое автоматически сортирует элементы по их значению в порядке возрастания. Это обеспечивает быстрый доступ к минимальному и максимальному элементам и эффективную сортировку элементов.
    
2. **Упорядоченность элементов**:
    - `HashSet`: Не гарантирует какого-либо порядка элементов, они могут располагаться в произвольном порядке, определяемом хэш-функцией.
    - `TreeSet`: Хранит элементы в отсортированном порядке по возрастанию и предоставляет возможность быстрого доступа к элементам в отсортированном порядке.
    
3. **Поддержка null**:
    - `HashSet`: Может хранить один элемент null.
    - `TreeSet`: Не допускает хранение null-элементов.
    
4. **Производительность операций**:
    - `HashSet`: Операции добавления, удаления и поиска выполняются за время O(1) в среднем.
    - `TreeSet`: Операции добавления, удаления и поиска выполняются за время O(log n), где n - количество элементов в множестве.
#### 17. Чем LinkedHashSet отличается от HashSet? 
`LinkedHashSet` отличается от `HashSet` в том, что он использует внутри структуру данных `LinkedHashMap` вместо стандартной `HashMap`. Это означает, что в `LinkedHashSet` порядок элементов при обходе коллекции будет идентичен порядку их добавления, что называется порядком вставки (insertion-order). Это достигается благодаря тому, что `LinkedHashMap` хранит элементы в порядке, в котором они были добавлены.

Кроме того, при добавлении элемента, который уже присутствует в `LinkedHashSet`, порядок обхода элементов не изменяется. Это означает, что если элемент повторно добавляется в множество, его положение в порядке итерации остается таким же, как и ранее.

>[!TIP]
>Суть в том, что в `LinkedHashSet` порядок итерации определяется порядком вставки элементов, а не их хэш-кодами, как в случае с обычным `HashSet`. Это полезно, если вам нужно сохранить порядок, в котором элементы были добавлены в коллекцию, или если вам важно, чтобы порядок обхода коллекции соответствовал порядку добавления элементов.

#### 18. Что будет, если добавлять элементы в TreeSet по возрастанию? 
Короткий ответ: В основе TreeSet лежит красно-черное дерево, которое умеет само себя балансировать. В итоге, TreeSet все равно в каком порядке вы добавляете в него элементы,
преимущества этой структуры данных будут сохраняться.
#### 19. Что будет в этом случае? 
![[Pasted image 20240322033850.png]]
Получим 1 элемент, т.к из-за реализации метода compare(), который возвращает 0, будет считать, что все элементы равны первому добавленному.

#### 20. Как устроен HashSet, сложность основных операций. 
`HashSet` в Java базируется на структуре данных `HashMap`, где ключи являются элементами `HashSet`, а значения представлены константой-заглушкой, которая всегда одинакова и используется только для обозначения наличия элемента в `HashMap`. Эта константа часто называется "PRESENT" и  имеет тип `Object`.

Хранение элементов в `HashSet` осуществляется таким образом, чтобы их можно было быстро найти. Метод `contains()` в `HashSet` выполняется быстро, потому что элементы хранятся в "корзинах" или "бакетах", которые выбираются на основе значений самих элементов с использованием хэш-кода.

Под капотом `HashMap` внутри `HashSet` представляет собой массив, известный как таблица хэш-кодов (hash table). Этот массив содержит набор элементов, и каждый элемент таблицы имеет определенный индекс, который вычисляется с использованием хэш-функции от ключа элемента. В случае коллизий, то есть когда два или более ключа имеют одинаковый хэш-код, эти элементы размещаются в одной корзине (bucket) в виде связанного списка или другой структуры данных.

Операции добавления, удаления и поиска в `HashSet` выполняются за константное время O(1), что означает, что они происходят быстро, при условии, что хэш-функция правильно распределяет элементы по корзинам.
В худшем случае, когда все элементы попадают в одну корзину из-за коллизии хэш-кодов, сложность также может быть O(n).
Для получения элементов из `Set` используется `Iterator`, операции быстрые.

>[!CAUTION]
>У Set нет метода get()!

Несколько важных аспектов `HashSet`:

1. Реализует интерфейс Set, что означает, что он может хранить только уникальные значения.
2. Может хранить значение NULL.
3. Порядок добавления элементов не сохраняется, он определяется хэш-кодом элементов.
4. Реализует интерфейсы Serializable и Cloneable.
5. Для поддержания постоянного времени выполнения операций, время, затрачиваемое на действия с `HashSet`, должно быть прямо пропорционально количеству элементов в `HashSet` и "емкости" встроенного экземпляра `HashMap` (количество "корзин").

Важно не устанавливать слишком высокую начальную емкость (или слишком низкий коэффициент загрузки) для поддержания производительности.
![[Pasted image 20240322044554.png]]

#### 21. Как устроен LinkedHashSet, сложность основных операций. 
Класс `LinkedHashSet` расширяет класс `HashSet`, не добавляя никаких новых методов.
Класс поддерживает связный список элементов множества в том порядке, в котором они
вставлялись. Это позволяет организовать упорядоченную итерацию вставки в набор.

###### **Сложность операций:**
1. **Добавление элемента**:
    - В среднем, операция добавления элемента имеет сложность O(1), так же как и в `HashSet`. Однако, если происходит изменение размера внутренней хэш-таблицы (`HashMap`), сложность может быть O(n) из-за перехэширования. Но сохранение порядка вставки элементов не повлияет на сложность добавления.
    
2. **Удаление элемента**:
    - Операция удаления элемента также имеет среднюю сложность O(1), так же как и в `HashSet`. В случае изменения размера внутренней хэш-таблицы, сложность может быть O(n) из-за перехэширования.
    
3. **Поиск элемента**:
    - Операция поиска элемента также имеет среднюю сложность O(1), так же как и в `HashSet`.  O(n) - когда все элементы попадают в одну и ту же корзину (bucket) в хэш-таблице, и приходится проходить через все элементы этой корзины, чтобы найти нужный элемент.
    
4. **Итерация по элементам**:
    - Итерация по элементам `LinkedHashSet` также выполняется за время O(n), так как элементы хранятся в порядке их вставки, и поэтому все элементы должны быть просмотрены последовательно.

`LinkedHashSet` в Java представляет собой комбинацию хэш-таблицы (`HashMap`) и двусвязного списка.

Каждый элемент в `LinkedHashSet` хранится в узле, который содержит ссылки на предыдущий и следующий элементы (при условии, что элементы вставлялись последовательно).

В памяти `LinkedHashSet` представляется следующим образом:
1. Для быстрого доступа к элементам используется хэш-таблица (`HashMap`), которая содержит корзины (buckets), в которых хранятся ссылки на узлы.
2. Каждый узел содержит сам элемент, а также ссылки на предыдущий и следующий узлы.
3. Ссылки на узлы обеспечивают порядок вставки элементов, что позволяет `LinkedHashSet` сохранять порядок вставки элементов при их итерации.

Таким образом, `LinkedHashSet` занимает дополнительное место в памяти для хранения ссылок на узлы двусвязного списка, но благодаря этому он сохраняет порядок вставки элементов.

#### 22. Как устроен TreeSet, сложность основных операций.        
В основе TreeSet лежит TreeMap, у которого:
	• ключи – это элементы TreeSet
	• значения – это константа-заглушка
HashSet не может гарантировать, что данные будут отсортированы, так как работает по другому алгоритму. Если сортировка для нас важна, то использовать TreeSet.

1. **Добавление элемента**:
    - Вставка элемента в `TreeSet` имеет сложность O(log n), где n - количество элементов в дереве. Дерево поддерживается в сбалансированном состоянии, что гарантирует, что высота дерева будет O(log n), и поиск, вставка и удаление будут выполняться за время, пропорциональное логарифму количества элементов.
    
2. **Удаление элемента**:
    - Удаление элемента из `TreeSet` также имеет сложность O(log n), где n - количество элементов в дереве. Дерево автоматически перебалансируется после удаления элемента, чтобы сохранить свою сбалансированность.
    
3. **Поиск элемента**:
    - Поиск элемента в `TreeSet` также имеет сложность O(log n), где n - количество элементов в дереве. Это происходит благодаря структуре красно-чёрного дерева, которая обеспечивает эффективный поиск элементов.
    
4. **Итерация по элементам**:
    - Итерация по элементам `TreeSet` занимает время O(n), где n - количество элементов в дереве. Это потому, что каждый элемент должен быть посещен ровно один раз в процессе обхода всего дерева.

#### 23. Расскажите про интерфейс List 
`List` – список или упорядоченная последовательность элементов, позволяющая хранить
дубликаты и `null`. Каждый элемент имеет индекс (от нуля и дальше), поиск по индексу.
Он расширяет интерфейс `Collection` и определяет методы для работы с упорядоченным списком элементов.

#### 24. Как устроен ArrayList, сложность основных операций. 
ArrayList реализует интерфейс List. 
ArrayList – это динамический массив, т.е. может менять свой размер во время исполнения программы, при этом не обязательно указывать размерность при создании объекта. Элементы ArrayList могут быть абсолютно любых типов в том числе и null. 

Используем тогда, когда нам нужна структура, похожая на массив, но где нам нужно добавлять/удалять/изменять элементы. Получение и изменение элементов выполняется быстро, поскольку эти операции просто обращаются к соответствующему элементу массива. В основе ArrayList лежит массив Object (элементами явл. Объекты типа Object). 

Ёмкость capacity массива по дефолту – 10 мест (не путать размер и ёмкость). 
Размер массива – это сколько по факту лежит элементов в массиве, а ёмкость – это потенциально возможное кол-во мест).

**Скорость основных операций**
	• Быстрый доступ к элементам по индексу за константное время O(1)
	• Доступ к элементам по значению за линейное время O(n)
	• Медленный, когда вставляются и удаляются элементы из «середины» списка
	• Позволяет хранить любые значения в том числе и null
	• Не синхронизирован

**Конструкторы `ArrayList`:**
1. `ArrayList()`: Создает пустой список.
2. `ArrayList(Collection<? extends E> c)`: Создает список, содержащий элементы указанной коллекции, расположенные в том порядке, в котором они возвращаются итератором коллекции.
3. `ArrayList(int initialCapacity)`: Создает пустой список с начальной емкостью, равной заданной.
##### **Алгоритм основных операций**
Если вызывается конструктор без параметров, то по умолчанию будет создан массив из 10-ти элементов типа Object (с приведением к типу, разумеется), индексы от 0 до 9. `elementData = (E[]) new Object[10]`. Можно использовать конструктор `ArrayList(capacity)` и указать свою начальную емкость.

1. Добавление элементов `list.add("0")`: 
	Внутри метода `add(value)` происходят следующие вещи:
	- проверяется, достаточно ли места в массиве для вставки нового элемента `ensureCapacity(size + 1)`;
	- добавляется элемент в конец (согласно значению `size`) массива `elementData[size++] = element;`.
Если места в массиве недостаточно, новая емкость рассчитывается по формуле `(oldCapacity * 3) / 2 + 1`. Второй момент — это копирование элементов. Оно осуществляется с помощью нативного метода `System.arraycopy()`, который написан не на языке Java.

2. Добавление в «середину» списка `list.add(5, "100")`: 
	Добавление элемента на позицию с определенным индексом происходит в три этапа:
	- проверяется, достаточно ли места в массиве для вставки нового элемента `ensureCapacity(size+1)`;
	- подготавливается место для нового элемента с помощью `System.arraycopy()`;
	- перезаписывается значение у элемента с указанным индексом `elementData[index] = element; size++;`.

В случаях, когда происходит вставка элемента по индексу и при этом в вашем массиве нет свободных мест, то вызов `System.arraycopy()` случится дважды: первый в `ensureCapacity()`, второй в самом методе `add(index, value)`, что явно скажется на скорости всей операции добавления. В случаях, когда в исходный список необходимо добавить другую коллекцию, да еще и в «середину», стоит использовать метод `addAll(index, Collection)`. И хотя, данный метод скорее всего вызовет `System.arraycopy()` три раза, в итоге это будет гораздо быстрее поэлементного добавления.

3. Удаление элементов: 
	Удалять элементы можно двумя способами:
	- по индексу `remove(index)`;
	- по значению `remove(value)`.
С удалением элемента по индексу всё достаточно просто: `list.remove(5)`;
- Сначала определяется, какое количество элементов надо скопировать
    ```java
    int numMoved = size - index - 1;
    ```
- затем копируем элементы используя `System.arraycopy()`
    ```java
    System.arraycopy(elementData, index + 1, elementData, index, numMoved);
    ```
- уменьшаем размер массива и забываем про последний элемент
    ```java
    elementData[--size] = null; // Let gc do its work
    ```

При удалении по значению, в цикле просматриваются все элементы списка, до тех пор, пока не будет найдено соответствие. Удален будет лишь первый найденный элемент. 
При удалении элементов текущая величина capacity не уменьшается, что может привести к своеобразным утечкам памяти. Поэтому не стоит пренебрегать методом `trimToSize()`.

#### 25. Как устроен LinkedList, сложность основных операций. 
LinkedList – список связанных элементов, каждый из которых хранит ссылки на следующий и предыдущий элементы в списке, цепочке. Бывает односвязный и двусвязный списки.

**ВАЖНО!** В каком порядке элементы добавлены, в таком они и находятся.
#### Почему LinkedList реализует и List, и Deque? (22)
LinkedList — класс, реализующий два интерфейса — List и Deque.
Это обеспечивает возможность создания **двунаправленной очереди** из любых (в том числе и null) элементов. Каждый объект, помещенный в связанный список, является узлом/нодом. Каждый узел содержит элемент, ссылку на предыдущий и следующий узел. Фактически связанный список состоит из последовательности узлов, каждый из которых предназначен для хранения объекта определенного при создании типа.

Каждый элемент "знает" своих соседей и ссылается на них. И знает ТОЛЬКО соседей. Чтобы вставить элемент в середину такого списка, достаточно изменить ссылки на его будущих соседей. Но чтобы получить элемент Nº 130, нам нужно перебрать каждый элемент от 0 до 130. 
Операции получения и изменения выполняются медленно! 
Если следующего элемента нет, то предыдущий элемент имеет ссылку на null и так LL понимает, что это конец. Бывают двух видов: DOUBLY (элементы ссылаются на 2х соседей) и SINGLY (1 ссылка на следующего)
##### Алгоритм основных операций
1. **Создание связанного списка:** `LinkedList<Integer> numbers = new LinkedList<>();`
	Данный код создает объект класса LinkedList и сохраняет его в ссылке `numbers`. Созданный объект предназначен для хранения целых чисел (`Integer`). Пока этот объект пуст.

2. **Добавление объекта в конец связанного списка:** `numbers.add(...)`
	Под «капотом» этот метод вызывает ряд других методов, обеспечивающих создание объекта типа `Integer`, создание нового узла, установку объекта класса `Integer` в поле `item` этого узла, добавление узла в конец списка и установку ссылок на соседние узлы.
	Для установки ссылок на предыдущий и следующий элементы LinkedList использует
	объекты своего вложенного класса Node.
	При каждом добавлении объекта в список создается один новый узел, а также
	изменяются значения полей связанного списка (size, first, last).

3. **Добавление объекта в середину связанного списка:** `numbers.add(index: 2, elem: 1)`
	Как и метод `add(element)`, данный метод вызывает несколько других методов. Сначала осуществляется проверка значения `index`, которое должно быть положительным числом, меньшим или равным размеру списка. Если `index` не удовлетворит этим условиям, то будет сгенерировано исключение `IndexOutOfBoundsException`. Затем, если `index` равен размеру коллекции, то осуществляются действия, описанные в п. 2, так как фактически необходимо вставить элемент в конец существующего списка.
	Если же index не равен size списка, то осуществляется вставка перед элементом, который
	до этой вставки имеет заданный индекс.

4. **Удаление объекта из связанного списка:** `numbers.remove(Integer.valueOf(5))`
	Для удаления одного элемента из списка класс `LinkedList` предлагает нам аж 10 методов, различающихся по типу возвращаемого значения, наличию или отсутствию выбрасываемых исключений, а также способу указания, какой именно элемент следует удалить.
	![[Pasted image 20240322054556.png]]
	Итак, что же происходит при вызове метода `remove(object)`?
	1. Сначала искомый объект сравнивается по порядку со всеми элементами, сохраненными в узлах списка, начиная с нулевого узла.
	2. Когда найден узел, элемент которого равен искомому объекту, первым делом элемент сохраняется в отдельной переменной.
	3. Потом переопределяются ссылки соседних узлов так, чтобы они указывали друг на друга.
	4. Затем обнуляется значение узла, который содержит удаляемый объект, а также уменьшается размер коллекции.
	
	Когда мы используем метод `remove(index)`, также вызывающий метод `unlink(node)`, то значение данного элемента последовательно возвращается сначала методом `unlink(node)`, а затем и методом `remove(index)`.
	Похожая ситуация наблюдается и в остальных методах, возвращающих значение удаленного элемента, только внутри вызываются другие методы, отсоединяющие ссылку: в методах `poll()`, `pollFirst()`, `remove()` и `removeFirst()` это метод `unlinkFirst(node)`, а в методах `pollLast()` и `removeLast()` — метод `unlinkLast(node)`.
##### Скорость основных операций
LinkedList знает, где находится его голова и где находится хвост.
##### Вставка и удаление элементов:
- **Вставка и удаление первого и последнего элемента (head и tail):** Эти операции выполняются за константное время O(1), потому что LinkedList хранит ссылки на первый и последний элементы. При вставке нового элемента в начало или конец списка или при удалении первого или последнего элемента, изменения происходят только с этими ссылками, что не зависит от размера списка.
  
- **Вставка и удаление элемента из середины списка:** При вставке или удалении элемента из середины списка, время выполнения также является константным O(1), но это не учитывает время поиска позиции элемента. Если позиция элемента известна заранее (например, по индексу), вставка или удаление происходят быстро. Однако, если необходимо найти позицию элемента сначала, это займет O(n) времени.
##### Поиск элемента:
- **Поиск элемента по индексу:** Поскольку LinkedList не имеет прямого доступа к элементам по индексу, чтобы найти элемент с определенным индексом, придется пройти по списку от начала до нужной позиции. Это занимает линейное время O(n), где n - количество элементов в списке.
  
- **Поиск элемента по значению:** Поиск элемента по значению также требует прохода по всему списку, чтобы найти соответствующий элемент. Поэтому это также занимает линейное время O(n), где n - количество элементов в списке.

*Что следует помнить о LinkedList, решая, использовать ли данную коллекцию:*
- не синхронизирована
- позволяет хранить любые объекты, в том числе null и повторяющиеся
- за константное время O(1) выполняются операции вставки и удаления
первого и последнего элемента и операции вставки и удаления элемента из
середины списка (не учитывая время поиска позиции элемента, который
осуществляется за линейное время)
- за линейное время O(n) выполняются операции поиска элемента по
индексу и по значению

#### 27. Чем отличаются ArrayList и LinkedList? 
`ArrayList` хранит данные в массиве, `LinkedList` в связанном списке. Из этого вытекает разница в эффективности разных операций:
	• `ArrayList` лучше справляется с изменениями в середине и ростом в пределах
`capacity`
	• `LinkedList` – на краях. В целом обычно `ArrayList` лучше.
В вопрос иногда добавляют `Vector` – пере-синхронизированный и устаревший
вариант `ArrayList`, который лучше заменить `Collections.synchronizedList()`.
>[!TIP]
>`Vector` в Java является устаревшей реализацией динамического массива, подобной `ArrayList`, но с одним ключевым отличием: он синхронизирован.
>
>**А что тогда использовать, если нам нужна потокобезопасный List?**
>`   Collections.synchronizedList()` - это статический метод класса `java.util.Collections`, который возвращает потокобезопасную оболочку для списка (List). Этот метод принимает на вход список и возвращает его синхронизированную версию, то есть версию списка, методы которой синхронизированы для обеспечения безопасности в многопоточной среде

Стоит добавить, что для работы на краях лучше использовать реализации специально для этого спроектированного интерфейса `Deque`: например, реализующую кольцевой буфер* `ArrayDeque`.

>[!TIP]
>Кольцевой буфер, или циклический буфер — это структура данных, использующая единственный буфер фиксированного размера таким образом, как будто бы после последнего элемента сразу же снова идет первый. Такая структура легко предоставляет возможность буферизации потоков данных.
##### ArrayDeque
Наконец, несколько дополнительных замечаний, которые стоит понимать и помнить об этой конкретной реализации:
1. Не является потокобезопасным.
2. Не принимает элементы со значением `null`.
3. Работает значительно быстрее синхронизированного стека.
4. Является более быстрой очередью, чем `LinkedList` благодаря лучшей локальности ссылок.
5. Большинство операций имеют амортизированную константную сложность времени.
6. Итератор, возвращаемый `ArrayDeque`, поддерживает стратегию `fail-fast`.
7. `ArrayDeque` автоматически удваивает размер массива, когда указатели головы и хвоста встречаются при добавлении элемента.

#### 28. Что такое Queue? 
`public interface Queue<E> extends Collection<E>`

Queue – это односторонняя очередь, когда элементы можно получить в том порядке, в котором добавляли. FIFO (первым вошёл, первым вышел).

Согласно Javadoc очереди, очередь добавляет следующие методы:
![[Pasted image 20240322060122.png]]

#### 29. Что такое Deque? Чем отличается от Queue? 
Deque (Double Ended Queue) – это двусторонняя очередь, т.е. можно вставлять/получать элементы как из начала, так и с конца. Расширяет Queue. Согласно документации, это линейная коллекция, поддерживающая вставку/извлечение элементов с
обоих концов (реализация: LIFO, либо FIFO).

Реализации и Deque, и Queue обычно НЕ переопределяют методы
equals() и hashCode(), вместо этого используются унаследованные
методы класса Object, основанные на сравнении ссылок.

Queue – это односторонняя очередь, которая обычно (но необязательно) строится по принципу FIFO (First-In-First-Out). Соответственно извлечение элемента осуществляется с начала очереди, а вставка элемента в конец очереди.
Хотя этот принцип нарушает, к примеру PriorityQueue, использующая «natural ordering»
или переданный Comparator при вставке нового элемента.

##### **Разница между Queue, Deque и Stack?**
1. **Queue (Очередь)**:
    - Следует принципу FIFO (первым пришел, первым ушел).
    - Элементы добавляются в конец очереди и извлекаются из начала.
    - Реализации: `LinkedList`, `ArrayDeque`, `PriorityQueue` и другие.
    
1. **Deque (Двусторонняя очередь)**:
    - Представляет собой очередь, в которой можно добавлять и удалять элементы с обоих концов.
    - Поддерживает как принцип FIFO (как обычная очередь), так и LIFO (как стек).
    - Реализации: `ArrayDeque`, `LinkedList`.
    
1. **Stack (Стек)**:
    - Следует принципу LIFO (последний пришел, первым ушел).
    - Элементы добавляются и удаляются только с одного конца (вершины стека).
    - Реализации: `Stack` (устарела, не рекомендуется к использованию), обычно рекомендуется использовать `Deque`, особенно `ArrayDeque`.

видео для просмотра: [Java. Очередь и стек. (youtube.com)](https://www.youtube.com/watch?v=X07Y7pkHHJc&list=TLPQMjUwMzIwMjR6H1BvH1Yz1A&index=2)

#### 30. Приведите пример реализации Deque. 
Например, класс `ArrayDeque<E>`.
Этот класс представляют обобщенную двунаправленную очередь, наследуя функционал от класса `AbstractCollection` и применяя интерфейс `Deque`.

В классе ArrayDeque определены следующие конструкторы:
• `ArrayDeque()`: создает пустую очередь
• `ArrayDeque(Collection<? extends E> col)`: создает очередь, наполненную элементами из коллекции col
• `ArrayDeque(int capacity)`: создает очередь с начальной емкостью capacity.
Если мы явно не указываем начальную емкость, то емкость по умолчанию будет равна 16

#### 31. Какая коллекция реализует FIFO? 
FIFO - First-In-First-Out (первый пришел, первым ушел). По этому принципу обычно
построена такая структура данных, как очередь (java.util.Queue).

#### 32. Какая коллекция реализует LIFO? 
`Stack` работает по схеме LIFO (последним вошел, первым вышел, как стопка книг). Всякий раз, когда вызывается новый метод, содержащий примитивные значения или ссылки на объекты, то на вершине стека под них выделяется блок памяти.

`Stack` реализует дополнительные методы: `peek` (взглянуть, посмотреть), `pop` (вытолкнуть), `push` (затолкать).

#### 33. Оцените количество памяти на хранение одного примитива типа byte в LinkedList? 

```java
private static class Node<E> { // 8 байт
E item; // 4 байта
Node<E> next; // 4 байта
Node<E> prev; // 4 байта
}
```
Итого 24 байта (кратно 8) для хранения элемента в списке(4 * 3 + 8 = 20(+4 до кратности))
+16 байт для хранения упакованного объекта Byte (8 байт заголовок и 8 байт для значений из пула int).
**Итого 40 байт для 32-битной JVM**
**Итого 64 байта для 64-битной JVM**

**Для 32-битных систем**:
Каждая ссылка занимает 32 бита (**4 байта**). Сам объект (заголовок) вложенного класса `Node` занимает 8 байт. 4 * 3 + 8 = 20 байт, а т.к. размер каждого объекта в Java кратен 8, соответственно получаем 24 байта.
Примитив типа `byte` занимает 1 байт памяти, но в Java Collections Framework примитивы упаковываются: объект типа `Byte` занимает в памяти 16 байт (8 байт на заголовок объекта, 1 байт на поле типа `byte` и 7 байт для кратности 8). Значения от -128 до 127 кэшируются в пул `int` и для них новые объекты каждый раз не создаются. **Таким образом, в x32 JVM 24 байта тратятся на хранение**
**одного элемента в списке и 16 байт - на хранение упакованного объекта типа Byte. Итого 40 байт.**
**Для 64-битной:** 
Каждая ссылка занимает 64 бита (**8 байт**), размер заголовка каждого объекта составляет 16 байт (два машинных слова). **Вычисления аналогичны: 8 * 3 + 16 = 40 байт и 24 байта. Итого 64 байта.**
#### 34. Оцените количество памяти на хранение одного примитива типа byte в ArrayList? 
`ArrayList` основан на массиве, для примитивных типов данных осуществляется
автоматическая упаковка значения, поэтому `16 байт` тратится на хранение упакованного объекта и `4 байта` (`8` для `x64`) на хранение ссылки на этот объект в самой структуре
данных.
Таким образом, в `x32 JVM` `4 байта` используются на хранение одного элемента и `16 байт` на хранение упакованного объекта типа `Byte`(всего 20 байт ). Для `x64` - `8 байт` и `24 байта` соответственно(всего 32 байта).

#### 35. Основные реализации Map:
![[Pasted image 20240322062929.png]]
1. **HashMap**: Это основная и наиболее распространенная реализация `Map`. Она использует хеш-таблицу для хранения ключей и значений. Предоставляет почти константное время доступа к элементам в среднем случае.

2. **LinkedHashMap**: Это расширение `HashMap`, которое поддерживает связанный список элементов для сохранения порядка вставки. Он обеспечивает доступ к элементам в порядке, определенном порядком вставки, что полезно в некоторых сценариях.

3. **TreeMap**: Эта реализация основана на красно-черном дереве. Ключи автоматически сортируются по их естественному порядку или пользовательскому компаратору. Поиск, вставка и удаление элементов выполняются за время O(log n).

4. **WeakHashMap**: Это реализация `Map`, где ключи являются слабыми ссылками. Это означает, что если ключ больше не используется в программе и нет других ссылок на него, он будет автоматически удален из `WeakHashMap`.

5. **SortedMap**: Это интерфейс, который расширяет `Map` и предоставляет методы для работы с отсортированным набором ключей. Он гарантирует, что ключи хранятся в отсортированном порядке в соответствии с их естественным порядком или пользовательским компаратором. Некоторые реализации `SortedMap` включают `TreeMap`.

6. **NavigableMap**: Это интерфейс, который также расширяет `Map` и предоставляет методы для навигации по ключам в отсортированном наборе. Он расширяет функциональность `SortedMap`, предоставляя дополнительные методы для поиска элементов ближайших к заданному ключу, получения подмножества элементов и т. д. Некоторые реализации `NavigableMap` включают `TreeMap`.

#### 36. Как устроена HashMap? (Расскажите про принцип корзин)
`HashMap<K,V>` - это КЛАСС в Java коллекции интерфейсов и классов (Java Collection
Framework), который реализует `interface Map<K,V>` ( пары ключей и значений (key & value)):
	• КЛЮЧИ элементов должны быть уникальными (и IMUTEABLE), может быть null.
	• ЗНАЧЕНИЯ элементов могут повторяться. Значение может быть null.
`HashMap` НЕ запоминает порядок добавления элементов в коллекцию.
НЕ синхронизируемая! Нельзя использовать в условиях многопоточности, для этого есть `ConcurrentHashMap`.
Почему так популярен? `HashMap` быстро работает, и большинство операций
выполняется за фиксированное или константное O(1) время благодаря
оптимизированному доступу к данным.

#### Структура
**В** основе **HashMap** лежит **массив Node**. Элементами этого массива являются структуры односвязного списка **LinkedList**, которые заполняются элементами. 
При помещении нового элемента (**k/v**), ищется нужная корзина. Если в корзине пусто, то помещаем туда новый объект. Если занято, то находим нужную корзину и проверяем первый объект, который там лежит. 
- Если такой элемент в цепочке существует, его значение перезаписывается. 
- Если место занято и объект не совпадает с нашим, то размещаем наш объект в следующем узле (она же нода, она же **entry**) в цепочке списка одной корзины, для добавления нового узла/ноды будет вызван метод **addEntry()**. 
**Нода** содержит поля и хранит инфо: **hash**, **key**, **value**, **next** (ссылка на следующий узел).
#### Хеш-код
Перед тем, как что-то сделать с объектом, вычисляется его **НОВЫЙ хэш-код**. Для генерации используется метод `hash(hashCode)`, в который передается `key.hashCode()`. Формула расчёта **ХЭШ-КОДА** для ключа:
```java
(hashCode) ^ (hashCode >>> 16)
```
1. **`hashCode >>> 16`**: `>>>` - это оператор беззнакового сдвига вправо. Он сдвигает биты значения `hashCode` на 16 позиций вправо, заполняя старшие биты нулями. Это означает, что старшие 16 битов исходного хэш-кода теперь будут находиться в младших 16 битах результата.
    
2. **`hashCode ^ (hashCode >>> 16)`**: `^` - это оператор побитового исключающего ИЛИ (XOR). Он применяется к исходному хэш-коду и результату сдвига. Он смешивает биты исходного хэш-кода, "размазывая" более высокие биты по всему значению. Это делается для уменьшения вероятности коллизий и лучшего распределения хэш-кодов по всему диапазону значений.

Это делается из-за того, что `hashCode()` может быть реализован так, что только нижние биты `int`'a будут заполнены. Например, для `Integer`, `Float`, если мы в `HashMap` кладем маленькие значения, то у них и биты хеш-кодов будут заполнены только нижние. В таком случае ключи в `HashMap` будут иметь тенденцию скапливаться в нижних ячейках, а верхние будут оставаться пустыми, что не очень эффективно. На то, в какой бакет попадёт новая запись, влияют только младшие биты хеша. Поэтому и придумали различными манипуляциями подмешивать старшие биты хеша в младшие, чтобы улучшить распределение по бакетам (чтобы старшие биты родного хеша объекта начали вносить коррективы в то, в какой бакет попадёт объект) и, как следствие, производительность. Потому и придумана дополнительная функция `hash` внутри `HashMap`.

При значении хэша 51 и размере таблицы 16, мы получаем индекс корзины в массиве:
```java
h & (length - 1);

110011 (51 в двоичной) 
& 
001111 (15 в двоичной) 
--------- 
000011 (3 в двоичной)
```
Эта формула применяется и для определения бакета при добавлении элемента и для поиска бакета, когда пытаемся достать элемент (пару k/v).

**Вопрос: как узнать, в какую корзину попадёт элемент, если значение его хэш-кода 51?**
**Ответ: остаток от деления на кол-во корзин (т.к. 51 % 16 = 3 (проверка 3 * 16 = 48 + 3))**

#### Как происходит сравнение при добавлении(put) элемента? Аналогично при поиске (получить).
Рассчитав и зная индекс в массиве, мы получаем список (цепочку) элементов,
привязанных к этой корзине (ячейке). Хэш и ключ нового элемента поочередно
сравниваются с хэшами и ключами элементов из списка и, при совпадении этих
параметров, значение элемента перезаписывается.

**Сравниваем КЛЮЧ нашего объекта с первым в цепочке объектом:**
- проверка по хэш-коду
- если проверка по хеш-коду выдала false, то проверка на equals НЕ ДЕЛАЕТСЯ. потому что проверка хеш-кодов - это прикидка, равны объекты или нет.
- если проверка по хеш-коду выдала true, т.е найден объект с таким же хеш-кодом, то тогда проверка на equals(потому что затратная по ресурсам операция).  тут и возникает коллизия. РАЗНЫЕ ОБЪЕКТЫ - ОДИНАКОВЫЙ ХЕШ-КОД

Если же предыдущий шаг не выявил совпадений, будет вызван метод `addEntry(hash, key, value, index)` для добавления нового элемента.

Когда добавляется элемент в `HashMap` и ключом является `null`, процесс немного отличается. Вместо вызова методов `hash() и indexFor()` (которые обычно используются для вычисления хэш-кода и определения индекса корзины) вызывается метод `putForNullKey(value)`(потому как все элементы с null-ключами всегда помещаются в `корзину[0]`).
#### Если при добавлении элемента возникает коллизия
В ситуации, когда разные ключи попадают в один и тот же бакет (даже с разными хешами), говорят о возникновении коллизии или столкновении. Даже если размер хеш-таблицы больше, чем количество элементов данных, и применена хорошая хеш-функция, это не гарантирует отсутствия коллизий. Также, значение хеша ограничено диапазоном значений типа int (порядка 4 миллиардов), что означает, что возможны ситуации, когда разным ключам соответствуют одинаковые хеши.

Для решения коллизий существуют два основных подхода:
1. **Метод цепочек (External Chaining)**: В этом методе в каждой ячейке хеш-таблицы находится список, так называемая цепочка (chain). Когда происходит коллизия, новый элемент добавляется в соответствующий список. Таким образом, в одной ячейке может находиться несколько элементов с разными ключами, имеющими одинаковые хеш-коды. Этот метод реализуется, например, в классе HashMap.
    
2. **Метод открытой адресации (Linear Probing)**: При использовании этого метода при коллизии происходит поиск следующей доступной ячейки в таблице. Если ячейка, вычисленная по хеш-коду, уже занята, происходит последовательный поиск следующей свободной ячейки в таблице. Этот метод используется, например, в классе IdentityHashMap.

##### Если ключ не immutable, что произойдет при попытке добавления/получения элемента?
Если ключ в HashMap не является immutable, то возникает риск изменения его состояния после того, как он был добавлен в HashMap. Это может привести к непредсказуемому поведению структуры данных и нарушению её инвариантов.

При попытке добавления элемента в HashMap с ключом, который не является immutable, **процесс хеширования и определения места расположения элемента внутри HashMap может быть нарушен, если хеш ключа изменяется после его добавления.** В результате элемент может быть помещен в неправильное место, что приведет к неправильной работе HashMap.

Аналогично, при попытке получения элемента по ключу, **который не является immutable и изменяется после добавления в HashMap, поиск элемента в HashMap может дать неверный результат, так как хеш ключа может измениться, и система не сможет найти элемент по измененному хешу.**

#### 36. Что такое бинарное дерево? 
Двоичное дерево — структура данных, в которой каждый узел (родительский) имеет не более двух потомков (правый и левый наследник).
Двоичное дерево поиска строится по определенным правилам:
- каждый узел имеет не более двух детей;
- каждое значение, меньшее, чем значение узла, становится левым ребенком или ребенком левого ребенка.

#### 37. Когда и как происходит перестроение мапы в дерево? 
Первоначальный размер `HashMap` = 16 бакетов (напомню, бакет – это ячейка массива).
Когда массив заполняется на 75%, то есть заполняются 12/16 бакетов (16 * 0,75 = 12, т.к. loadFactory = 0,75), размер массива увеличивается в 2 раза, т.е. становится 32 бакета.
И так далее (64, 128 …). При увеличении размера массива все объекты, уже
содержащиеся в `HashMap`, будут перераспределены по новым бакетам, с учётом их
нового количества.
Каждый бакет содержит в себе ноды (пары ключ-значение), когда нод становится 8(в одном бакете), а бакетов 64, то структура `Node` перестраивается в красно-черное дерево (`TreeNode`).
Обратное перестроение `TreeNode →Node` случается, если количество нод в цепочке меньше 6.

#### 38. Каковы особенности красно-чёрного дерева? 
1. **Бинарные деревья поиска**: Оба поддерева каждого узла в красно-черном дереве являются бинарными деревьями поиска, где левое поддерево содержит значения, меньшие или равные значению корня, а правое поддерево содержит значения, большие значения корня.
    
2. **Условие упорядоченности**: Левые потомки должны быть меньше или равны своему корню, а правые потомки всегда больше левых. Это условие обеспечивает быстрый бинарный поиск.
    
3. **Цвета узлов**: Каждый узел в красно-черном дереве окрашен в красный или черный цвет. Это дополнительное поле помогает в поддержании баланса и правильной структуры дерева.
    
4. **Окраска корня и листьев**: Корень и все листья дерева (так называемые NULL-узлы) окрашены в черный цвет. 
    
5. **Условие двойного черного**: Каждый красный узел должен иметь два черных дочерних узла. Красные узлы могут иметь только черные дочерние узлы.
    
6. **Черная высота**: Пути от узла к его листьям должны содержать одинаковое количество черных узлов. Это условие обеспечивает сбалансированность дерева.
    
7. **Перебалансировка дерева**: При нарушении любого из вышеперечисленных правил дерево перебалансируется для восстановления свойств красно-черного дерева.

#### 39. Сложность основных операций HashMap? 
1. **Вставка (Insertion)**: Вставка элемента в HashMap в среднем выполняется за время O(1). Это означает, что вставка элемента занимает постоянное время в среднем случае. Однако, в редких случаях, когда происходит коллизия хэш-кодов (когда два ключа с разными значениями хэш-кода попадают в одну ячейку массива), время вставки может быть O(n), где n - количество элементов в корзине (bucket). В худшем случае, когда все элементы хэш-таблицы попадают в одну корзину, время вставки может стать O(n).
    
2. **Поиск (Search)**: Поиск элемента в HashMap также в среднем выполняется за время O(1). Это означает, что поиск элемента занимает постоянное время в среднем случае. Однако, аналогично вставке, в редких случаях, когда происходит коллизия хэш-кодов, время поиска может быть O(n), где n - количество элементов в корзине. В худшем случае, когда все элементы хэш-таблицы попадают в одну корзину, время поиска также может стать O(n).
    
3. **Удаление (Deletion)**: Удаление элемента из HashMap в среднем выполняется за время O(1). Однако, как и в случае вставки и поиска, в редких случаях с коллизиями хэш-кодов, время удаления может быть O(n), где n - количество элементов в корзине. В худшем случае, когда все элементы хэш-таблицы попадают в одну корзину, время удаления также может стать O(n).
#### 40. Что происходит внутри HashMap.put()?
1. Вычисляется хэш ключа. Если ключ null, хэш считается равным 0. Чтобы достичь лучшего распределения, результат вызова hashCode() «перемешивается»: его старшие биты XOR-ятся на младшие. 
2. Значения внутри хэш-таблицы хранятся в специальных структурах данных – нодах, в массиве. Из хэша высчитывается номер бакета – индекс для значения в этом массиве. Полученный хэш обрезается по текущей длине массива. Длина – всегда степень двойки, так что для скорости используется битовая операция &.
3. В бакете ищется нода. В ячейке массива лежит не просто одна нода, а связка всех нод, которые туда попали. Исполнение проходит по этой связке (цепочке или дереву), и ищет ноду с таким же ключом. Ключ сравнивается с имеющимися сначала на `==`, затем на `equals`.
4. Если нода найдена – её значение просто заменяется новым. Работа метода на этом завершается.
5. Если ноды с таким же ключом в бакете пока нет – добавляемая пара ключ-значение запаковывается в новый объект типа Node, и прикрепляется к структуре существующих нод бакета. Ноды составляют структуру за счет того, что в ноде хранится ссылка на следующий элемент (для дерева – следующие элементы). Кроме самой пары и ссылок, чтобы потом не считать заново, записывается и хэш ключа.
7. В случае, когда структурой была цепочка а не дерево, и длина цепочки превысила 7 элементов – происходит процедура treeification – превращение списка в самобалансирующееся дерево. В случае коллизии это ускоряет доступ к элементам на чтение с O(n) до O(log(n)). У comparable-ключей для балансировки используется их естественный порядок. Другие ключи балансируются по порядку имен их классов и значениям identityHashCode-ов. Для маленьких хэш-таблиц (< 64 бакетов) «одеревенение» заменяется увеличением (см. п.8).
8. Если новая нода попала в пустую ячейку, заняла новый бакет – увеличивается счетчик структурных модификаций. Изменение этого счетчика сообщит всем итераторам контейнера, что при следующем обращении они должны выбросить ConcurrentModificationException.
9. Когда количество занятых бакетов массива превысило пороговое (capacity * load factor), внутренний массив увеличивается вдвое, а для всего содержимого выполняется рехэш – все имеющиеся ноды перераспределяются по бакетам по тем же правилам, но уже с учетом нового размера
>[!TIP]
>Нюансы которые стоит повторить и запомнить:  
_**🔘**_ Общий принцип: внутренний массив `table`, содержащий бакеты (корзины) – списки элементов с одинаковыми _пересчитанными_ хэш-суммами;  
_**🔘**_ Пересчет хэш-суммы для умещения `int` индексов в `capacity` ячейках `table`;  
_**🔘**_ `rehash` – удвоение размера `table` при достижении `threshold` (`capacity*loadFactor`) занятых бакетов;  
_**🔘**_ Невозможность сжать однажды раздувшийся `table`;  
_**🔘**_ Два способа разрешения коллизий: используемый в `HashMap` метод цепочек и альтернатива – открытая адресация;  
_**🔘**_ Варианты для многопоточного использования: пересинхронизированная `Hashtable` и умная `ConcurrentHashMap`;  
_**🔘**_ Оптимизация Java 8: превращение списка в бакете в дерево при достижении 8 элементов – при большом количестве коллизий скорость доступа растет с O(n) до O(log(n));  
_**🔘**_ Явное использование бакета 0 для ключа `null`;  
_**🔘**_ Связь с `HashSet` – `HashMap`, в котором используются только ключи;  
_**🔘**_ Нет гарантий порядка элементов;  
Обсуждая этот вопрос на интервью вы обязательно затронете особенности методов [equals/hashCode](https://itsobes.ru/JavaSobes/equals-hashcode). Возможно придется поговорить об альтернативных хранилищах ключ-значение – [TreeMap](https://www.baeldung.com/java-treemap-vs-hashmap), [LinkedHashMap](https://habr.com/ru/post/129037/).

#### 40. Что такое LinkedHashMap? LinkedHashMap - что в нем от LinkedList, а что от HashMap? 
Реализация `LinkedHashMap` отличается от `HashMap` тем, что помимо основной хеш-таблицы для быстрого доступа к элементам также поддерживается двусвязный список, который определяет порядок итерации по элементам структуры данных.

Этот двусвязный список сохраняет порядок вставки элементов: каждый элемент хранит ссылку на предыдущий и следующий элемент, что позволяет эффективно поддерживать порядок элементов. Когда элемент добавляется или доступ к элементу изменяется, соответствующие операции также обновляют связи в двусвязном списке.
По умолчанию элементы списка упорядочены согласно их порядку добавления в
`LinkedHashMap` (insertion-order). Однако порядок итерации можно изменить, установив параметр конструктора `accessOrder` в значение`true`. В этом случае доступ осуществляется по порядку последнего обращения к элементу (access-order).

Это означает, что при вызове методов `get() или put()` элемент, к которому обращаемся, перемещается в конец списка.

При добавлении элемента, который уже присутствует в `LinkedHashMap` (т.е. с
одинаковым ключом), порядок итерации по элементам не изменяется.

#### 41. Как устроена TreeMap, сложность основных операций? 
Реализация интерфейса `Map` — `TreeMap` позволяет хранить данные в структурированном виде с возможностью навигации.
Древовидная структура: под капотом `TreeMap` использует структуру данных, которая называется красно-чёрное дерево.
Имплементируя интерфейсы `NavigableMap и SortedMap`, `TreeMap` получает
дополнительный функционал, которого нет в `HashMap`, но плата за это —
производительность.
Хоть класс `TreeMap` является самым многофункциональным, он не всегда может
хранить `null` в качестве ключа. Кроме этого, время доступа к элементам `TreeMap` будет самым длительным. Поэтому если НЕ нужно хранить данные в отсортированном виде, лучше использовать `HashMap или LinkedHashMap`.

![[Pasted image 20240325121918.png]]

##### По какому признаку сравнивать например несколько полей объекта в TreeMap?
Когда вы сравниваете несколько полей объекта в TreeMap, вы должны использовать компаратор для определения порядка сортировки элементов. Компаратор должен сравнивать каждое поле объекта по очереди, учитывая приоритетность полей для сортировки.
```java
	TreeMap<Person, String> treeMap = new TreeMap<>
	(new Comparator<Person () { 
		@Override 
		public int compare(Person p1, Person p2) { 
		p1.name.compareTo(p2.name); 
		if (nameCompare != 0) { 
			return nameCompare; 
		} 
		Integer.compare(p1.age, p2.age);
```

#### 42. Что такое WeakHashMap? 
`WeakHashMap` - это реализация интерфейса `Map` в Java, где ключи являются слабыми ссылками. Это означает, что если на ключ не осталось сильных ссылок из других частей программы, то такой ключ может быть удален автоматически сборщиком мусора.

Основные особенности `WeakHashMap`:

1. **Использование слабых ссылок для ключей:** В отличие от обычной `HashMap`, где ключи хранятся как сильные ссылки, в `WeakHashMap` ключи хранятся как слабые ссылки. Это означает, что если на ключ не осталось сильных ссылок из других частей программы, то ключ может быть удален автоматически сборщиком мусора.
    
2. **Удаление автоматически при очистке ключей:** Когда ключ становится доступен только через слабую ссылку, то он считается недостижимым и может быть удален из `WeakHashMap`. Это позволяет избежать утечек памяти в случае, когда объекты, которые больше не нужны, остаются в `Map`.
    
3. **Применение в кешах и словарях:** `WeakHashMap` часто используется для создания кешей или словарей, где ключи могут быть автоматически удалены из коллекции, если на них больше нет ссылок из других частей программы. Это особенно полезно в ситуациях, когда объекты в кеше могут стать неактуальными и их следует удалить для освобождения памяти.
    
4. **Особенности работы с ключами:** Поскольку ключи хранятся как слабые ссылки, при использовании `WeakHashMap` важно гарантировать, что сами ключи не будут модифицированы таким образом, чтобы потерять свои сильные ссылки. Иначе они могут быть случайно удалены из `WeakHashMap`.
    
5. **Слабые ссылки в Java:** Слабые ссылки (weak references) в Java - это ссылки на объекты, которые не учитываются сборщиком мусора при принятии решения о том, можно ли удалить объект. Если на объект остаются только слабые ссылки, он будет удален при следующем запуске сборщика мусора.

#### 43. В чем разница между HashMap и WeakHashMap? Для чего используется WeakHashMap? 
Основное различие между `HashMap` и `WeakHashMap` заключается в том, как они управляют своими ключами и значениями в памяти:
1. **HashMap:**
    - `HashMap` использует сильные ссылки (strong references) для ключей и значений. Это означает, что если объект является ключом или значением в `HashMap`, он не будет удален из памяти, пока существует хотя бы одна сильная ссылка на него.
    - Объекты, добавленные в `HashMap`, могут быть удалены только в том случае, если они больше не доступны через сильные ссылки.
    
1. **WeakHashMap:**
    - `WeakHashMap`, напротив, использует слабые ссылки (weak references) для ключей. Это означает, что если на ключ нет сильных ссылок и существуют только слабые ссылки, то этот ключ может быть удален сборщиком мусора.
    - Значения в `WeakHashMap`, как и в обычной `HashMap`, могут быть сильными ссылками.

**Использование WeakHashMap:**
- `WeakHashMap` полезен там, где нужно иметь ассоциативные данные, но объекты в качестве ключей должны быть доступны для удаления сборщиком мусора, если на них больше нет сильных ссылок.
- Одно из распространенных применений `WeakHashMap` - это кеш или кэширование. Например, когда вам нужно временно хранить результаты вычислений или другие данные, которые могут быть удалены из памяти, когда на них больше нет активных ссылок. Когда ключи перестают быть нужными и удаляются, соответствующие значения в `WeakHashMap` также удаляются автоматически.

##### В WeakHashMap используются WeakReferences, а почему бы не создать SoftHashMap на SoftReferences?
`SoftHashMap` представлена в сторонних библиотеках, например, в Apache Commons.

##### В WeakHashMap используются WeakReferences, а почему бы не создать PhantomHashMap на PhantomReferences?
`PhantomReference` при вызове метода `get()` возвращает всегда `null` (объект
недостижим), поэтому тяжело представить назначение такой структуры данных.
Фантомные ссылки — это безопасный способ узнать, что объект удален из памяти.

>[!TIP]
>- `WeakReferences` используются в `WeakHashMap` для ключей, чтобы объекты-ключи могли быть удалены сборщиком мусора, как только на них больше нет сильных ссылок. Обычно это происходит при следующем запуске сборки мусора.
>- `SoftReferences`, напротив, используются для создания `SoftHashMap` для значений, чтобы они могли быть удалены сборщиком мусора только в случае, крайней необходимости, когда система под давлением из-за нехватки памяти. Это делает их более подходящими для кеширования данных, которые могут быть полезными в памяти, но могут быть удалены, если возникнет нехватка памяти.

#### 44. Как работает HashMap при попытке сохранить в него два элемента по ключам с одинаковым hashCode(), но для которых equals() == false? 
По значению hashCode() вычисляется индекс ячейки массива, в список которой этот
элемент будет добавлен. Перед добавлением осуществляется проверка на наличие
элементов в этой ячейке. Если элементы с таким hashCode() уже присутствует, но их
equals() методы не равны, то элемент будет добавлен в конец списка в данном бакете.

#### 45. Что будет, если мы кладем в HashMap ключ, у которого equals и hashCode определены некорректно? 
Если ключ, у которого методы `equals()` и `hashCode()` определены некорректно, добавление такого ключа в `HashMap` может привести к неожиданным результатам:

1. **Потеря данных**: Если ключи, которые на самом деле равны друг другу, возвращают разные значения `hashCode()`, они могут быть помещены в разные ячейки хеш-таблицы. В результате метод `get()` может не найти ключ, который по логике должен был быть найден.
    
2. **Некорректное переписывание значений**: Если у двух ключей, которые по сути равны, но возвращают разные значения `hashCode()`, будут разные значения, то при добавлении второго ключа значение первого ключа будет перезаписано, что может привести к потере данных.
    
3. **Некорректное удаление элементов**: Если ключи, которые по сути равны, возвращают разные значения `hashCode()`, они могут быть помещены в разные ячейки хеш-таблицы. При удалении элемента по одному из таких ключей, элемент с другим ключом не будет удален, что приведет к неконсистентному состоянию `HashMap`.

+ плюсом про распределение старших и младших битов 

#### 46. Возможна ли ситуация, когда HashMap выродится в список даже с ключами имеющими разные hashCode()? 
Это возможно в случае, если метод, определяющий номер корзины будет возвращать
одинаковые значения.

Это может произойти, например, когда у объектов разные хеш-коды, но при вычислении индекса корзины (bucket index) с помощью хеш-функции все они оказываются **в одной и той же корзине из-за совпадения младших битов хеша**. В результате, при добавлении новых элементов в HashMap все они будут добавляться в конец цепочки, превращая HashMap в список.

#### 47. Почему нельзя использовать byte[] в качестве ключа в HashMap? 
1. **Хеш-коды**: По умолчанию в Java для массивов типа `byte[]` используется метод `Arrays.hashCode(byte[])`, который вычисляет хеш-код на основе содержимого массива. Это означает, что разные массивы `byte[]` с одинаковым содержимым будут иметь одинаковый хеш-код.
    
2. **Сравнение**: В Java массивы сравниваются по ссылкам, а не по содержимому. Даже если два массива `byte[]` имеют одинаковое содержимое, они будут считаться разными, если это разные объекты.
    
Из-за этих особенностей использование массивов `byte[]` в качестве ключей может привести к непредсказуемому поведению `HashMap`, особенно если не обеспечить правильную реализацию методов `hashCode()` и `equals()` для ключей типа `byte[]`. Обычно это делается путем обертывания массива `byte[]` в класс-оболочку с переопределением этих методов для учета содержимого массива при сравнении.

#### 48. Будет ли работать HashMap, если все добавляемые ключи будут иметь одинаковый hashCode()? 
Да, будет, но в этом случае `HashMap` вырождается в связный список и теряет свои
преимущества.

#### 49. Какое худшее время работы метода get(key) для ключа, которого НЕТ в HashMap? 
O(N). Худший случай – это поиск ключа в HashMap, вырожденного в список по причине
совпадения ключей по hashCode(). Для выяснения хранится ли элемент с определенным
ключом может потребоваться перебор всего списка

#### 50. Какое худшее время работы метода get(key) для ключа, который ЕСТЬ в HashMap?
O(N). Худший случай – это поиск ключа в HashMap, вырожденного в список по причине
совпадения ключей по hashCode(). Для выяснения хранится ли элемент с определенным
ключом может потребоваться перебор всего списка