#### 1. Что такое Stream API? Для чего нужны стримы? 
Java Stream API представляет собой новый пакет в Java 8, **предназначенный для обработки последовательности элементов**. Он вводит **функциональный стиль программирования** для обработки данных и предоставляет богатый набор операций для работы с коллекциями данных.

Основная цель Stream API - это предоставление удобного и эффективного способа выполнения операций над коллекциями данных. Он позволяет выполнять параллельные операции с данными без необходимости явного управления потоками. Stream API упрощает многие типичные операции, такие как фильтрация, сортировка, слияние и трансформация данных.

Основные преимущества использования стримов:
1. **Удобство и читаемость кода**: Стримы предоставляют лаконичный и выразительный способ выполнения операций над данными.
2. **Параллельная обработка данных**: Стримы могут эффективно использовать многопоточность для обработки данных параллельно.
3. **Отсутствие необходимости создавать промежуточные коллекции**: Стримы позволяют выполнять операции напрямую на исходных данных, минимизируя использование памяти.
**Ключевой абстракцией, представленной в пакете java.util.stream является ПОТОК.**
**Конструкция языка, представляющая последовательность элементов, потенциально**
**бесконечная, с возможность применять к ней, сложные, поэтапные преобразования без**
**цикла и условного оператора.**

**Виды стримов:**
- параллельные 
- последовательные
- конечные
- бесконечные
- примитивные
#### 2. Почему Stream называют ленивым? 
Потоки данных в Java, представленные интерфейсом `Stream`, часто называют ленивыми из-за их особенности начинать выполнение операций только тогда, когда это необходимо, а не сразу после создания.

Когда вы создаете поток данных и применяете к нему различные промежуточные операции (например, `filter`, `map`, `flatMap`), поток не начинает выполнение этих операций немедленно. Вместо этого он ожидает, пока будет вызвана терминальная операция (например, `collect`, `forEach`, `reduce`), которая потребует результаты этих промежуточных операций.

#### 3. Какие существуют способы создания стрима? 
![[Pasted image 20240325142420.png]]

#### 4. Как из коллекции создать стрим? 
Для создания стрима из коллекции в Java используется метод `stream()`, доступный для всех реализаций интерфейса `Collection`.
```java
Collection<String> collection = Arrays.asList("f5", "b6", "z7");
collection.stream();
```

#### 5. Какие промежуточные методы в стримах вы знаете? 
Промежуточные методы в Stream API выполняют преобразования или операции над элементами стрима и возвращают новый стрим. Эти операции являются ленивыми, что означает, что они не выполняются немедленно, а накапливаются для выполнения при вызове терминальной операции.

Некоторые примеры промежуточных методов в Stream API:
1.  `Stream<T> filter(Predicate<? super T> predicate`: фильтрует элементы стрима в соответствии с заданным предикатом.
2.  `<R> Stream<R> map(Function<? super T, ? extends R> mapper)`: преобразует каждый элемент стрима в другой объект с помощью заданной функции.
3. `<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)`: преобразует каждый элемент стрима в стрим, а затем объединяет полученные стримы в один.
4. `Stream<T> distinct()`: удаляет дубликаты из стрима.
5. `Stream<T> sorted(); Stream<T> sorted(Comparator<? super T> comparator)`: сортирует элементы стрима.
6. `Stream<T> limit(long maxSize)`: ограничивает количество элементов в стриме.
7. `Stream<T> skip(long n)`: пропускает указанное количество элементов в стриме.

##### О map(), peek() и flatMap() подробнее
1. **Метод `<R> Stream<R> map(Function<? super T, ? extends R> mapper)`:
    - Использует интерфейс `Function`, который преобразует элементы потока и возвращает результат.
    - Метод `map` применяет функцию к каждому элементу потока и возвращает поток, содержащий результаты преобразования.
    - Это операция преобразования, которая используется для изменения элементов потока и получения нового потока с измененными значениями.

2. **Метод `Stream<T> peek(Consumer<? super T> action)`**:
	- Использует интерфейс `Consumer`, который не возвращает результат.
	- Метод `peek` применяет действие к каждому элементу потока, но не изменяет их, а также не возвращает новые значения.
	- Это побочная операция, которая может быть использована для логирования, отладки или выполнения других действий с элементами потока без их изменения.

1. **Метод `<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)`:
    - `flatMap()` принимает функцию, которая преобразует каждый элемент исходного стрима в другой стрим, а затем объединяет эти стримы в один стрим.
    - Возвращает один стрим, содержащий объединенные результаты.
    - Используется, когда каждый элемент стрима нужно преобразовать в стрим, а затем объединить эти стримы в один.
    - Часто используется для слияния списков или коллекций в один плоский стрим.
    - Пример использования: объединение нескольких списков в один или разбиение строки на слова и дальнейшая обработка каждого слова.

**Отличия между `map()` и `flatMap()`**:
- `map()` преобразует каждый элемент непосредственно в другой объект, в то время как `flatMap()` преобразует каждый элемент в стрим и затем объединяет эти стримы в один.
- Результат `map()` - стрим объектов, тогда как результат `flatMap()` - один стрим элементов.
- Если функция `flatMap()` возвращает пустой стрим для какого-то элемента, этот элемент исключается из итогового стрима.

#### 6. Методы конвейерные 
Конвейерные методы в Stream API - это методы, которые можно объединять последовательно для создания цепочки операций над элементами стрима. Эти методы принимают стрим как аргумент, выполняют какие-то операции над его элементами и возвращают другой стрим. Таким образом, результат одного метода становится входным данным для следующего метода в цепочке.

![[Pasted image 20240325142844.png]]

#### 7. Методы терминальные 
Терминальные методы в Stream API - это методы, которые завершают выполнение последовательности операций над элементами стрима и возвращают результат. После вызова терминального метода выполнение стрима завершается, и нельзя применять к нему дополнительные операции.

![[Pasted image 20240325143857.png]]
#### 8. Методы числовых стримов 
Это специальные методы, которые работают только со стримами с числовыми
примитивами. **Специализированные stream-ы есть только для int, long и double.**
![[Pasted image 20240325143922.png]]

#### 9. Расскажите про класс Collectors и его методы. 
`Collector` в Java является интерфейсом, который определяет операцию сбора (collecting) элементов из потока (stream) в различные структуры данных, такие как списки, множества, мапы и другие.

`Collectors` - это утилитарный класс, предоставляющий широкий набор предопределенных коллекторов для использования с операциями стримов. **Он позволяет собирать элементы стрима в различные контейнеры данных или выполнять reduce операции.**

Связь между `Collector` и `Collectors` заключается в том, что `Collectors` предоставляет ряд методов, которые возвращают реализации интерфейса `Collector` для часто используемых операций сбора, таких как сбор элементов в списки, множества, карты и т. д. Эти методы возвращают готовые коллекторы, которые можно использовать непосредственно в операции сбора элементов в Java Stream API.

**Reduction operations (операции сокращения)** в контексте Stream API в Java представляют собой операции, которые сводят (редуцируют) элементы стрима к одному значению. Эти операции начинаются с некоторого начального значения (identity) и комбинируют элементы стрима с этим значением, используя некоторую операцию, чтобы получить результирующее значение.
**Пояснение:** Когда вы вызываете, например, метод `toList()` на стриме данных, он проходит по всем элементам этого стрима и добавляет их в список. Этот процесс можно рассматривать как сведение (или "редукцию") всех элементов стрима к одной структуре данных - списку.

Примеры reduction operations включают в себя операцию суммирования (sum), нахождение минимального или максимального элемента (min, max), нахождение среднего значения (average), конкатенацию строк (joining).

1. **Методы для сбора коллекций:**
    - `Collectors.toList()`: Создает список из элементов потока.
    - `Collectors.toSet()`: Создает множество из элементов потока.
    - `Collectors.toCollection(collectionFactory)`: Создает указанную коллекцию из элементов потока, используя предоставленную фабрику коллекций.
2. **Методы для сбора элементов потока в Map:**
    - `Collectors.toMap(keyMapper, valueMapper)`: Создает карту, в которой ключами являются результаты применения функции `keyMapper` к элементам потока, а значениями - результаты применения функции `valueMapper`.
    - `Collectors.groupingBy(classifier)`: Группирует элементы потока в карту, используя результаты применения функции `classifier` в качестве ключей.
    - `Collectors.partitioningBy(predicate)`: Разделяет элементы потока на две группы на основе результата применения предиката `predicate`.
3. **Методы для группировки данных в Map:**
    - `Collectors.groupingBy(classifier, downstream)`: Группирует элементы потока в карту с использованием функции `classifier` в качестве ключей, а затем применяет функцию `downstream` к элементам каждой группы.
    - `Collectors.groupingBy(classifier, supplier, downstream)`: То же самое, но позволяет настроить тип создаваемой карты и тип создаваемых значений.
    - `Collectors.groupingByConcurrent(classifier, downstream)`: Аналог `groupingBy`, но создает конкурентную карту.
4. **Методы для изменения методов сбора:**
    - `Collectors.collectingAndThen(downstream, finisher)`: Применяет сначала указанный коллектор `downstream` к элементам потока, а затем применяет указанную функцию `finisher` к результату.
    - `Collectors.filtering(predicate, downstream)`: Применяет предикат `predicate` к элементам потока и затем применяет указанный коллектор `downstream` к отфильтрованным элементам.
5. **Методы для получения статистики:**
    - `Collectors.summarizingInt(mapper)`: Возвращает объект `IntSummaryStatistics`, содержащий статистическую информацию (минимум, максимум, среднее, сумма и количество элементов) о результате применения функции `mapper` к элементам потока типа `int`.
    - `Collectors.summarizingDouble(mapper)`: Аналогично, но для элементов типа `double`.
    - `Collectors.summarizingLong(mapper)`: Аналогично, но для элементов типа `long`.

#### 10. Расскажите о параллельной обработке в Java 8. 
В Java бывают еще и параллельные стримы, обрабатывающие свои элементы
одновременно в нескольких потоках.

![[Pasted image 20240325151311.png]]

Стримы могут быть последовательными и параллельными. Первые выполняются в
текущем потоке, вторые используют общий пул ForkJoinPool.commonPool().
В параллельном стриме элементы разделяются на группы. Их обработка проходит в
каждом потоке по отдельности. Затем они снова объединяются, чтобы вывести
результат. С помощью методов parallel и sequential можно явно указать, что нужно
сделать параллельным, а что — последовательным.

**Не рекомендуется применять параллельность для выполнения долгих операций** (например, извлечения данных из базы), потому что все стримы работают с общим
пулом. Долгие операции могут остановить работу всех параллельных стримов в Java
Virtual Machine из-за того, что в пуле не останется доступных потоков.

Чтобы избежать такой проблемы, используйте параллельные стримы только для коротких операций, выполнение которых занимает миллисекунды, а не секунды и тем более минуты.
В Stream API по умолчанию скрыта работа с поток небезопасными коллекциями,
разделение на части и объединение элементов. Это отличное решение. Разработчику
остается только выбирать нужные методы и следить за тем, чтобы не было зависимостей от внешних факторов.

#### 11. Что такое IntStream и DoubleStream?
Существуют специализированные stream-ы: IntStream, LongStream, DoubleStream.

У них есть все методы, что и в обычном Stream, но также существуют дополнительные методы: count, average, sum, min, max, range и другие.

Эти stream-ы специально созданы для примитивных типов, так как обычный Stream
работает с объектами, а значит, в нем будут накладные расходы на автоупаковку и
автораспаковку. **Специализированные stream-ы есть только для int, long и double.**
Для других примитивных типов специализированных stream-ов нет.
#### Порядок обработки элементов стрима операциями
Обрабатывает каждый элемент отдельно, проводя его по всем доступным операциям
![[Pasted image 20240329181928.png]]
![[Pasted image 20240329182147.png]]

#### Заметка про Spliterator
`Spliterator` (split-iterator) - это разновидность итератора, представленная в Java начиная с версии 8. Основное отличие между `Spliterator` и обычным `Iterator` заключается в возможности разделения данных на части для обработки параллельно, что делает его особенно полезным в контексте потоков данных (Streams).

Вот несколько ключевых отличий `Spliterator` от обычного `Iterator`:
1. **Параллельная обработка данных**: Основная цель `Spliterator` - обеспечить возможность параллельной обработки данных. В отличие от обычного `Iterator`, который обрабатывает данные последовательно, `Spliterator` позволяет разделять данные на части и обрабатывать их параллельно в нескольких потоках.
    
2. **Разделение данных**: `Spliterator` предоставляет метод `trySplit()`, который позволяет разделить набор данных на две части. Это позволяет эффективно обрабатывать большие объемы данных параллельно, разделяя их на более мелкие части для обработки в отдельных потоках.
    
3. **Поддержка характеристик**: `Spliterator` предоставляет набор характеристик, которые определяют его поведение и возможности. Эти характеристики, такие как SIZED, SORTED, DISTINCT и другие, предоставляют информацию о свойствах данных и способе их обработки.
    
4. **Поддержка параллельных потоков данных**: `Spliterator` активно используется в потоках данных (Streams) в Java для обработки данных параллельно. Он позволяет потокам данных разделять итерируемые данные на части и обрабатывать их параллельно в нескольких потоках, что улучшает производительность и эффективность обработки данных.

`Spliterator` широко используется в стандартной библиотеке Java для обработки данных параллельно в потоках данных (Streams) и других структурах данных. Вот несколько примеров, где `Spliterator` используется в стандартной библиотеке Java:

1. **Потоки данных (Streams)**: Одним из основных мест использования `Spliterator` являются потоки данных в пакете `java.util.stream`. Многие операции над потоками данных, такие как `filter()`, `map()`, `reduce()` и другие, используют `Spliterator` для разделения и обработки данных параллельно.
    
2. **Коллекции**: Некоторые коллекции из пакета `java.util`, такие как `ArrayList`, `LinkedList`, `HashSet`, `TreeSet`, `HashMap`, `TreeMap` и другие, предоставляют методы для получения `Spliterator`, что позволяет обрабатывать элементы коллекции параллельно.
    
3. **Массивы**: В классе `java.util.Arrays` также имеются методы для создания сплитераторов для массивов, такие как `spliterator()`, `spliterator(T[] array)` и другие.
    
4. **Разделенные строки (Splittable strings)**: В Java 8 появился интерфейс `java.util.Splittable`, который предоставляет способ разделения строки на части для обработки параллельно. Это часто используется в потоках данных для обработки строк.