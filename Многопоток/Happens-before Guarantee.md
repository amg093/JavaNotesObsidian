Гарантия "happens-before" в Java представляет собой набор правил, определяющих, как виртуальная машина Java и центральный процессор (CPU) могут переупорядочивать инструкции для повышения производительности. Гарантия "happens-before" позволяет потокам опираться на то, когда значение переменной синхронизируется с главной памятью (main memory), и какие другие переменные были синхронизированы в то же время. Правила гарантии "happens-before" в Java сосредоточены вокруг доступа к волатильным переменным и переменным, к которым происходит доступ из синхронизированных блоков.

Этот учебник о гарантии "happens-before" в Java упомянет гарантии "happens-before", предоставляемые в Java для волатильных и синхронизированных объявлений, но в этом учебнике я не буду подробно останавливаться на этих объявлениях.

Переупорядочивание инструкций Современные центральные процессоры (CPU) имеют возможность выполнять инструкции параллельно, если эти инструкции не зависят друг от друга. Например, следующие две инструкции не зависят друг от друга и могут быть выполнены параллельно:

a = b + c
d = e + f 

Однако следующие две инструкции не могут быть легко выполнены параллельно, потому что вторая инструкция зависит от результата первой инструкции:

a = b + c 
d = a + e 

Представьте, что эти две инструкции выше являются частью более крупного набора инструкций, например, как ниже:

a = b + c 
d = a + e
l = m + n 
y = x + z 

Инструкции могут быть переупорядочены, как показано ниже. Затем процессор может выполнить по крайней мере первые 3 инструкции параллельно, и как только первая инструкция будет завершена, он может начать выполнение 4-й инструкции.

a = b + c
l = m + n 
y = x + z
d = a + e 

Как видите, переупорядочивание инструкций может увеличить параллельное выполнение инструкций в центральном процессоре. Увеличение параллелизма означает повышение производительности.

Переупорядочивание инструкций разрешено для виртуальной машины Java и центрального процессора (CPU), пока семантика программы не изменяется. Конечный результат должен быть таким же, как если бы инструкции были выполнены в точном порядке, указанном в исходном коде.

##### **Проблемы переупорядочивания инструкций в многопроцессорных компьютерах** 
Переупорядочивание инструкций представляет некоторые вызовы в многопоточной, многопроцессорной системе. Я постараюсь проиллюстрировать эти проблемы через пример кода. Имейте в виду, что пример создан специально для иллюстрации этих проблем. Таким образом, пример кода не является рекомендацией в любом случае!

Представьте два потока, которые сотрудничают, чтобы рисовать кадры на экране так быстро, как только могут. Один поток генерирует кадры, а другой поток рисует кадры на экране.

Этим двум потокам нужно обмениваться кадрами через некий механизм связи. В следующем примере кода я создал пример такого механизма связи - класс Java с именем FrameExchanger.

Поток, создающий кадры, производит кадры так быстро, как только может. Поток рисования кадров будет рисовать эти кадры так быстро, как только может.

Иногда поток-производитель может создать 2 кадра, прежде чем поток рисования успеет их нарисовать. В этом случае на экран должен быть нарисован только последний кадр. Мы не хотим, чтобы поток рисования отставал от потока-производителя. Если поток-производитель имеет новый кадр готовым до того, как предыдущий кадр будет нарисован, предыдущий кадр просто заменяется новым кадром. Другими словами, предыдущий кадр "отбрасывается".

Иногда поток рисования может нарисовать кадр и быть готовым нарисовать новый кадр до того, как поток-производитель создаст новый кадр. В этом случае мы хотим, чтобы поток рисования ждал новый кадр. Нет никакой причины тратить ресурсы центрального процессора (CPU) и графического процессора (GPU) на перерисовку того же самого кадра, который был только что нарисован! Экран не изменится от этого, и пользователь не увидит ничего нового.

FrameExchanger подсчитывает количество сохраненных кадров и количество взятых кадров, чтобы мы могли понять, сколько кадров было отброшено.

Вот код для FrameExchanger. Обратите внимание: определение класса Frame опущено. Для понимания работы FrameExchanger не важно, как выглядит этот класс. Поток-производитель будет вызывать storeFrame() непрерывно, а поток рисования будет вызывать takeFrame() непрерывно.

```java
public class FrameExchanger  {  
  
    private long framesStoredCount = 0;  
    private long framesTakenCount  = 0;  
  
    private boolean hasNewFrame = false;  
  
    private Frame frame = null;  
  
    // вызывается потоком-производителем  
    public void storeFrame(Frame frame) {  
        this.frame = frame;  
        this.framesStoredCount++;  
        this.hasNewFrame = true;  
    }  
  
    // вызывается потоком рисования кадров  
    public Frame takeFrame() {  
        while( !hasNewFrame) {  
            // ожидание появления нового кадра  
        }  
  
        Frame newFrame = this.frame;  
        this.framesTakenCount++;  
        this.hasNewFrame = false;  
        return newFrame;  
    }  
}
```

Обратите внимание, как три инструкции внутри метода storeFrame() кажутся, что они не зависят друг от друга. Это означает, что виртуальной машине Java и центральному процессору (CPU) кажется, что было бы нормально переупорядочить инструкции, если бы виртуальная машина Java или центральный процессор решил, что это было бы выгодно. Однако представьте, что произойдет, если инструкции будут переупорядочены, как это:

```java
public void storeFrame(Frame frame) {
    this.hasNewFrame = true;
    this.framesStoredCount++;
    this.frame = frame;
}
```

Обратите внимание, как поле hasNewFrame теперь устанавливается в true перед тем, как поле frame ссылается на новый объект Frame. Это означает, что если поток рисования ожидает в while-цикле в методе takeFrame(), поток рисования может выйти из этого цикла, и взять старый объект Frame. Это приведет к перерисовке старого кадра, что приведет к потере ресурсов.

Очевидно, что в этом конкретном случае перерисовка старого кадра не приведет к сбою или неправильной работе приложения. Это просто расточительство ресурсов центрального процессора (CPU) и графического процессора (GPU). Однако в других случаях такое переупорядочивание инструкций может вызвать сбой приложения.

##### Гарантия видимости Java volatile
Ключевое слово volatile в Java обеспечивает некоторые гарантии видимости для записи и чтения переменных volatile, что приводит к синхронизации значения переменной с и из основной памяти. Эта синхронизация с и из основной памяти является тем, что делает значение видимым для других потоков. Отсюда и термин "гарантия видимости".

В этом разделе я кратко расскажу о гарантии видимости Java volatile и объясню, как переупорядочивание инструкций может нарушить гарантию видимости volatile. Вот почему у нас также есть гарантия happens-before для volatile в Java, чтобы наложить некоторые ограничения на переупорядочивание инструкций, чтобы гарантия видимости volatile не была нарушена переупорядочиванием инструкций.

##### Гарантия записи видимости Java volatile
Когда вы пишете в переменную Java volatile, значение гарантированно записывается непосредственно в основную память. Кроме того, все переменные, видимые для потока, записывающего в переменную volatile, также синхронизируются с основной памятью.

Чтобы проиллюстрировать гарантию записи видимости Java volatile, рассмотрим следующий пример:
```java
this.nonVolatileVarA = 34;
this.nonVolatileVarB = new String("Text");
this.volatileVarC    = 300;
```
Этот пример содержит две записи в неволатильные переменные и одну запись в волатильную переменную. Пример не явно показывает, какая переменная объявлена волатильной, так что для ясности представьте, что переменная (поле, на самом деле) с именем volatileVarC объявлена волатильной.

Когда третья инструкция в приведенном выше примере записывает значение в волатильную переменную volatileVarC, значения двух неволатильных переменных также будут синхронизированы с основной памятью - потому что эти переменные видимы потоку при записи в волатильную переменную.

##### Гарантия чтения видимости Java volatile
При чтении значения переменной Java volatile значение гарантированно считывается непосредственно из памяти. Более того, все переменные, видимые для потока, считывающего волатильную переменную, также обновляют свои значения из основной памяти.

Для иллюстрации гарантии чтения видимости Java volatile рассмотрим следующий пример:
```java
c = other.volatileVarC;
b = other.nonVolatileB;
a = other.nonVolatileA;
```
Обратите внимание, что первая инструкция является чтением волатильной переменной (other.volatileVarC). Когда other.volatileVarC считывается из основной памяти, также считываются other.nonVolatileB и other.nonVolatileA из основной памяти.

##### Гарантия happens-before для volatile в Java
Гарантия happens-before для volatile в Java накладывает некоторые ограничения на переупорядочивание инструкций вокруг волатильных переменных. Чтобы понять, почему эта гарантия необходима, давайте изменит класс FrameExchanger из предыдущего урока так, чтобы переменная hasNewFrame была объявлена волатильной:
```java
public class FrameExchanger  {

    private long framesStoredCount = 0;
    private long framesTakenCount  = 0;

    private volatile boolean hasNewFrame = false;

    private Frame frame = null;

        // вызывается производящим потоком кадров
    public void storeFrame(Frame frame) {
        this.frame = frame;
        this.framesStoredCount++;
        this.hasNewFrame = true;
    }

        // вызывается потоком рисования кадров
    public Frame takeFrame() {
        while( !hasNewFrame) {
            // ожидание появления нового кадра
        }

        Frame newFrame = this.frame;
        this.framesTakenCount++;
        this.hasNewFrame = false;
        return newFrame;
    }
}
```
Теперь, когда переменная hasNewFrame установлена в true, поля frame и frameStoredCount также будут синхронизированы с основной памятью. Кроме того, каждый раз, когда поток рисования считывает переменную hasNewFrame в цикле while внутри метода takeFrame(), поля frame и framesStoredCount также будут обновлены из основной памяти. Даже framesTakenCount будет обновлен из основной памяти на этом этапе.

Представьте, что если Java VM переупорядочила бы инструкции внутри метода storeFrame(), как показано ниже:
```java
// вызывается производящим потоком кадров
public void storeFrame(Frame frame) {
    this.hasNewFrame = true;
    this.framesStoredCount++;
    this.frame = frame;
}
```
Теперь поля framesStoredCount и frame будут синхронизированы с основной памятью, когда выполняется первая инструкция (потому что hasNewFrame является волатильной) - что происходит до того, как им присваиваются их новые значения!

Это означает, что поток рисования, выполняющий метод takeFrame(), может выйти из цикла while до того, как новое значение будет присвоено переменной frame. Даже если бы производящим потоком уже было присвоено новое значение переменной frame, нет гарантии, что это значение было бы синхронизировано с основной памятью и было бы видимо для потока рисования!

##### Гарантия happens-before для записи в волатильные переменные
Как видите, переупорядочивание инструкций внутри метода storeFrame() может привести к неполадкам в работе приложения. Вот где вступает в игру гарантия записи happens-before для волатильных переменных - чтобы наложить ограничения на то, какое переупорядочивание инструкций разрешается вокруг записей в волатильные переменные:

Запись в неволатильную или волатильную переменную, которая произошла до записи в волатильную переменную, гарантированно произошла до записи в эту волатильную переменную.

В случае метода storeFrame() это означает, что первые две инструкции записи не могут быть переупорядочены после последней записи в hasNewFrame, поскольку hasNewFrame является волатильной переменной.
```java
// вызывается производящим потоком кадров
public void storeFrame(Frame frame) {
    this.frame = frame;
    this.framesStoredCount++;
    this.hasNewFrame = true;  // hasNewFrame является волатильной
}
```
Первые две инструкции не пишут в волатильные переменные, поэтому их можно переупорядочить Java VM свободно. Таким образом, это переупорядочивание разрешено:
```java
// вызывается производящим потоком кадров
public void storeFrame(Frame frame) {
    this.framesStoredCount++;
    this.frame = frame;
    this.hasNewFrame = true;  // hasNewFrame является волатильной
}
```
Это переупорядочивание не нарушает код в методе takeFrame(), так как переменная frame все еще записывается до того, как переменная hasNewFrame записывается. Общая программа по-прежнему работает как задумано.

##### Гарантия happens-before для чтения волатильных переменных
В Java волатильные переменные имеют аналогичную гарантию happens-before для чтения волатильных переменных. Однако направление отличается:

Чтение волатильной переменной произойдет до любых последующих чтений волатильных и неволатильных переменных.

Когда я говорю, что направление отличается от записей, я имею в виду, что для волатильных записей все инструкции до записи останутся до волатильной записи. Для чтения волатильных переменных все чтения после волатильного чтения останутся после волатильного чтения.

Рассмотрим следующий пример:
```java
int a = this.volatileVarA;
int b = this.nonVolatileVarB;
int c = this.nonVolatileVarC;
```
Благодаря гарантии видимости волатильного чтения, когда this.volatileVarA считывается из основной памяти, также считываются все другие переменные, видимые потоку в то время. Таким образом, this.nonVolatileVarB и this.nonVolatileVarC также считываются из основной памяти в тот же момент. Это означает, что поток, который считывает volatileVarA, может полагаться на то, что nonVolatileVarB и nonVolatileVarC также обновлены в соответствии с основной памятью.

Если бы какая-либо из двух последних инструкций была переупорядочена выше первой волатильной инструкции чтения, гарантия для этой инструкции на момент ее выполнения не была бы выполнена. Вот почему позже чтения не могут быть переупорядочены, чтобы оказаться выше чтения волатильной переменной.

Что касается метода takeFrame(), первое чтение волатильной переменной - это чтение поля hasNewFrame внутри цикла while. Это означает, что ни одна из инструкций чтения не может быть переупорядочена так, чтобы находиться выше этой. В этом конкретном случае перемещение любой из других операций чтения выше цикла while также нарушило бы семантику кода, поэтому эти переупорядочивания все равно не были бы разрешены.
```java
// вызывается потоком рисования кадров
public Frame takeFrame() {
    while( !hasNewFrame) {
        // ожидание появления нового кадра
    }

    Frame newFrame = this.frame;
    this.framesTakenCount++;
    this.hasNewFrame = false;
    return newFrame;
}
```
##### Гарантия видимости в Java synchronized
Блоки synchronized в Java предоставляют гарантии видимости, аналогичные гарантиям видимости волатильных переменных в Java. Кратко расскажу о гарантии видимости в Java synchronized.
##### Гарантия видимости входа в synchronized Java
Когда поток входит в блок synchronized, все переменные, видимые потоку, обновляются из основной памяти.
##### Гарантия видимости выхода из synchronized Java
Когда поток выходит из блока synchronized, все переменные, видимые потоку, записываются обратно в основную память.

##### Пример использования synchronized в Java
Рассмотрим класс ValueExchanger:
```java
public class ValueExchanger {
    private int valA;
    private int valB;
    private int valC;

    public void set(Values v) {
        this.valA = v.valA;
        this.valB = v.valB;

        synchronized(this) {
            this.valC = v.valC;
        }
    }

    public void get(Values v) {
        synchronized(this) {
            v.valC = this.valC;
        }
        v.valB = this.valB;
        v.valA = this.valA;
    }
}
```
Обратите внимание на два блока synchronized внутри методов set() и get(). Заметьте, как блоки размещены в конце и в начале этих двух методов.

В методе set() синхронизированный блок в конце метода заставит все переменные синхронизироваться с основной памятью после их обновления. Это сбрасывание значений переменных в основную память происходит, когда поток выходит из блока synchronized. Поэтому он размещен в конце метода - для обеспечения того, что все обновленные значения переменных сброшены в основную память.

В методе get() синхронизированный блок размещен в начале метода. Когда поток, вызывающий get(), входит в синхронизированный блок, все переменные снова считываются из основной памяти. Вот почему этот синхронизированный блок размещен в начале метода - для обеспечения того, что все переменные обновляются из основной памяти перед их чтением.
##### Гарантия happens-before для блоков synchronized в Java
Блоки synchronized в Java предоставляют две гарантии happens-before: одна гарантия, связанная с началом блока synchronized, и другая - с концом блока synchronized. Обе они будут рассмотрены в следующих разделах.
##### Гарантия начала блока synchronized в Java
Начало блока synchronized в Java обеспечивает гарантию видимости (упомянутую ранее в этом руководстве), что когда поток входит в блок synchronized, все переменные, видимые потоку, будут считаны (обновлены) из основной памяти.

Чтобы соблюсти эту гарантию, необходим набор ограничений на переупорядочивание инструкций. Чтобы проиллюстрировать это, я использую метод get() из ValueExchanger, показанный ранее:
```java
public void get(Values v) {
    synchronized(this) {
        v.valC = this.valC;
    }
    v.valB = this.valB;
    v.valA = this.valA;
}
```

Как видите, синхронизированный блок в начале метода гарантирует, что все переменные this.valC, this.valB и this.valA будут снова считаны (обновлены) из основной памяти. Затем последующие чтения этих переменных будут использовать последнее значение.

Для этого ни одно из чтений переменных не может быть переупорядочено так, чтобы оно появлялось перед началом синхронизированного блока. Если бы чтение переменной было переупорядочено, чтобы оно появлялось перед началом синхронизированного блока, вы потеряли бы гарантию обновления значений переменных из основной памяти. Это было бы так в случае следующего запрещенного переупорядочивания инструкций:
```java
public void get(Values v) {
    v.valB = this.valB;
    v.valA = this.valA;
    synchronized(this) {
        v.valC = this.valC;
    }
}
```
##### Гарантия конца блока synchronized в Java
Конец блока synchronized обеспечивает гарантию видимости того, что все измененные переменные будут записаны обратно в основную память, когда поток выходит из блока synchronized.

Для того чтобы соблюсти эту гарантию, необходим набор ограничений на переупорядочивание инструкций. Чтобы проиллюстрировать это, я использую метод set() из ValueExchanger, показанный ранее:
```java
public void set(Values v) {
    this.valA = v.valA;
    this.valB = v.valB;

    synchronized(this) {
        this.valC = v.valC;
    }
}
```
Как видите, синхронизированный блок в конце метода гарантирует, что все измененные переменные this.valA, this.valB и this.valC будут записаны обратно (сброшены) в основную память, когда поток, вызывающий set(), выходит из блоков synchronized.

Для этого ни одна из записей переменных не может быть переупорядочена так, чтобы она появлялась после окончания синхронизированного блока. Если бы записи переменных были переупорядочены так, чтобы они появлялись после окончания синхронизированного блока, вы потеряли бы гарантию записи обновленных значений переменных в основную память. Это было бы так в случае следующего запрещенного переупорядочивания инструкций:
```java
public void set(Values v) {
    synchronized(this) {
        this.valC = v.valC;
    }
    this.valA = v.valA;
    this.valB = v.valB;
}
```