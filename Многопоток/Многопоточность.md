#### 1. Чем процесс отличается от потока? 
**Процесс** – это исполняемая программа, которая создается операционной системой при запуске приложения. Он обладает собственным адресным пространством памяти и включает в себя код и данные программы. Процессы работают независимо друг от друга, имеют свои собственные ресурсы и не имеют прямого доступа к данным других процессов. Создание нового процесса обычно включает в себя дублирование родительского процесса.

**Поток** – это наименьшая единица выполнения внутри процесса, также называемая легковесным процессом. Потоки могут выполняться параллельно друг с другом в рамках одного процесса. Они совместно используют адресное пространство памяти процесса и могут контролироваться и взаимодействовать друг с другом с помощью методов `wait()`, `notify()` и `notifyAll()`. 
**Операционная система создает процесс при запуске программы, загружая в него код и данные программы, а затем запускает главный поток созданного процесса.**

**Виртуальное адресное пространство** является важным абстрактным концептом в операционных системах, который определяет организацию доступной памяти для каждого процесса и обеспечивает изоляцию и безопасность выполнения программ.

**Многопоточность** – это принцип построения программы, при котором несколько блоков кода могут выполняться одновременно.
#### 2. Чем Thread отличается от Runnable? Когда нужно использовать Thread, а когда Runnable? 
1. **Thread (Поток)**:
    - Используйте `Thread`, когда вам нужно управлять всем жизненным циклом потока, таким как создание, запуск, приостановка и прерывание.
    - Когда вы наследуете класс `Thread`, вы получаете доступ ко всем методам и свойствам потока, что позволяет вам управлять им более прямым и контролируемым способом. 
    - Нужно предоставить собственную реализацию метода run.
    - Однако использование класса `Thread` ограничивает вашу возможность наследовать другие классы, поскольку в Java поддерживается только одиночное наследование.
    - Чтобы породить новый поток нужно: 
	    1) Создать объект класса Thread 
	    2) Передать в него метод, который нужно выполнить 
	    3) Вызвать у созданного объект Thread метод start()
    
1. **Runnable (Выполнимый)**:
    - Используйте `Runnable`, когда вы хотите отделить логику выполнения от контекста выполнения, то есть когда вы хотите использовать один и тот же код выполнения в нескольких потоках с разными контекстами.
    - Нужно предоставить собственную реализацию метода run.
    - Поскольку `Runnable` является функциональным интерфейсом, вы можете передать любой объект, реализующий его, в конструктор `Thread`. Это означает, что вы можете использовать лямбда-выражения или анонимные классы, чтобы легко передавать код выполнения в потоки.
    - Более того, использование `Runnable` позволяет избежать ограничений наследования классов в Java, поскольку класс, реализующий `Runnable`, может наследовать другие классы.

Оба вызывают Thread.start, чтобы запустить новый поток.

**Наследование класса Thread целесообразно применять когда нужно дополнить функциональность самого класса Thread**.****

**Использование интерфейса Runnable – когда просто нужно одновременно выполнить несколько задач и не требуется вносить изменений в сам механизм многопоточности.**
```java
public class MyThread0 implements Runnable {  
	@Override  
	public void run() {  
		for (int i = 1; i<=10; i++) {  
			System.out.println(i);  
		}  
	}  
}  
  
class MyThread1 extends Thread {  
	public void run() {  
		for (int i = 10; i>0; i--) {  
			System.out.println(i);  
		}  
	}  
}  
  
class ThreadTest {  
	public static void main(String[] args) {  
	Thread thread = new Thread(new MyThread0());  
	Thread thread1 = new Thread(new MyThread1());  
	thread.start();  
	thread1.start();  
	}  
}
```
#### 3. Как выполнить две задачи параллельно? 
Простейший, путь – явно создать два объекта типа `Thread`, передать им инстансы `Runnable`, с нужными задачами в реализации их методов `run`, и запустить вызвав `thread.start()`. Если в основном потоке нужно дождаться завершения задач, то после `start()` вызывается метод `thread.join()`. Исполнение зависнет на вызове этого метода до тех пор, пока тред не закончит свою задачу и не умрет. Вся работа задач с внешними данными должна быть синхронизирована. 

Такое ручное создание тредов полезно в учебных целях, но считается плохой практикой в промышленном коде: само создание – дорогостоящая операция, а большое количество случайно созданных потоков может приводить к проблеме голодания потоков (starvation). 
В качестве продвинутой альтернативы используются пулы потоков – реализации интерфейса `ExecutorService`. 
Такие сервисы создаются статическими фабричными методами класса `Executors` (исполнители). Они умеют принимать задачи в виде `Runnable` или `Callable` объектов на заранее созданном наборе потоков (собственно, пуле).

Кроме основного пула потоков для выполнения задач, экземпляры `ExecutorService` также **содержат фабрику потоков и очередь задач на исполнение.**

```java
public static void main(String[] args) throws InterruptedException {  
	// Создание пула потоков с фиксированным числом потоков  
	ExecutorService executor = Executors.newFixedThreadPool(2);  
  
	// Постановка задач на выполнение в пуле  
	executor.submit(new MyTask("Task 1"));  
	executor.submit(new MyTask("Task 2"));  
	executor.submit(new MyTask("Task 3"));  
	executor.submit(new MyTask("Task 4"));  
  
	// Остановка пула потоков после выполнения всех задач  
	executor.shutdown();  
	// Принужадет поток подождать до тех пор, пока не выполнится:  
	//либо ExecutorService.shutdown() - return true  
	//либо пройдет время, указанное в параметре awaitTermination - return  false  
	executor.awaitTermination(5, TimeUnit.SECONDS);  
}
```

1. **Фабрика потоков (Thread Factory)**: Фабрика потоков (`ThreadFactory`) представляет собой интерфейс, определяющий способ создания новых потоков при необходимости. Когда `ExecutorService` нуждается в создании нового потока для выполнения задачи, он обращается к фабрике потоков для создания нового экземпляра потока. Фабрика потоков обеспечивает абстракцию относительно того, как именно потоки создаются, что позволяет гибко настраивать процесс создания потоков. Например, можно определить собственную реализацию фабрики потоков для установки определенных параметров для создаваемых потоков (например, приоритеты, имена и т. д.).
    
2. **Очередь задач (Task Queue)**: Очередь задач представляет собой коллекцию, в которой хранятся задачи, поставленные на выполнение через `ExecutorService`. Когда поступает новая задача, она добавляется в эту очередь. Пул потоков потом поочередно берет задачи из очереди и выполняет их. Это обеспечивает управление порядком выполнения задач и предотвращает голодание потоков. Очередь задач может быть реализована с использованием различных структур данных, таких как блокирующая очередь (`BlockingQueue`), которая обеспечивает безопасное многопоточное доступ к элементам очереди.

`ScheduledExecutorService` используем, когда хотим установить расписание на запуск потоков из пула. Создается методом класса `Executors - Executors.newScheduledThreadPool(int count)`.

В ответ на передачу на исполнение `Runnable` или `Callable`, сервис возвращает связанный с ним объект типа `Future` – хранилище, которое будет заполнено результатом выполнения задачи в будущем. Даже если никакого результата не ожидается, `Future` поможет дождаться момента завершения обработки задачи.
##### Вот некоторые из основных методов `ScheduledExecutorService`:
1. **`schedule(Runnable command, long delay, TimeUnit unit):`** этот метод запускает задачу на выполнение через определенное время (задержку). `command` - это задача, которая будет выполнена. `delay` - это время задержки до запуска задачи, а `unit` - единица измерения времени (например, `TimeUnit.SECONDS`).
2. **`schedule(Callable<V> callable, long delay, TimeUnit unit):`** Аналогично предыдущему методу, но вместо `Runnable` он принимает `Callable`, который возвращает результат.
3. **`scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit):`** Этот метод запускает задачу с фиксированной частотой выполнения. `initialDelay` - это время задержки перед первым выполнением задачи, `period` - период выполнения задачи, а `unit` - единица измерения времени. Задача будет выполняться первый раз через `initialDelay`, а затем с интервалом `period`.
4. **`scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit):`** Этот метод запускает задачу с фиксированной задержкой между завершением предыдущего выполнения и началом следующего выполнения. `initialDelay` - это время задержки перед первым выполнением задачи, `delay` - задержка между завершением предыдущего выполнения и началом следующего, а `unit` - единица измерения времени.
#### 4. Что такое монитор? Как монитор реализован в java? 
1. **Монитор**:
    - Монитор - это механизм синхронизации, который обеспечивает корректную работу и доступ к неразделяемым ресурсам при синхронизации. Он предотвращает одновременный доступ к общим ресурсам из нескольких потоков, что может привести к гонкам данных и ошибкам в программе.
    - Частью монитора является мьютекс (mutex), который является встроенным в класс `Object` и есть у каждого объекта. Мьютекс (или lock) используется для управления доступом к критическим секциям кода и обеспечивает эксклюзивный доступ к ресурсам.

2. **Mutex (Мьютекс)**:
    - Mutex - это синхронизационный примитив, который может иметь два состояния: свободен или занят.
    - Каждый объект в Java имеет свой мьютекс, который используется для синхронизации доступа к этому объекту.
    - **Мьютекс можно представить как одноместный семафор. Если мьютекс свободен (его id равен 0), то ресурс доступен для использования. Если мьютекс занят (его id не равен 0), поток должен встать в очередь и ждать, пока мьютекс не освободится.**

3. **Ключевое слово synchronized**:
    - **В Java монитор реализован с помощью ключевого слова `synchronized`.**
    - Когда блок кода или метод помечается ключевым словом `synchronized`, мьютекс объекта захватывается, блокируя доступ к критической секции кода для других потоков.
    - Это позволяет предотвратить гонки данных и обеспечить согласованность разделяемых ресурсов в многопоточной среде.

#### 5. Что такое синхронизация? Какие способы синхронизации существуют в java? 
Синхронизация в Java - это процесс управления параллельным выполнением потоков для предотвращения гонок данных и повреждения состояния объектов. В Java каждый объект имеет встроенную блокировку, которая обеспечивает эксклюзивный доступ к критическому коду в объекте, позволяя только одному потоку выполнять операции над объектом в конкретный момент времени. Это помогает предотвратить повреждение состояния объекта и обеспечить корректное выполнение параллельных потоков.

В Java существует несколько способов синхронизации, включая:

1. **Системная синхронизация с использованием методов wait() и notify()**: Потоки могут использовать методы wait() и notify() для организации ожидания и уведомления о событиях. Метод wait() заставляет поток ожидать до тех пор, пока другой поток не вызовет метод notify(), который уведомляет ожидающие потоки о том, что событие произошло.
2. **Системная синхронизация с использованием метода join()**: Потоки могут использовать метод join(), чтобы ожидать завершения работы другого потока, прежде чем продолжить свою работу.
3. **Использование классов из пакета java.util.concurrent.locks**: Java предоставляет различные механизмы синхронизации в пакете `java.util.concurrent.locks`, такие как Lock, Condition и ReadWriteLock, которые предоставляют более гибкие и мощные способы синхронизации потоков, чем базовые методы synchronized, wait и notify.
>[!WARNING]
>`wait()` и `notify()` не синхронизированы. Для использования этих методов без ошибок синхронизации, необходимо захватить монитор объекта, вызывая эти методы, в явном виде, используя блокировку с помощью ключевого слова `synchronized`.
>
	synchronized (monitorObject) {
    // код, который может потребовать ожидания
    monitorObject.wait(); 
    // вызов метода wait() внутри синхронизированного блока

#### 6. Как работают методы Object wait(), notify() и notifyAll()? 

Методы `wait(), notify(), notifyAll()` должны вызываться только из синхронизированного кода. Для извещения потоком других потоков о своих действиях часто используются следующие методы: 
- `wait()` – тормозит текущий поток на этом объекте (ждите) и отпускает его монитор (уступает дорогу). 
- `notify()` – НЕ освобождает монитор и будит поток, у которого был ранее вызван метод `wait()`; 
- `notifyAll()` – НЕ освобождает монитор и будит ВСЕ потоки, у которых ранее был вызван метод `wait()`;

1. **Захват монитора**: Чтобы вызвать методы `wait()`, `notify()` или `notifyAll()` у объекта, необходимо, чтобы поток уже захватил монитор этого объекта, то есть находился внутри `synchronized`-блока для этого объекта. Иначе будет выброшено исключение `IllegalMonitorStateException`.
    
2. **Ожидание и уведомление**: Метод `wait()` блокирует текущий поток на ожидание на объекте и освобождает монитор, позволяя другим потокам работать с этим объектом. Методы `notify()` и `notifyAll()` используются для уведомления ожидающих потоков о изменении состояния объекта.
    
3. **Spurious wakeup:** В теории, ожидание методом `wait()` может быть прервано без вызова `notify()`, это называется "ложными/случайными пробуждениями" (spurious wakeup). Хотя такие случаи крайне редки, рекомендуется после вызова `wait()` добавлять дополнительную проверку условия, по которому поток был приостановлен.
    
4. **Исключения и таймауты**: Метод `wait()` может завершиться не только из-за вызова `notify()` или `notifyAll()`, но и из-за прерывания потока извне или по истечении времени ожидания (таймаута). При прерывании выбрасывается исключение `InterruptedException`, а при таймауте поток просто продолжает выполнение. Для таймаута нужно указать время ожидания параметрами метода wait. Значение 0 игнорируется.
##### Подробнее:
1. **wait()**: Метод `wait()` вызывается на объекте и заставляет текущий поток ожидать, пока другой поток не вызовет метод `notify()` или `notifyAll()` для этого же объекта. Когда поток вызывает `wait()`, он освобождает монитор объекта, на котором он вызывается, и переходит в состояние ожидания. Другие потоки могут продолжать работу с этим объектом. После того как другой поток вызывает `notify()` или `notifyAll()`, один или все ожидающие потоки будут разбужены, и они снова попытаются захватить монитор объекта и продолжить выполнение.
    
2. **notify()**: Метод `notify()` вызывается на объекте и уведомляет один из потоков, ожидающих на этом объекте, что состояние объекта изменилось и они могут попытаться продолжить выполнение. Если на объекте есть несколько потоков, ожидающих вызова `wait()`, то не гарантируется, какой именно поток будет разбужен методом `notify()`.
    
3. **notifyAll()**: Метод `notifyAll()` вызывается на объекте и уведомляет все потоки, ожидающие на этом объекте, что состояние объекта изменилось и они могут попытаться продолжить выполнение. Все ожидающие потоки будут разбужены, и они будут соперничать за доступ к монитору объекта.

##### Напоминание о видах блокировок:
1. **Пессимистическая блокировка**:
    - В пессимистической блокировке поток блокирует доступ к общему ресурсу сразу после того, как начинает выполнение операции над ним.
    - Поток блокирует ресурс и удерживает блокировку до тех пор, пока не закончит выполнение операции.
    - Этот подход обеспечивает полную защиту от гонок данных и других проблем синхронизации, но может привести к потере производительности из-за частых блокировок и ожиданий.
    
2. **Оптимистическая блокировка**:
    - В оптимистической блокировке поток не блокирует ресурс сразу, а сначала выполняет операции над ресурсом, предполагая, что другие потоки не будут его изменять.
    - После завершения операции поток проверяет, не изменился ли ресурс в процессе выполнения операции.
    - Если ресурс не изменился, операция считается успешной. Если же ресурс изменился, поток повторяет операцию или выполняет какие-то дополнительные действия для обработки конфликта.
    - Оптимистическая блокировка может увеличить производительность за счет снижения количества блокировок и ожиданий, но требует дополнительных механизмов для обработки конфликтов и восстановления целостности данных.

#### 7. В каких состояниях может находиться поток? 
**Жизненный цикл потока:** 
Поток может находиться в одном из состояний, соответствующих элементам статически вложенного перечисления `Thread.state`:
- **New** – поток создан, но еще не запущен 
- **Runnable** – поток выполняет методы: `start()`, принудительное продолжение `notify(), notifyAll()`. 
- **Blocked** – поток блокирован (состояние возникает при синхронизации: вызов методов помеченных, как `synchronized`) 
- **Waiting** – поток ждёт окончания работы другого потока или принудительного продолжения. Методы: `join(), wait()
- **Timed_waiting** – поток некоторое время ждёт окончания другого потока. Методы: `yield(), sleep(long mills), join(long timeout) и wait(long timeout)`. 
- **Terminated** – поток завершён. Методы: `interrupt(), stop()` (deprecated) или нормальное завершение метода `run()`. 
- **Dead** — после того, как поток завершил свое выполнение, его состояние меняется на dead, то есть он завершает свой жизненный цикл. 

**Получить текущее значение состояния потока можно через getState().**

##### Подробнее:
1. **New (новый)**: Поток создан, но еще не запущен. В этом состоянии потоку не были выделены системные ресурсы и он не начал выполнение.
    
2. **Runnable (выполняемый)**: Поток находится в этом состоянии, когда он готов к выполнению и может быть запущен методом `start()`. Также из этого состояния поток может быть временно приостановлен и возобновлен с помощью методов `notify()` и `notifyAll()`.
    
3. **Blocked (заблокированный)**: Поток находится в этом состоянии, когда он ожидает доступа к ресурсу, который заблокирован другим потоком. Это происходит, например, при попытке входа в синхронизированный блок кода или метод, когда монитор этого объекта уже захвачен другим потоком.
    
4. **Waiting (ожидающий)**: Поток находится в этом состоянии, когда он ожидает события, такие как завершение другого потока или принудительное возобновление. Это может происходить при вызове методов `join()`, `wait()`.
    
5. **Timed_waiting (ожидающий с таймаутом)**: Это подобное состояние ожидания, но с определенным временным интервалом, после которого поток автоматически перейдет в состояние Runnable. Это может происходить, например, при вызове методов `sleep()`, `yield()`, `join(long timeout)` или `wait(long timeout)`.
    
6. **Terminated (завершенный)**: Поток завершил свое выполнение. Это может произойти при нормальном завершении метода `run()`, вызове методов `interrupt()` или `stop()` (хотя последний также считается устаревшим и не рекомендуется к использованию).
    
7. **Dead**: После завершения выполнения поток переходит в состояние Dead, завершая свой жизненный цикл. В этом состоянии поток больше не существует как работающий поток и не может быть восстановлен.

#### 8. Что такое семафор? Как он реализован в Java? 
**Semaphore** представляет собой синхронизатор с счетчиком, который управляет доступом к определенному ресурсу. Он используется для защиты дорогих ресурсов, которые доступны в ограниченном количестве, таких как подключения к базе данных в пуле.

Когда поток входит в блок кода, защищенный Semaphore, счетчик уменьшается на единицу. Если счетчик становится равным нулю, поток блокируется и ждет, пока другой поток не выйдет из защищенного блока и не освободит ресурс, увеличивая при этом счетчик.

Уменьшение до 0 блокирует уменьшающий поток. Состояние, когда счетчик больше нуля называют сигнальное состояние, операцию его увеличения – release (освобождение) или signal, уменьшения – acquire (захват) или wait (ожидание). 
На практике можно представить, что release – выделение квоты доступа к критической секции программы, а acquire – использование необходимого объема доступной квоты, или ожидание, если её не хватает.

В классе `Semaphore` в Java содержатся различные формы методов `acquire()` и `release()`, предназначенных для управления семафором. Эти методы позволяют захватывать и освобождать разрешения (permits) семафора. Параметр permits указывает количество разрешений, которые необходимо захватить или освободить.

Некоторые формы метода `acquire()` включают:
- `acquire()`: блокирует текущий поток до тех пор, пока не будет доступно хотя бы одно разрешение для захвата.
- `acquireUninterruptibly()`: блокирует текущий поток, игнорируя прерывания, до тех пор, пока не будет доступно хотя бы одно разрешение для захвата.
- `tryAcquire()`: пытается захватить разрешение, но не блокирует поток. Если разрешение доступно, метод возвращает `true`, в противном случае возвращает `false`.

Аналогично, методы `release()` используются для освобождения разрешений:
- `release()`: освобождает одно разрешение.
- `release(int permits)`: освобождает указанное количество разрешений.

Класс `Semaphore` также предоставляет методы для получения информации о состоянии семафора:
- `availablePermits()`: возвращает количество доступных разрешений, которые можно немедленно захватить.
- `getQueueLength()`: возвращает количество потоков, ожидающих освобождения разрешений.

**В конструкторе класса `Semaphore` можно указать начальное количество разрешений и настроить свойство fair для определения порядка очереди потоков на захват разрешений.**

**Справка по `fair` свойству:**
	Когда свойство `fair` установлено в `true`, это означает, что блокировки будут выдаваться потокам в порядке их запроса, то есть в порядке, в котором потоки вызывают метод `lock()`. Это обеспечивает справедливость в распределении блокировок между потоками. Поток, который первый запросил блокировку, первым её и получит.
	Когда свойство `fair` установлено в `false` (по умолчанию), блокировки выдаются потокам без учета порядка запросов, что может привести к более высокой производительности за счет снижения накладных расходов на управление блокировками. В этом режиме потоки могут захватывать блокировки в произвольном порядке, а не по порядку запросов.
#### 9. Что обозначает ключевое слово volatile? Почему операции над volatile переменными не атомарны? 
![[Pasted image 20240405115914.png]]
Ключевое слово `volatile` в Java применяется к переменным и используется для указания компилятору и среде выполнения на то, что значение этой переменной может быть изменено несколькими потоками, и что изменения переменной должны быть видны всем потокам без кэширования её значения.

Проблемы, которые решает `volatile`:
1. **В процессе работы многопоточного приложения разные потоки могут кэшировать значения переменных. Возможна ситуация, когда один поток изменил значение переменной, а второй НЕ увидел этого изменения, потому что работал со своей, кэшированной копией переменной.**
2. В Java операции чтения и записи long и double, как и любого другого примитивного типа, являются атомарными на всех платформах, включая 64-битные системы. Это означает, что на 64-битных системах операции чтения и записи long и double в любом случае будут атомарными. Однако стоит отметить, что на некоторых 32-битных платформах чтение и запись 64-битных значений может быть атомарными только при использовании определенных инструкций процессора или при использовании специальных средств синхронизации, предоставляемых в Java, таких как ключевое слово `volatile`, атомарные классы из пакета `java.util.concurrent`, или синхронизация с помощью блокировок.
>[!TIP]
>long и double — самые «тяжеловесные» примитивы в Java: они весят по 64 бита. И в некоторых 32-битных платформах просто не реализована атомарность чтения и записи 64-битных переменных. 
>Такие переменные читаются и записываются в две операции. Сначала в переменную записываются первые 32 бита, потом еще 32. Соответственно, в этих случаях может возникнуть проблема. 
>Один поток записывает какое-то 64-битное значение в переменную Х, и делает он это «в два захода». В то же время второй поток пытается прочитать значение этой переменной, причем делает это как раз посередине, когда первые 32 бита уже записаны, а вторые — еще нет. В результате он читает промежуточное, некорректное значение, и получается ошибка.

##### Если мы объявляем в программе какую-то переменную, со словом volatile, это означает:
1. Гарантирует, что любые изменения этой переменной, сделанные одним потоком, будут немедленно видны всем другим потокам. Однако операции чтения и записи `volatile` переменных не являются атомарными, что означает, что они могут быть разделены между несколькими операциями в потоке или между операциями в другом потоке."
    
2. **Использование кэша**: Когда переменная объявлена с ключевым словом `volatile`, ее значение не будет кэшироваться в локальных кэшах потоков. Это означает, что каждое обращение к переменной будет осуществляться непосредственно из памяти(heap). Это предотвращает ситуацию, когда разные потоки могут работать с разными локальными копиями переменной.

Использование ключевого слова `volatile` подходит для случаев, когда переменная используется несколькими потоками, но только один поток изменяет ее значение, а другие потоки только читают это значение. Это обеспечивает безопасное чтение значения переменной из разных потоков без необходимости явной синхронизации. **Однако следует помнить, что `volatile` не обеспечивает атомарности операций, которые используют несколько инструкций, таких как инкремент или декремент, и для таких операций может потребоваться дополнительная синхронизация.****
**
#### Почему операции над volatile переменными не атомарны? 
Операции над `volatile` переменными не гарантируют атомарность из-за того, что атомарность и видимость — это два разных аспекта многопоточной безопасности.

Когда переменная объявлена как `volatile`, это гарантирует ее видимость между потоками. Это означает, что если один поток записал значение в `volatile` переменную, то другие потоки увидят это изменение, а не используют кэшированное значение.

Однако, это не гарантирует, что операции чтения и записи к этой переменной будут атомарными. Атомарность означает, что операция выполняется как единое целое и не может быть прервана другими потоками посередине выполнения. Для обеспечения атомарности операций над переменными, в Java используются блокировки или атомарные типы данных из пакета `java.util.concurrent.atomic`.
#### 10. Расскажи про правила «happens-before» и Java Memory Model (JMM). 
#### JMM
**Java Memory Model (JMM) - это спецификация, которая определяет, как виртуальная машина Java взаимодействует с памятью в многопоточных программах. JMM описывает правила для доступа к переменным из разных потоков и определяет, какие гарантии предоставляются для порядка чтения и записи операций.**

Одной из ключевых концепций в JMM является гарантия happens-before. **Эта гарантия определяет отношение порядка между операциями чтения и записи в многопоточной среде. Гарантия happens-before обеспечивает, что если одна операция happens-before другой, то все действия, произведенные перед первой операцией, будут видны после выполнения второй операции. Это обеспечивает консистентность и предсказуемость поведения многопоточных программ.**

Таким образом, JMM определяет правила для обеспечения правильной синхронизации доступа к переменным в многопоточной среде и гарантирует, что операции чтения и записи происходят в определенном порядке, что способствует предсказуемому и корректному выполнению программы.
##### Happens-before Guarantee
**Гарантия "happens-before" в Java представляет собой набор правил, определяющих, как виртуальная машина Java и центральный процессор (CPU) могут переупорядочивать инструкции для повышения производительности.** Гарантия "happens-before" позволяет потокам опираться на то, когда значение переменной синхронизируется с главной памятью (main memory), и какие другие переменные были синхронизированы в то же время. Правила гарантии "happens-before" в Java сосредоточены вокруг доступа к волатильным переменным и переменным, к которым происходит доступ из синхронизированных блоков.
![[Pasted image 20240408172836.png]]

>[!INFO] Тонкости работы: [[Happens-before Guarantee]]
##### Можно выделить несколько основных аспектов, относящихся к модели памяти в Java:
**Синхронизация (Synchronized)**
При входе в synchronized метод или блок поток обновляет содержимое локальной памяти, а при выходе из synchronized метода или блока поток записывает изменения, сделанные в локальной памяти, в главную. Такое поведение synchronized методов и блоков следует из правил для отношения «happens-before».

**Видимость (Visibility)**
Один поток может временно сохранить значения полей в своих локальных регистрах или кэше процессора, избегая доступа к основной памяти. Это может привести к ситуации, когда другой поток не видит последних изменений полей. Ключевые слова, такие как synchronized, volatile и final, управляют видимостью данных для потоков.

**Волатильность, изменчивость (Volatile)**
Запись volatile-переменных производится в основную память, минуя локальную. Чтение volatile переменной также производится из основной памяти, то есть значение переменной не может сохраняться в регистрах или локальной памяти потока, и операция чтения этой переменной гарантированно вернет последнее записанное в нее значение.

**Финализация (Final)**
После того как объект был корректно создан, любой поток может видеть значения его final полей без дополнительной синхронизации. "Корректно создан" означает, что ссылка на создающийся объект не должна использоваться до тех пор, пока не завершился конструктор объекта. Рекомендуется инициализировать final поля объекта только внутри конструктора, в противном случае поведение не специфицировано.

**Переупорядочивание (Reordering)**
Для повышения производительности, процессор или компилятор могут переупорядочивать инструкции в программе. Это может привести к ситуации, когда поток видит результаты операций в другом порядке, чем они были выполнены. Правила «happens-before» и ключевое слово volatile регулируют такое поведение, обеспечивая согласованность и непротиворечивость данных между потоками.
Также регулируется набором правил «happens-before»: операции чтения и записи volatile переменных не могут быть переупорядочены с операциями чтения и записи других volatile и не-volatile переменных.
#### 11. Для чего нужны Atomic типы данных? Чем отличаются от volatile? 
**Atomic** – семейство классов из java.util.concurrent. Они предоставляют набор атомарных операций для соответствующих типов.
Atomic типы данных в Java предоставляют атомарные операции чтения и записи для примитивных типов данных. **Эти типы данных гарантируют, что операции чтения и записи к ним происходят неделимо, то есть не могут быть прерваны или перехвачены другим потоком посередине.**

Например, с помощью методов getAndIncrement и incrementAndGet класса AtomicInteger можно делать **ЦЕЛОСТНЫМ**(атомарным) неатомарный в обычных условиях инкремент.
##### **Условно можно разделить подходы реализации большинства atomic-методов на две группы: compare-and-set и get-and-set 
Методы категории compare-and-set принимают старое значение и новое. Если переданное старое значение совпало с текущим, устанавливается новое.** 

Обычно делегируют вызов в методы класса Unsafe, которые заменяются нативными реализациями виртуальной машины. Виртуальная машина в большинстве случаев использует атомарную операцию процессора compare-and-swap (CAS). 
Поэтому атомики обычно более эффективны чем стандартная дорогостоящая блокировка. Все операции, которые нужны, происходят атомарно. 

**Оба подхода обеспечивают атомарность и предотвращают проблемы согласованности данных в многопоточной среде. Однако они используются в разных сценариях в зависимости от требований к вашему коду. CAS обычно используется, когда вам нужно обновить значение на основе его текущего состояния, в то время как get-and-set используется, когда вам просто нужно заменить значение и возможно использовать старое значение для дальнейшей обработки.**
###### Unsafe
Класс `Unsafe` в Java - это предопределенный класс, который предоставляет низкоуровневые, не безопасные операции. Он позволяет программистам напрямую работать с памятью и выполнять другие “небезопасные” операции, которые обычно не доступны в высокоуровневых языках программирования, таких как Java.

##### Get-and-set 
Подход **get-and-set**  с использованием **оптимистической блокировки** или **double-checked locking** действительно используется в многопоточном программировании для обеспечения безопасности данных при минимальном использовании блокировок.
**Get-and-set**: Этот подход используется в методах, таких как `getAndSet(newValue)`. Этот метод устанавливает новое значение и возвращает старое значение. Это также делается как одна атомарная операция, что делает его безопасным для использования в многопоточной среде. Это означает, что если два потока пытаются выполнить get-and-set операцию на одной и той же переменной одновременно, один из потоков будет должен дождаться завершения операции другого потока, прежде чем сможет выполнить свою операцию. Это обеспечивает согласованность данных и предотвращает состояния гонки.
###### Подход **get-and-set** может быть полезен во многих ситуациях, особенно в многопоточных приложениях. Вот несколько примеров:
1. **Синхронизация потоков**: Get-and-set может использоваться для синхронизации потоков в многопоточном приложении. Например, если потоки обновляют общую переменную и вам нужно знать, какое значение было до обновления, вы можете использовать get-and-set.
    
2. **Обнаружение изменений**: Get-and-set также может быть полезен, если вам нужно обнаружить, было ли значение изменено другим потоком. Вы можете сравнить старое значение (возвращаемое get-and-set) с текущим значением, чтобы узнать, было ли оно изменено.
    
3. **Атомарные операции**: Get-and-set гарантирует, что чтение и запись значения являются атомарной операцией, то есть они выполняются как единая неделимая операция. Это может быть критически важно в многопоточных приложениях, где необходимо обеспечить целостность данных.

##### Справка по CAS:
В Java используется операция **Compare-And-Set (CAS)**, которая очень похожа на Compare-And-Swap, но имеет некоторые отличия.

Вот как это работает:
1. **Сравнение (Compare)**: CAS сначала сравнивает текущее значение переменной с ожидаемым значением.
2. **Установка (Set)**: Если текущее значение совпадает с ожидаемым, CAS устанавливает новое значение. Если текущее значение не совпадает с ожидаемым, CAS не делает ничего.

Однако, в отличие от Compare-And-Swap, операция Compare-And-Set в Java возвращает булево значение, указывающее, была ли операция успешной. Если текущее значение совпадает с ожидаемым, CAS устанавливает новое значение и возвращает `true`. Если текущее значение не совпадает с ожидаемым, CAS не делает ничего и возвращает `false`.

Это позволяет потоку, выполняющему операцию CAS, узнать, была ли операция успешной, и, если нет, повторить ее или предпринять другие действия. Это особенно полезно в неблокирующих алгоритмах и структурах данных, где потоки могут конкурировать за доступ к общим ресурсам.

Так что, когда мы говорим о `CopyOnWriteArrayList` и других подобных структурах данных в Java, мы обычно имеем в виду операцию Compare-And-Set.

Таким образом, CAS обеспечивает безопасность потоков, позволяя только одному потоку вносить изменения в переменную за раз. Это предотвращает проблемы согласованности данных, которые могут возникнуть при одновременном доступе к переменной из нескольких потоков.
    - В контексте процессоров, операция CAS обычно представляет собой инструкцию, которая выполняется непосредственно на уровне процессора.
    - В контексте языков программирования, таких как Java, операции CAS могут быть реализованы с использованием соответствующих низкоуровневых механизмов, таких как класс `Unsafe`.
    https://jenkov.com/tutorials/java-concurrency/compare-and-swap.html

##### Семейство Atomics:
**AtomicBoolean, AtomicInteger и AtomicLong:**
- Операции с этими классами выполняются быстрее, чем при использовании синхронизации через synchronized или volatile.
- Предоставляют методы для атомарного добавления заданной величины, а также для инкремента и декремента.

**AtomicIntegerArray и AtomicLongArray** - классы для работы с массивами.

**AtomicReference** - класс для выполнения атомарных операций с ссылками на объекты.

**AtomicMarkableReference** - класс для атомарных операций с парами полей: ссылка на объект и битовый флаг true/false.

**AtomicStampedReference** - класс для атомарных операций с парами полей: ссылка на объект и целочисленное значение.

**AtomicReferenceArray** - массив ссылок на объекты, который может обновляться атомарно.
#### 12. Что такое потоки демоны? Для чего они нужны? Как создать поток-демон? 
В Java процесс завершается тогда, когда завершаются все его основные и дочерние потоки.
**Потоки-демоны** — это низкоприоритетные потоки, работающие в фоновом режиме для выполнения таких задач, как сбор «мусора» (освобождают память неиспользованных объектов и очищают кэш). 

**Большинство потоков JVM (Java Virtual Machine) являются потоками-демонами.** 

**Потоки не-демоны называются пользовательскими (user thread)**

**Свойства потоков-демонов:** 
- Не влияют на закрытие JVM, когда все пользовательские потоки завершили свое исполнение; 
- JVM сама закрывается, когда все пользовательские потоки перестают выполняться;
- Если JVM обнаружит работающий поток-демон, она завершит его, после чего закроется. JVM не учитывает, работает поток или нет. 

Чтобы установить, является ли поток демоном, используется метод `boolean isDaemon()`. Если да, то он возвращает значение `true`, если нет, то — то значение `false`. Daemon потоки предназначены для выполнение фоновых задач и оказания различных сервисов user потокам. При завершении работы последнего user потока программа завершает своё выполнение, не дожидаясь окончания Daemon потоков. 

Как правило, потоки-демоны создаются с помощью метода `setDaemon(true)` перед запуском потока. Если мы запустили поток и только потом создаём поток-демон, то будет выброшено исключение `IllegalThreadStateException`.
Важно помнить, что потоки-демоны не должны выполнять критически важные операции или работать с ресурсами, которые могут быть использованы другими потоками, так как их выполнение может быть прервано в любой момент без предупреждения.

Daemon thread может быть полезен для таких действий, как инвалидация кэша, периодическая актуализация значений из внешних источников, освобождение неиспользуемых пользовательских ресурсов.

#### 13. Что такое приоритет потока? На что он влияет? Какой приоритет у потоков по умолчанию? 
Каждому потоку исполнения в Java присваивается свой приоритет, который определяет поведение данного потока по отношению к другим потокам. 

Приоритеты потоков исполнения задаются целыми числами (обычно от 1 до 10), определяющими относительный приоритет одного потока над другими. 

Приоритет потока исполнения используется для принятия решения при переходе от одного потока исполнения к другому. Это так называемое переключение контекста. Задается с помощью метода `public final void setPriority(int newPriority)`. **По умолчанию приоритет потока = 5.**

Существуют следующие константы для определения приоритета потока: 
- Thread.MIN_PRIORITY (1) 
- Thread.NORM_PRIORITY (5) 
- Thread.MAX_PRIORITY (10)

НЕ полагайтесь на приоритет потоков при проектировании многопоточных приложений! Скорее всего планировщик потоков будет использовать приоритеты при выборе следующего потока на выполнение, но это НЕ гарантируется.

Приоритеты потоков в Java предоставляют только подсказку планировщику о том, какой поток следует отдать предпочтение при выборе следующего потока для выполнения. Однако фактический порядок выполнения потоков может быть различным в разных реализациях JVM и на разных операционных системах.
#### 14. Как работает Thread.join()? Для чего он нужен? 
Если в основном потоке нужно дождаться завершения задач – после `start()`, вызывается метод `thread.join()` (присоединиться). Исполнение зависнет на вызове этого метода до тех пор, пока тред не закончит свою задачу и не умрет.

Одна нить может вызывать метод `join()` у объекта второй нити. В результате первая нить (которая вызвала метод) приостанавливает свою работу до окончания работы второй нити (у объекта которой был вызван метод).

Метод можно использовать с параметрами, принимает миллисекунды. Тогда поток, в котором вызван метод `join()` (здесь в `main` потоке), будет ждать пока тред (`thread.join`) не завершит свою работу или не пройдёт установленный период. Какое из этих событий случится первым, то и подстегнёт поток `main` продолжить свою работу.
##### Пояснение про нить и объект нити:
1. **Нить (Thread)**: Это отдельный процесс выполнения команд. В Java потоки представлены классом `Thread`. Когда вы создаете объект типа `Thread` и вызываете его метод `start()`, создается новая нить, которая начинает выполнение своего кода в методе `run()`.
    
2. **Объект нити (Thread object)**: Это сам объект, который представляет нить выполнения. Объекты нити создаются с помощью конструктора класса `Thread`, и каждый такой объект имеет свои собственные свойства и методы, такие как приоритет, состояние и методы для управления выполнением нити.

Таким образом, **нить (Thread)** является абстракцией процесса выполнения, в то время как **объект нити (Thread object)** - это конкретный объект в Java, представляющий эту нить выполнения.
```java
JoinThread thread1 = new JoinThread();  
thread1.start(); // Запуск потока thread1  
  
Thread thread2 = new Thread(() -> {  
	try {  
		thread1.join(); // Поток thread2 будет ждать завершения потока thread1  
	} catch (InterruptedException e) {  
		e.printStackTrace();  
	}  
	System.out.println("Поток thread2 завершил работу");  
});  
System.out.println("Поток thread2 начал работу");  
thread2.start(); // Запуск потока thread2
```
Вывод в консоль:
- Поток JoinThread начал работу
- Поток thread2 начал работу
- Поток JoinThread завершил работу
- Поток thread2 завершил работу
#### 15. Чем отличаются методы yield() и sleep()? 
Короткий ответ: 
- `sleep(500)` – текущая нить «засыпает», то есть приостанавливает свою работу на 500 миллисекунд – 0.5 секунды 
- `yield()` – текущая нить «пропускает свой ход». Из состояния running переходит в состояние ready, а Java-машина приступает к выполнению следующей нити.

1. **`sleep()`:**
    - Метод `sleep()` используется для приостановки выполнения текущего потока на заданный промежуток времени. При вызове `sleep()` поток переходит в состояние "спящего", и его выполнение приостанавливается на указанное количество миллисекунд.
    - Основное назначение `sleep()` состоит в том, чтобы приостановить выполнение потока на определенный промежуток времени, например, для синхронизации или для реализации временных задержек.

2.  **`yield()`:**
    - Метод `yield()` используется для предоставления другим потокам с более высоким приоритетом возможности выполнения. Он сообщает планировщику потоков, что текущий поток готов уступить свое место другим потокам, которые могут иметь более высокий приоритет. Однако, нет гарантии, что после вызова `yield()` произойдет переключение контекста на другой поток, так как это зависит от реализации планировщика потоков в конкретной виртуальной машине Java.
    - Использование `yield()` полезно, когда вы хотите предоставить возможность выполнения другим потокам, но не хотите блокировать текущий поток на определенное время.

>**Таким образом, основное различие между `yield()` и `sleep()` заключается в их целях: `yield()` уступает время выполнения другим потокам, а `sleep()` приостанавливает выполнение текущего потока на заданное время.**
#### 16. Как правильно остановить поток? Для чего нужны методы .stop(), .interrupt(), .interrupted(), .isInterrupted(). 
Метод `stop()` прерывает поток грубо, в неоконченном состоянии. Метод считается устаревшим. Если хотим прервать поток, то должны позаботиться об исключении, чтобы вовремя узнать о непредвиденной ситуации.

Есть возможность послать сигнал потоку, что мы хотим его прервать `interrupt()`. Есть возможность в самом потоке проверить, хотят ли его прервать `isInterrupted()`. Если проверка показала, что поток хотят прервать, программист должен сам решать, что делать дальше. Фактическое прерывание потока зависит от его реализации. В некоторых случаях поток может продолжать выполнение, игнорируя флаг прерывания.

**Метод `interrupt`** 
В классе Thread существует переменная `interrupted` и метод остановки `interrupt()`. Никто не гарантирует, что нить можно остановить. Она может остановиться только сама.
##### Подробнее про `interrupt()`
Если поток находится в состоянии ожидания или сна (то есть был вызван метод `wait()` или `sleep()`), и на этот поток вызывается метод `interrupt()`, то поток выходит из состояния ожидания или сна, выбрасывая `InterruptedException`.

Если поток не находится в состоянии ожидания или сна, вызов метода `interrupt()` приводит к нормальному поведению и не прерывает поток, но устанавливает флаг прерывания в `true`.

Вы можете определить, был ли поток прерван, с помощью метода `isInterrupted()`, который возвращает флаг прерывания. Если этот флаг установлен в `true`, это означает, что поток был прерван. Есть еще один метод `interrupted()`, который также возвращает флаг прерывания, но в отличие от `isInterrupted()`, он сбрасывает флаг прерывания(то есть устанавливает в `false`).

Метод `interrupt()` не прерывает поток немедленно, потому что Java использует кооперативное прерывание. Это означает, что поток, который был прерван, сам решает, как и когда ответить на прерывание. Это дает больше контроля над тем, как поток должен быть остановлен, и позволяет потоку корректно завершить свою работу перед остановкой.

Прерывание потоков важно в многопоточных приложениях, где один поток может нуждаться в остановке другого потока. Например, если поток выполняет какую-то долгую операцию, и вы хотите иметь возможность остановить эту операцию по запросу пользователя, вы можете использовать прерывание для этого. Прерывание также полезно, когда один поток ожидает завершения другого потока с помощью метода `join()`, и вы хотите иметь возможность прервать ожидание.

#### 17. Чем Runnable отличается от Callable? 
Коротко: Метод `Runnable.run()` не возвращает никакого значения, `Callable.call()` возвращает объект `Future`, который может содержать результат вычислений; Метод `run()` не может выбрасывать проверяемые исключения, в то время как метод `call()` может.
![[Pasted image 20240405124625.png]]
**Метод `submit()`**:
- Метод `submit()` принимает задачу на выполнение и возвращает объект типа `Future`.
- Задача может быть представлена как объект типа `Runnable` (без возвращаемого значения) или `Callable` (возвращающий значение).
- Если задача представлена объектом типа `Callable`, то `submit()` возвращает объект `Future`, который позволяет получить результат выполнения задачи или обработать исключение, если оно произошло.
- Если задача представлена объектом типа `Runnable`, `submit()` также возвращает объект `Future`, но без возможности получения результата выполнения задачи (так как `Runnable` не возвращает результат).

**Метод `execute()`**:
- Метод `execute()` принимает задачу на выполнение без возвращаемого значения.
- Задача представлена объектом типа `Runnable`.
- `execute()` не возвращает никакого результата выполнения задачи и не предоставляет механизм для отслеживания или получения результата.
#### 18. Что такое FutureTask? 
**FutureTask используется для представления результата асинхронных вычислений. Он предоставляет методы для проверки, завершены ли вычисления, для получения результата вычислений, для отмены задачи и т.д.**

Класс `FutureTask` в Java представляет собой реализацию интерфейса `Future` и предоставляет возможность выполнять вычисления в фоновом режиме и ожидать результаты. Он часто используется в многопоточном программировании, когда вам нужно выполнить некоторую задачу в фоновом потоке и получить результат в будущем.

**Результат может быть получен только когда вычисление завершено, метод получения get() блокирует вызывающий поток, если вычисление ещё не завершено.** 

`get()` может выбросить исключение `InterruptedException`, если текущий поток был прерван во время ожидания, или `ExecutionException`, если задача завершилась с ошибкой.

Объекты FutureTask могут быть использованы для обёртки объектов Callable и Runnable. Так как FutureTask помимо Future реализует Runnable, его можно передать в Executor на выполнение.

Важно отметить, что `FutureTask` - это одноразовый объект, который не может быть повторно использован для новой задачи. Если вам нужно выполнить новую задачу, вам нужно создать новый объект `FutureTask`.

Метод submit() передаёт задание (task) в пул потоков для выполнения одним из потоков и возвращает тип Future, в котором и хранится результат выполнения задания. Метод get() позволяет получить результат из объекта Future.
##### Основные методы класса `Future`:
- `boolean isDone()`: Возвращает `true`, если задача была завершена.
- `boolean cancel(boolean mayInterruptIfRunning)`: Отменяет выполнение этой задачи.
- `V get()`: Возвращает результат вычислений.
- `V get(long timeout, TimeUnit unit)`: Возвращает результат вычислений, ждет, если необходимо, не более заданного времени
#### 19. Что такое deadlock? 
**Deadlock – это ситуация в многопоточном программировании, когда два или более потока залочены навсегда, ожидают друг друга и ничего не делают.** 
**Такая ситуация обычно возникает, когда несколько потоков используют синхронизацию на нескольких объектах не в одинаковом порядке.**

Оба процесса удерживают один ресурс и ждут другого ресурса, удерживаемого другим процессом. Это тупиковая ситуация, поскольку ни процесс 1, ни процесс 2 не могут двигаться вперед, пока один из процессов не откажется от своего ресурса.

**Как решить проблему?** Синхронизироваться в одинаковом порядке для разных методов.
 
**Взаимная блокировка (deadlock) - явление, при котором все потоки находятся в режиме ожидания и своё состояние не меняют.** 
##### 4 условия, которые должны выполняться одновременно для возникновения deadlock:
1. **Взаимное исключение (Mutual Exclusion)**: Каждый ресурс либо находится в состоянии свободного использования, либо занят одним процессом и не может быть использован другим процессом.
2. **Удержание и ожидание (Hold and Wait)**: Процесс, удерживающий хотя бы один ресурс, может ожидать дополнительных ресурсов, которые в настоящее время заняты другими процессами.
3. **Нет отзыва (No Preemption)**: Ресурсы не могут быть принудительно изъяты из процесса. Они должны быть освобождены процессом после его завершения.
4. **Циклическое ожидание (Circular Wait)**: Существует набор процессов {P1, P2, …, Pn}, где P1 ожидает ресурс, который удерживается P2, P2 ожидает ресурс, который удерживается P3, и так далее, до Pn, который ожидает ресурс, удерживаемый P1.

**Простейший способ избежать взаимной блокировки – не допускать цикличного ожидания. Этого можно достичь, получая мониторы разделяемых ресурсов в определенном порядке и освобождая их в обратном порядке.**

На примере кода ниже:
1. **Взаимное исключение**: `lock1` и `lock2` являются ресурсами, которые могут быть заняты только одним потоком в определенный момент времени.
2. **Удержание и ожидание**: Каждый из потоков удерживает один замок и ожидает освобождения другого замка.
3. **Нет отзыва**: Замки не могут быть принудительно изъяты из потока. Они должны быть освобождены потоком после его завершения.
4. **Циклическое ожидание**: `firstThread` ожидает `lock2`, который удерживается `secondThread`, и `secondThread` ожидает `lock1`, который удерживается `firstThread`.

```java
public void firstThread() {  
    Random random = new Random();  
  
    for (int i =0; i<10000; i++) {  
        lock1.lock();
        //здесь и возникает deadlock. thread1 ждет освобождение монитора lock2
        lock2.lock(); 
        try {  
            Account.transfer(acc1, acc2, random.nextInt(100));  
        } finally {  
            lock2.unlock();  
            lock1.unlock();  
        }  
    }
}

public void secondThread() {  
    Random random = new Random();  
  
    for (int i =0; i<10000; i++) {  
        lock2.lock();
        //здесь и возникает deadlock. thread2 ждет освобождение монитора lock1
        lock1.lock(); 
        try {  
            Account.transfer(acc2, acc1, random.nextInt(100));  
        } finally {  
            lock1.unlock();  
            lock2.unlock();  
        }  
    }
}
```

#### 20. Что такое livelock? 
**Livelock** - это ситуация, когда потоки постоянно реагируют на действия друг друга, что приводит к тому, что они не могут продолжить свою работу. Это схоже с deadlock, но в отличие от него, потоки не блокируются, они просто слишком заняты взаимодействием друг с другом, чтобы продолжить выполнение своих задач.

В ситуации livelock, каждый поток считает, что другой поток активен, и поэтому передает ему управление, ожидая, что другой поток продолжит работу. Но поскольку оба потока действуют одинаково, они продолжают передавать управление друг другу, не выполняя при этом никакой полезной работы. Это и есть основная причина возникновения livelock.

В реальной жизни примером livelock может быть ситуация, когда два человека сталкиваются в узком коридоре и оба пытаются уступить дорогу друг другу, избегая столкновения. В результате они могут зациклиться, двигаясь из стороны в сторону, но не продвигаясь вперед.

Livelock, так же как и deadlock, являются проблемами, которые следует избегать при разработке многопоточных приложений.
![[Pasted image 20240413162142.png]]
#### 21. Что такое lock starvation?
**Это ситуация, когда менее приоритетные потоки ждут долгое время для того, чтобы могли запуститься.**

**Lock starvation (голодание блокировки)** - это ситуация, когда один или несколько потоков постоянно ожидают доступа к блокировке из-за длительного пребывания других потоков внутри критической секции.

Это может произойти, например, когда потоки с низким приоритетом постоянно уступают блокировку потокам с более высоким приоритетом. Как результат, низкоприоритетные потоки ожидают доступа к ресурсам, что может привести к замедлению или даже остановке их работы.

Lock starvation может также происходить из-за несправедливого распределения ресурсов или из-за неправильной реализации механизмов блокировки.

Для предотвращения голодания блокировки важно соблюдать принцип справедливости при распределении ресурсов между потоками и правильно управлять приоритетами потоков. Также необходимо использовать альтернативные подходы к синхронизации, такие как семафоры или условные переменные, чтобы избежать ситуаций, когда потоки долго ожидают доступа к ресурсам.

#### 21. Что такое race condition? 
**Race condition (гонка состояний)** - это ситуация, которая возникает в многопоточном программировании, когда результат выполнения программы зависит от того, в каком порядке выполняются операции в различных потоках.

Состояние гонки возникает, когда поток, который должен исполнится в начале, проиграл гонку и первым исполняется другой поток: поведение кода изменяется, из-за чего возникают недетерминированные (неопределённые) ошибки.

DataRace – это свойство выполнения программы. Согласно JMM, выполнение считается содержащим гонку данных, если оно содержит по крайней мере два конфликтующих доступа (чтение или запись в одну и ту же переменную), которые не упорядочены отношениями «happens before».

**Самый простой способ решения — копирование переменной в локальную переменную. Или просто синхронизация потоков методами и sync-блоками**.
#### 22. Что такое Фреймворк fork/join? Для чего он нужен? 
**Фреймворк Fork/Join** был введен в Java 7 и представляет собой реализацию интерфейса ExecutorService, которая помогает использовать все доступные процессорные ядра для ускорения параллельной обработки.

**Основная идея фреймворка Fork/Join заключается в применении подхода “разделяй и властвуй”.** Фреймворк сначала “разделяет” (forks) задачу на меньшие независимые подзадачи до тех пор, пока они не станут достаточно простыми для асинхронного выполнения. Затем начинается этап “объединения” (joins), когда результаты всех подзадач рекурсивно объединяются в один общий результат.

Для эффективного параллельного выполнения фреймворк Fork/Join использует пул потоков, называемый ForkJoinPool. Этот пул управляет рабочими потоками и использует алгоритм **“похищения работы” (work-stealing), который позволяет свободным потокам “похищать” задачи у занятых потоков.**
![[Pasted image 20240409202611.png]]
#### 23. Что означает ключевое слово synchronized? Где и для чего может использоваться? 
Когда одна нить заходит внутрь блока кода, помеченного словом synchronized, то Java машина тут же блокирует мьютекс(монитор) у объекта, который указан в круглых скобках после слова synchronized.

Больше ни ода нить не сможет зайти в этот блок, пока наша нить его не покинет. Как только наша нить выйдет из блока, помеченного synchronized, то мьютекс тут же автоматически разблокируется и будет свободен для захвата другой нитью.

**Ключевым словом synchronized может быть помечен как блок кода, так и метод. Позволяет добиваться синхронизации в помеченных им методах или блоках кода. Блокировка происходит по ОБЪЕКТУ!**

**Ключевое слово synchronized** можно применять как модификатор метода, и как самостоятельный оператор с блоком кода. Выполняет код при захваченном мониторе объекта. В виде оператора объект указывается явно. В виде модификатора нестатического метода используется this, статического – .class текущего класса. 

Один из основных инструментов обеспечения потокобезопасности. Одновременно выполняется не более одного блока synchronized на одном и том же объекте. Такая блокировка называется intrinsic lock или monitor lock.
Блок synchronized также необходим для использования методов wait, notify, notifyAll.

Снятие блокировки производится автоматически при выходе из блока.

#### 24. Что является монитором у статического синхронизированного класса? 
**Объект типа Class, соответствующий классу, в котором определен метод.**

Для синхронизации статических методов используется один монитор для одного класса. Каждый загруженный в Java класс имеет соответствующий объект класса Class, представляющий этот класс. Монитор именно этого объекта используется для синхронизации статических методов (если они синхронизированы). Таким образом, монитором у статического синхронизированного класса в Java является объект класса Class, представляющий этот класс.

#### 25. Что является монитором у не статического синхронизированного класса? 
Объект this

#### 26. Способы управления потоками java.util.сoncurrent 
Возможности классов этого пакета обеспечивают высокую производительность, масштабируемость и построение потокобезопасных блоков. 
Почти все коллекции, с которыми мы работали, не являются потокобезопасными. Исключения составляют устаревшие классы: Vector, Stack и HashTable. 

Синхронизированные коллекции получаются из обычных коллекций благодаря обертке. Эти коллекции достигают потокобезопасности **за счет использования блокировок через synchronized блоки для всех методов**. Это означает, что если несколько потоков попытаются добавить или удалить элементы из ArrayList, доступ к коллекции будет осуществляться через один поток. То есть первый поток заходит, устанавливает блокировку (lock), выполняет свою работу, и только после завершения работы разблокирует доступ для второго потока и так далее. 
**Эта операция является дорогостоящей, и производительность таких коллекций при многопоточности низкая.** 
Чтобы предотвратить возникновение исключения ConcurrentModificationException, необходимо полностью блокировать коллекцию на время ее перебора.
```java
List<Integer> integerList = new ArrayList<>();  
List<Integer> syncList = Collections.synchronizedList(integerList);
```

Специально для работы в условиях многопоточности были созданы Concurrent collections: усовершенствован вызов утилит синхронизации, добавлены классы семафоров и блокировок и т.д.

Atomics – набор потокобезопасных переменных и массивов.

Механизм управления заданиями, основанный на интерфейсе Executor:
1. Организация запуска пула потоков: ThreadPoolExecutor
2. Эффективная реализация пула ExecutorService – ForkJoinPool
3. Службы планирования: ScheduledThreadPoolExecutor

Параллельные аналоги классов-коллекций:
1. **Блокирующие очереди BlockingQueue и BlockingDeque, гарантирующие остановку потока если нет элемента или нет места для вставки.**
2. Класс Exchanger позволяет двум потокам обмениваться объектами.
3. Классы CopyOnArrayList и CopyOnWriteArraySet, копирующие своё содержимое при попытке его изменения, причём ранее полученный итератор будет корректно продолжать работать с исходным набором данных.
4. ConcurrentHashMap, ConcurrentLinkedQueue – эффективные аналоги HashTable и LinkedList.

Классы – барьеры синхронизации (Synchronizers):
- CountDownLatch – заставляет потоки ожидать завершения заданного числа операций, по окончании чего все ожидающие потоки освобождаются.
- Semaphore – предлагают потоку ожидать завершения действий в других потоках.
- CyclicBarrier – предлагает нескольким потокам ожидать момента, когда они все достигнут какой-либо точки, после чего барьер снимается.
- Phaser – улучшенная реализация барьера для синхронизации потоков, совмещает в себе функционал CyclicBarrier и CountDownLatch. Количество потоков может динамически изменяться. Класс может пере-использоваться.

Неблокирующие коллекции:
- ConcurrentLinkedQueue (LinkedList)
- ConcurrentLinkedDeque (ArrayDeque)
- CopyOnWriteArrayList (ArrayList)
- CopyOnWriteArraySet (HashSet)
- ConcurrentHashMap (HashMap)
- ConcurrentScipListMap (TreeMap)
- ConcurrentScipListSet (TreeSet)

Принципы:
1. Простые операции атомарны
2. Пакетные операции (addAll, removeAll) могут быть не атомарны!
3. Как правило, длина не хранится (isEmpty() !)
4. Не кидает ConcurrentModificationException
#### 27. Расскажи про устройство и алгоритм работы ConcurrentHashMap 
Структура ConcurrentHashMap включает в себя массив узлов(Node[]), которые служат бакетами таблицы. Эти бакеты инициализируются лениво, при первой вставке. Операции чтения обычно не блокируются, так что они могут перекрываться с операциями обновления (включая put и remove).

Например, есть два потока, работающие с HashMap. Оба потока блокируют коллекцию целиком и это делает ее неэффективной. Эту проблему и решает **ConcurrentHashMap**.
ConcurrentHashMap работает иначе, чем, HashMap, поскольку ConcurrentHashMap получает блокировку для каждого бакета отдельно.

Это означает, что вместо блокировки всей карты он имеет несколько блокировок на уровне бакетов. **Таким образом, два потока, работающие с разными бакетами, могут получить блокировку этих бакетов, не мешая друг другу, и могут работать одновременно, поскольку они работают с отдельными блокировками бакета.**

###### Процесс добавления элемента в `ConcurrentHashMap`. Вот подробные шаги:

1. **ConcurrentHashMap**: Сначала мы имеем экземпляр `ConcurrentHashMap`.
2. **Node[] table**: Затем мы переходим к массиву ведер (`Node[] table`), который является полем в `ConcurrentHashMap`.
3. **Node<K, V>**: Внутри нужного ведра (`table`) мы находим или создаем нужный узел (`Node<K, V>`).
4. **Ключ-значение**: В конце мы кладем пару ключ-значение в найденный или созданный узел.
##### **Одновременные операции чтения и записи в ConcurrentHashMap:**
- **Операция чтения/получения:** Два потока `T1` и `T2` могут одновременно считывать данные из одного и того же или разных бакетов `ConcurrentHashMap`, не блокируя друг друга.

- **Операция записи/ввода:** Два потока `T1` и `T2` могут одновременно записывать данные в разные бакеты, не блокируя друг друга. Однако два потока не могут одновременно записывать данные в одни и те же бакеты. Один поток должен ждать, пока другой завершит операцию.

- **Операция чтения-записи:** Два потока могут одновременно читать и записывать данные в разные бакеты, не блокируя друг друга. Обычно операции извлечения не блокируются, поэтому могут пересекаться с операциями записи (помещения/удаления). Последнее обновленное значение будет возвращено операцией получения, которая является самым последним обновленным значением операции записи (включая размещение/удаление).

По умолчанию ConcurrentHashMap имеет размер бакетов равный 16.
Однако стоит отметить, что хотя размер массива ведер (`Node[] table`) по умолчанию равен 16, это не означает, что только 16 потоков могут одновременно помещать данные в карту. Благодаря механизму блокировки на уровне сегмента, `ConcurrentHashMap` позволяет большему числу потоков работать с картой без взаимной блокировки, даже если они работают с одним и тем же ведром. Это достигается за счет того, что операции обновления (`put`, `remove` и т.д.) блокируют только узлы, с которыми они работают, а не весь список или дерево в ведре.

**concurrencyLevel параметр указывает ожидаемое количество потоков, которые будут одновременно работать с `ConcurrentHashMap`**, и определяет размер массива бакетов соответственно.
```java
ConcurrentHashMap map = new ConcurrentHashMap(int initialCapasity, float loadFactor, int concurrencyLevel);

ConcurrentHashMap map = new ConcurrentHashMap(100, 0.75f, 10);
```

**Каждый сегмент в ConcurrentHashMap содержит собственный массив (Node[]),** который используется для хранения данных. Когда размер этого массива превышает определенный коэффициент загрузки, то есть становится слишком заполненным, он должен быть перехеширован для уменьшения коллизий и обеспечения эффективного доступа к данным.

**Когда происходит необходимость в перехешировании сегмента, это выполняется независимо от других сегментов.** Например, если поток 1 вставляет данные в сегмент с индексом 3 и обнаруживает, что массив Node[] в этом сегменте требует перехеширования из-за превышения коэффициента загрузки, то он будет выполнять перехеширование только для этого сегмента. **При этом массивы Node[] в других сегментах останутся неизменными и продолжат обслуживать запросы на вставку и извлечение параллельно. Это позволяет избежать конфликтов между потоками, работающими с разными сегментами, и обеспечивает параллельное выполнение операций на разных участках данных ConcurrentHashMap.**
#### 28. Что знаешь про CopyOnWriteArrayList? 
**CopyOnWriteArrayList** - это потокобезопасная реализация списка в Java, которая обеспечивает безопасное чтение данных и позволяет производить модификации списка без блокировки доступа к нему при чтении. Вот более подробное объяснение особенностей этой структуры данных:

1. **Volatile массив Object внутри**: Внутри CopyOnWriteArrayList используется массив элементов, который объявлен как volatile. Это гарантирует, что изменения, внесенные в массив одним потоком, будут видны всем остальным потокам сразу после завершения записи.
    
2. **Блокировка только при модификации списка**: Как указано в названии, при каждой операции модификации списка (добавлении или удалении элементов) создается его копия, а затем изменения вносятся в эту копию. Это позволяет избежать блокировки доступа к списку при выполнении операций чтения, что делает операции чтения очень быстрыми.
    
3. **Новая копия массива при модификации**: При модификации списка создается новая копия массива элементов, в которую затем вносятся изменения. Это гарантирует, что операции чтения не будут затронуты изменениями, происходящими во время модификации.
    
4. **Fail-safe итератор**.

6. **Модификация через итератор невозможна**: Изменение элементов списка через итератор невозможно, и это приведет к выбросу UnsupportedOperationException. Это сделано для обеспечения безопасности и защиты от непредсказуемого поведения при модификации списка во время итерации.

Почему важно, чтобы операции по удалению и вставке элементов были не частыми? Как уже упоминалось, каждая модификация списка приводит к созданию его копии, что занимает дополнительные ресурсы. Если операции вставки и удаления элементов будут слишком частыми, это может привести к значительным затратам памяти и процессорного времени на создание и копирование списков. Поэтому CopyOnWriteArrayList наиболее эффективен в сценариях, где операции чтения преобладают над операциями модификации.

#### 29. Stream API & ForkJoinPool Как связаны, что это такое. 
Stream API — это одна из ключевых особенностей, введенных в Java . Он предоставляет набор методов, которые позволяют обрабатывать данные в функциональном стиле. **Stream API может использовать ForkJoinPool, однако для этого требуется использовать parallelStream() вместо stream().**

**ForkJoinPool — это реализация интерфейса ExecutorService, которая использует алгоритм “разделяй и властвуй” для выполнения задач.** По умолчанию, при использовании параллельных потоков, они используют общий пул потоков `ForkJoinPool.commonPool()`. Этот пул создается статически и продолжает существовать до завершения работы приложения, обычно путем вызова `System::exit`. Если явно не указан другой пул потоков, все задачи будут выполняться в рамках этого общего пула.
Размер пула по умолчанию равен количеству доступных процессорных ядер минус одно. Такой подход обеспечивает эффективное использование ресурсов многоядерного процессора.

**Таким образом, Stream API и ForkJoinPool взаимодействуют друг с другом при выполнении параллельных операций. Stream API использует ForkJoinPool для распределения задач между потоками.**

Когда какой-либо поток отправляет задачу в общий пул, этот пул может использовать сам поток-отправитель для выполнения задачи. Таким образом, `ForkJoinPool` пытается максимально загрузить свои задачи и даже использовать вызывающий поток для выполнения некоторых задач.

Сортировка слиянием на `ForkJoinPool` - это эффективный подход к сортировке больших массивов данных в параллельной среде. Она использует принцип разделения и властвования для разделения массива на более мелкие части, сортирует их независимо и затем объединяет отсортированные части в итоговый отсортированный массив. Этот процесс может быть эффективно распараллелен с использованием `ForkJoinPool`, что может ускорить сортировку на многоядерных системах.
#### 29. Зачем используются thread local переменные? 
Класс ThreadLocal представляет хранилище тред-локальных переменных. По способу использования он похож на обычную обертку над значением, с методами get(), set() и remove() для доступа к нему, и дополнительным фабричным методом ThreadLocal.withInitial(), устанавливающим значение по умолчанию. 

Отличие тред-локальной переменной от обычной в том, что ThreadLocal хранит отдельную независимую копию значения для каждого ее использующего потока. Работа с такой переменной потокобезопасна.

Первый, самый очевидный вариант использования – данные, относящиеся непосредственно к треду, определенный пользователем «контекст потока». Например, ThreadId.get() вернет порядковый номер текущего треда. 
Другой случай, с которым локальная переменная потока может помочь – кэширование read-only данных в многопоточной среде без дорогостоящей синхронизации. 
Помимо обычного ThreadLocal, в стандартной библиотеке присутствует его расширение InheritableThreadLocal. Этот класс «наследует» значение – изначально берет его для потока, являющегося родителем текущего
```java
public class ThreadLocalExample {  
    // Создаем thread-local переменную для хранения порядкового номера потока  
    private static ThreadLocal<Integer> threadId = ThreadLocal.withInitial(() -> {  
        return Thread.currentThread().getId();  
    });  
  
    public static int getThreadId() {  
        // Возвращаем порядковый номер текущего потока из thread-local переменной  
        return threadId.get();  
    }  
  
    public static void main(String[] args) {  
        // Создаем и запускаем несколько потоков  
        Thread thread1 = new Thread(() -> {  
            System.out.println("Thread ID: " + getThreadId());  
        });  
        thread1.start();  
  
        Thread thread2 = new Thread(() -> {  
            System.out.println("Thread ID: " + getThreadId());  
        });  
        thread2.start();  
    }  
}
```
#### 30. Как реализовать двусторонний обмен данными между потоками? 
Вопрос, который зачастую дается в виде практической задачи. Конечно, результата можно добиться разными способами: парой атомарных переменных, критическими секциями, потокобезопасными коллекциями. 

Специально для этого случая в стандартной библиотеке java.util.concurrent есть простой класс `Exchanger`. 
Класс содержит единственный метод `V exchange(V x)`. Один поток передает в него данные, и встает в ожидание. Ожидание завершается, когда второй поток также приходит в метод `exchange` со своей порцией информации. В качестве результата вызова потоки получают данные друг друга. 

На основе класса `Exchanger` удобно создавать пайплайны обработки данных. Первый поток выполняет свою часть обработки, и складывает результаты в буфер. В качестве буфера может работать любой многоразовый объект-контейнер. Когда он заполняется, следующий поток обменивает его на второй, пустой буфер. Таким образом два буфера используются поочередно, не выделяется лишний раз память и не нагружается GC. Далее из попарно обменивающихся буферами потоков может строиться длинная многопоточная цепочка обработки.
##### Рассмотрим примерное описание процесса работы пайплайна на основе `Exchanger`:
1. **Первый поток (Producer)**: Этот поток выполняет начальную обработку данных и складывает результаты в буфер. После того как буфер заполнен, первый поток передает его второму потоку через `Exchanger` и ожидает получения нового пустого буфера от второго потока.
    
2. **Второй поток (Consumer)**: Этот поток принимает буфер от первого потока через `Exchanger`, выполняет дальнейшую обработку данных и складывает результаты в новый буфер. Затем он передает этот заполненный буфер обратно первому потоку через `Exchanger` и ожидает получения нового пустого буфера от первого потока.
    
3. **Повторение процесса**: После обмена буферами между первым и вторым потоками процесс повторяется: первый поток выполняет новую порцию обработки данных и передает заполненный буфер второму потоку, который, в свою очередь, продолжает обработку и возвращает пустой буфер первому потоку.

#### 31. Какими коллекциями пользоваться в многопоточной среде?
Первый вариант – превратить в синхронизированную обычную коллекцию, вызвав соответствующий ее типу метод Collections.synchronized*(). Самый общий и самый примитивный способ, создает обертку с синхронизацией всех операций с помощью synchronized.

Если работа с коллекцией состоит в основном из чтения, лучшая в плане производительности альтернатива – CopyOnWriteArrayList, и содержащий его в реализации CopyOnWriteArraySet.

Потокобезопасность достигается копированием внутреннего массива при любой модификации, оригинальный массив остается immutable.

Program order достигается модификатором volatile на внутреннем массиве. 

Третий вариант – использование Concurrent-коллекций: 
- Неблокирующие хэш таблицы ConcurrentSkipListMap, ConcurrentHashMap и ConcurrentSkipListSet (хэш-таблица в основе реализации) 
- Неблокирующие очереди ConcurrentLinkedQueue и ConcurrentLinkedDeque 
- Большой набор различных блокирующих очередей