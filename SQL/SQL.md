#### 1. Что такое данные, информация, база данных? Что «под капотом» БД? 
**Данные** – это факты, структурированные или неструктурированные, которые могут быть записаны, сохранены и использованы для различных целей.
Это информация в формализованном виде, т.е. пригодном для интерпретации, обработки, передачи.

**Информация** - это осмысленный набор данных, который приносит пользу и имеет значение для конкретного контекста или задачи. **Структурированные данные.**

**База данных** - это организованная коллекция данных. База данных предоставляет удобный способ хранения, организации и доступа к данным.

**СУБД (система управления базами данных)** - это программное обеспечение, которое используется для создания, управления и обслуживания баз данных. Она предоставляет интерфейс для пользователя или приложения взаимодействовать с данными в базе данных, обеспечивая функции хранения, поиска, обновления и удаления данных. **Обеспечивает безопасность данных.**

**Семь из десяти самых популярных СУБД** — реляционные (связанные, relation/связь) Это Oracle, MySQL, Microsoft SQL Server, PostgreSQL, IBM Db2, Microsoft Access, SQLite.
**Есть также:** MongoDB – документ- ориентированная СУБД; Redis - хранилище по типу «ключ-значение»; Elasticsearch - поисковой движок.

**DBeaver** - это универсальный инструмент для работы с базами данных. Он предоставляет среду для подключения к различным типам баз данных, выполнения SQL-запросов, администрирования и визуализации данных. DBeaver поддерживает большое количество СУБД, включая реляционные (например, MySQL, PostgreSQL, Oracle, Microsoft SQL Server), NoSQL (например, MongoDB, Cassandra) и другие типы баз данных.
##### Что «под капотом» БД?
Под капотом систем управления базами данных (СУБД) обычно лежат файлы, содержащие данные и метаданные. Однако каждая СУБД имеет свой собственный способ организации и интерпретации этих файлов.

В типичной реляционной базе данных данные обычно организованы в таблицы. Вот как эти таблицы обычно хранятся на уровне структуры данных:

1. **Строки и столбцы**: Таблица содержит строки и столбцы. Каждая строка таблицы представляет собой набор данных, а каждый столбец определяет тип данных, который хранится в соответствующей колонке для каждой строки.
    
2. **Страницы**: Для хранения данных таблицы физически разбиваются на страницы. Например, если таблица имеет размер 1 Гб и каждая страница имеет размер 8 Кб, это означает, что таблица будет состоять из (1 Гб / 8 Кб) = 128 000 страниц.
    
3. **Заголовок страницы**: Каждая страница содержит заголовок, который содержит метаданные о самой странице, такие как метаинформация, идентификатор страницы и другая управляющая информация.
    
4. **Строки и заголовки**: В каждой странице содержатся как данные, так и метаданные о данных. Это включает в себя заголовки строк, которые могут содержать метаданные о типе данных, ограничениях и других атрибутах, а также фактические значения данных для каждой строки.
    
5. **Ссылки на строки (CTID)**: CTID - это специальное поле, которое используется для ссылки на конкретные строки в таблице. Каждая страница может содержать ссылки на строки, указывающие, где в этой странице находятся данные для каждой строки.
    
Таким образом, внутренняя структура таблицы в базе данных включает в себя организацию данных на уровне страниц, заголовки страниц, данные строк и соответствующие им метаданные, а также ссылки на строки для быстрого доступа к данным.

#### 2. Что такое SQL? 
**SQL (Structured Query Language)** - это язык программирования, используемый для управления данными и их обработки  в реляционных базах данных. Он предоставляет стандартизированный способ выполнения различных операций с данными, таких как вставка, обновление, удаление, выборка и управление структурой баз данных.

**Внешние программы могут формировать запросы к СУБД на языке SQL.** Это один из основных способов взаимодействия с базой данных.

##### Что такое SQL-сервер и как он работает?
В широком понимании, SQL-сервер - это программный комплекс, который предоставляет доступ к базе данных и обрабатывает запросы, написанные на языке структурированных запросов SQL.

Он работает по принципу клиент-серверной архитектуры. Клиент (например, приложение) отправляет запросы к SQL-серверу, который затем обрабатывает эти запросы и возвращает результаты.

##### Виды СУБД:
1. **Реляционные СУБД (RDBMS)**: Этот тип СУБД основан на реляционной модели данных, где данные организованы в виде таблиц с рядами и столбцами. Примеры: Oracle, MySQL, Microsoft SQL Server, PostgreSQL.
	
2. **Нереляционные СУБД (NoSQL)**: Используются для хранения и управления нереляционными или полуструктурированными данными.  Включают различные модели данных, такие как документы, ключ-значение, столбцы и графы. Примеры: MongoDB (документ), Redis (ключ-значение), Cassandra (столбцы), Neo4j (графы).
    
3. **Объектно-реляционные СУБД (ORDBMS)**: Этот вид СУБД расширяет реляционную модель данных, добавляя поддержку объектно-ориентированных концепций, таких как наследование, полиморфизм и инкапсуляция. Примеры: Oracle, PostgreSQL.
    
4. **Иерархические СУБД (Hierarchical DBMS)**: Эти СУБД организуют данные в виде иерархии, где каждый элемент имеет одного родителя и ноль или более дочерних элементов. Пример: IBM IMS.
    
5. **Сетевые СУБД (Network DBMS)**: Этот тип СУБД основан на сетевой модели данных, где данные организованы в виде сети элементов (узлов) и связей между ними. Пример: Integrated Data Store (IDS).
    
6. **Объектно-ориентированные СУБД (ODBMS)**: В этих СУБД данные хранятся в виде объектов, а не в табличной форме, что позволяет лучше моделировать объектные структуры данных. Примеры: db4o, ObjectStore.

##### Особенности реляционных БД:
1. **Структурированность:** Данные в реляционных БД хранятся в структурированном виде, в таблицах, состоящих из столбцов и строк. Каждый столбец имеет определенный тип данных.
2. **Уникальность:** Каждая строка в таблице представляет собой уникальную запись с уникальным идентификатором, который называют ключом.
3. **Взаимосвязь:** Реляционные БД позволяют устанавливать взаимосвязи между различными таблицами на основе общих ключей.
4. **Строгая типизация:** Модель данных в реляционных БД определена заранее и является строго типизированной.
5. **Использование SQL:** Для работы с реляционными БД используется язык структурированных запросов SQL.
6. **Запросы** к базе данных возвращают результат в виде таблицы.
7. В таблице **может не быть ни одной строчки**, но обязательно **должен быть хотя бы 1 столбец.**

![[Pasted image 20240422223313.png]]

#### 3. Что такое Query? 
**Запрос (Query)** в контексте баз данных обозначает запрос на извлечение, изменение или удаление данных из базы данных. Обычно запросы формулируются на языке структурированных запросов (SQL) и представляют собой инструкции, направленные на выполнение определенных операций с данными.
##### Что такое JPQL?
**JPQL (Java Persistence Query Language)** - это язык запросов, используемый в Java Persistence API (JPA) для выполнения операций с объектами в базе данных с использованием объектно-ориентированной модели данных.

JPQL представляет собой спецификацию языка запросов, которая аналогична SQL, но работает с сущностями и их полями вместо таблиц и столбцов. Он позволяет выполнять различные операции с данными, такие как выборка, фильтрация, сортировка и агрегация, используя объекты и их свойства.

##### Как передать в объект Query параметры?
**HQL** запрос всегда начинается с получения объекта `Query` из `Session` вызовом метода `createQuery()`, в который передаётся текст запроса.
Параметры также могут быть переданы с помощью метода `setParameter()` объекта `Query`.
```java
String queryString = "FROM Customer WHERE age > :age";
Query query = session.createQuery(queryString);
query.setParameter("age", 18);
List<Customer> adults = query.list();
```
#### 4. Какие бывают связи таблиц SQL? 
1. **Один-к-одному (One-to-One)**: В этом типе связи каждая запись в одной таблице соответствует ровно одной записи в другой таблице, и наоборот. Например, каждый сотрудник может иметь только одну карточку доступа, а каждая карточка доступа принадлежит только одному сотруднику.
    
2. **Один-ко-многим (One-to-Many)**: В этом типе связи одна запись в одной таблице может иметь несколько соответствующих записей в другой таблице. Например, каждая страна может иметь несколько городов, но каждый город принадлежит только одной стране.
    
3. **Многие-к-одному (Many-to-One)**: Это обратное отношение к одному-ко-многим, где несколько записей в одной таблице соответствуют одной записи в другой таблице. Например, множество студентов может принадлежать к одному университету.
    
4. **Многие-ко-многим (Many-to-Many)**: В этом типе связи множество записей в одной таблице может соответствовать множеству записей в другой таблице. Для реализации таких связей требуется промежуточная таблица (таблица-связь), которая связывает записи из двух таблиц. Например, многие студенты могут учиться во многих курсах, и каждый курс может иметь множество студентов.

#### 5. Что такое DDL? Какие операции в него входят? Рассказать про них. 
**DDL (Data Definition Language)** - это подмножество SQL, которое используется для определения структуры базы данных и ее объектов, таких как таблицы, индексы, представления и другие. Операции DDL позволяют создавать, изменять и удалять эти объекты в базе данных. Вот основные операции DDL:

1. **CREATE**: Операция CREATE используется для создания новых объектов в базе данных, таких как таблицы, индексы, представления и т. д. Например, чтобы создать новую таблицу, вы можете использовать оператор CREATE TABLE. Пример:
```mysql
CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    LastName VARCHAR(50),
    FirstName VARCHAR(50),
    DepartmentID INT,
    Salary DECIMAL(10,2)
);
```

2. **ALTER**: Операция ALTER используется для изменения структуры существующих объектов в базе данных. Например, вы можете добавить новый столбец в таблицу, изменить тип данных существующего столбца или добавить ограничения к столбцу. Пример:
```mysql
ALTER TABLE Employees
ADD COLUMN Email VARCHAR(100);
```

3. **DROP**: Операция DROP используется для удаления существующих объектов из базы данных. Например, вы можете удалить таблицу, индекс или представление. Важно быть осторожным при использовании операции DROP, так как удаление объектов может привести к потере данных. Пример:
```mysql
DROP TABLE Employees;
```

4. **TRUNCATE**: Операция TRUNCATE используется для удаления всех записей из таблицы без удаления самой таблицы. Это полезно, когда вам нужно быстро удалить все данные из таблицы, но сохранить ее структуру. Пример:
```mysql
TRUNCATE TABLE Employees;
```

5. **RENAME**: Операция RENAME используется для изменения имени существующего объекта в базе данных. Например, вы можете переименовать таблицу, столбец или индекс. Пример:
```mysql
ALTER TABLE Employees
RENAME COLUMN DepartmentID TO DeptID;
```
#### 6. Что такое DML? Какие операции в него входят? Рассказать про них. 
**DML (Data Manipulation Language)** - это подмножество SQL, которое используется для манипулирования данными внутри таблиц базы данных. Операции DML позволяют добавлять, изменять и удалять данные из таблиц. Вот основные операции DML:

1. **INSERT**: Операция INSERT используется для добавления новых записей в таблицу базы данных. Вы можете вставить одну или несколько записей сразу. Пример:
```mysql
INSERT INTO Employees (EmployeeID, LastName, FirstName, DepartmentID, Salary)
VALUES (1, 'Smith', 'John', 101, 50000.00);
```

2. **UPDATE**: Операция UPDATE используется для изменения существующих записей в таблице. Вы можете обновить значения одного или нескольких столбцов для определенных записей с использованием условия WHERE. Пример:
```mysql
UPDATE Employees
SET Salary = 55000.00
WHERE EmployeeID = 1;
```

3. **DELETE**: Операция DELETE используется для удаления записей из таблицы. Вы можете удалить одну или несколько записей с использованием условия WHERE. Важно быть осторожным при использовании операции DELETE, так как удаление записей приводит к потере данных. Пример:
```mysql
DELETE FROM Employees
WHERE EmployeeID = 1;
```

4. **MERGE**: Операция MERGE позволяет объединить данные из источника данных с целевой таблицей на основе определенного условия совпадения. Если запись уже существует в целевой таблице, то данные обновляются, иначе они вставляются как новая запись. Пример:
```mysql
MERGE INTO Employees AS target
USING NewEmployees AS source
ON target.EmployeeID = source.EmployeeID
WHEN MATCHED THEN
    UPDATE SET target.Salary = source.Salary
WHEN NOT MATCHED THEN
    INSERT (EmployeeID, LastName, FirstName, DepartmentID, Salary)
    VALUES (source.EmployeeID, source.LastName, source.FirstName, source.DepartmentID, source.Salary);
```

5. SELECT
#### 7. Что такое TCL? Какие операции в него входят? Рассказать про них. 
**TCL (Transaction Control Language)** - это подмножество языка SQL, которое используется для управления транзакциями в базе данных. Операции TCL позволяют начинать, завершать и управлять транзакциями, которые представляют собой логические операции, состоящие из одного или нескольких DML (Data Manipulation Language) операций. Вот основные операции TCL:

1. **COMMIT**: Операция COMMIT используется для завершения текущей транзакции и сохранения всех изменений, сделанных в рамках этой транзакции, в базе данных. После успешного выполнения операции COMMIT изменения становятся постоянными и видимыми для других пользователей.

2. **ROLLBACK**: Операция ROLLBACK используется для отмены всех изменений, сделанных в рамках текущей транзакции, и возврата базы данных в состояние, которое было до начала этой транзакции.

3. **SAVEPOINT**: Операция SAVEPOINT используется для создания точки сохранения внутри текущей транзакции. Это позволяет вам сделать позже ROLLBACK до этой точки, вместо того чтобы отменять всю транзакцию целиком.

4. **RELEASE SAVEPOINT**: Операция RELEASE SAVEPOINT используется для удаления указанной точки сохранения в текущей транзакции. Это позволяет освободить ресурсы, которые были выделены для этой точки сохранения.

5. **SET TRANSACTION**: Операция SET TRANSACTION используется для установки различных свойств транзакции, таких как изоляция транзакций, уровень изоляции и другие параметры.

#### 8. Что такое DCL? Какие операции в него входят? Рассказать про них. 
**DCL (Data Control Language)** - это подмножество языка SQL, которое используется для управления доступом к данным в базе данных. Операции DCL позволяют администраторам баз данных управлять привилегиями доступа к объектам базы данных, таким как таблицы, представления и хранимые процедуры. Вот основные операции DCL:

1. **GRANT**: Операция GRANT используется для предоставления привилегий определенным пользователям или ролям в базе данных. Привилегии могут включать права на выполнение операций SELECT, INSERT, UPDATE, DELETE и другие на определенных объектах базы данных. Пример:
```mysql
GRANT SELECT, INSERT ON Employees TO user1;
```

2. **REVOKE**: Операция REVOKE используется для отмены или удаления привилегий, предоставленных ранее с помощью операции GRANT. Это позволяет администраторам баз данных изменять уровень доступа пользователей к данным в базе данных. Пример:
```mysql
REVOKE INSERT ON Employees FROM user1;
```

3. **DENY:** Она используется для отказа в доступе к определенным объектам базы данных или их компонентам, таким как таблицы, представления, хранимые процедуры и другие, определенным пользователям или ролям. Пример:
```mysql
DENY SELECT, INSERT, UPDATE, DELETE ON Employees TO user1;
```

#### 9. Нюансы работы с NULL в SQL. Как проверить поле на NULL? 
NULL представляет собой специальное значение, обозначающее "пустое поле" или "отсутствие значения" в базе данных. Это важно для различения между пустыми значениями и отсутствующими данными.

Операторы сравнения и логические операции в SQL обрабатывают NULL особым образом, поскольку NULL не является конкретным значением и не может быть равно или не равно другим значениям. Оператор IS NULL и IS NOT NULL используются для проверки, содержит ли поле NULL значение или нет.

Результат сравнения значения с NULL в SQL будет NULL, если не используется оператор эквивалентности <=>. Это связано с тем, что NULL представляет собой отсутствие значения, и поэтому результат любого сравнения с NULL также будет отсутствовать. Оператор эквивалентности <=> (NULL-safe equal) позволяет сравнивать NULL значения без явного исключения NULL != NULL. Он вернет TRUE при сравнении двух NULL значений.

#### 10. Виды Join’ов (виды связывания таблиц). 
![[Pasted image 20240420140154.png]]

1. **INNER JOIN**: Он возвращает строки, которые имеют соответствующие значения в обеих таблицах. INNER JOIN связывает строки из двух таблиц на основе условия соответствия (JOIN условия), определенного в предложении ON или WHERE.
2. **LEFT JOIN (или LEFT OUTER JOIN)**: Возвращает все строки из левой таблицы и соответствующие строки из правой таблицы. Если в правой таблице нет соответствия, то возвращается NULL.
3. **RIGHT JOIN (или RIGHT OUTER JOIN)**: Возвращает все строки из правой таблицы и соответствующие строки из левой таблицы. Если в левой таблице нет соответствия, то возвращается NULL.
4. **FULL JOIN (или FULL OUTER JOIN)**: Возвращает все строки из обеих таблиц. Если нет соответствия, то возвращается NULL. 
   
   Алгоритм работы full join: 
	   1. Формируется таблица на основе внутреннего соединения (INNER JOIN). 
	   2. В таблицу добавляются значения не вошедшие в результат формирования из левой таблицы (LEFT OUTER JOIN). 
	   3. В таблицу добавляются значения не вошедшие в результат формирования из правой таблицы (RIGHT OUTER JOIN). 
	Соединение FULL JOIN реализовано НЕ во всех СУБД. Например, в MySQL оно отсутствует, однако его можно очень просто эмулировать

5. **CROSS JOIN (или CARTESIAN JOIN)**: Создает декартово произведение всех строк из двух таблиц. Каждая строка из первой таблицы соединяется со всеми строками из второй таблицы.

#### 11. Что лучше использовать join или подзапросы? Почему? 
Выбор между использованием JOIN и подзапросов зависит от конкретной задачи, структуры данных и требований к производительности. Оба подхода имеют свои преимущества и недостатки, и выбор между ними может быть обусловлен следующими факторами:

1. **Читаемость кода**: Во многих случаях использование JOIN делает SQL-запрос более читаемым и понятным, особенно когда требуется соединение нескольких таблиц. JOIN выражает отношения между таблицами явно, что облегчает понимание структуры запроса.
    
2. **Производительность**: Использование JOIN может быть более эффективным с точки зрения производительности, особенно при выполнении запросов к большим таблицам. Оптимизатор запросов базы данных обычно более эффективно обрабатывает JOIN, чем подзапросы, что может привести к более быстрому выполнению запроса.
    
3. **Гибкость**: Подзапросы могут быть более гибкими в некоторых случаях, особенно если требуется выполнить сложные операции фильтрации или агрегации данных перед объединением с другой таблицей. Они могут быть полезны, когда необходимо выполнить вычисления или фильтрацию на основе результатов другого запроса.
    
4. **Поддержка старых версий баз данных**: Некоторые старые версии баз данных могут не поддерживать некоторые типы JOIN (например, LEFT JOIN), поэтому использование подзапросов может быть более универсальным способом написания запросов.

**Alias (псевдоним)** — это имя, назначенное источнику данных в запросе при использовании выражения в качестве источника данных или для упрощения ввода и прочтения инструкции SQL. Это м.б. полезно, если имя источника данных слишком длинное или его трудно вводить.

#### 12. Что делает UNION? 
Оператор **UNION** в SQL используется для объединения результатов двух или более SELECT запросов в один набор результатов. Однако, для успешного выполнения оператора UNION, следует учитывать следующие условия:

1. **Количество столбцов**: Каждый SELECT запрос, объединяемый с помощью UNION, должен возвращать одинаковое количество столбцов.
    
2. **Типы данных**: Типы данных в каждом столбце должны быть совместимы между соответствующими столбцами во всех SELECT запросах. Например, если первый SELECT возвращает столбец типа VARCHAR(50), то все другие SELECT также должны вернуть столбцы совместимого типа данных.
    
3. **Порядок столбцов**: Порядок столбцов в каждом SELECT запросе должен быть одинаковым. То есть, если в первом SELECT запросе столбец "Name" идет первым, то он должен идти первым и в остальных SELECT запросах.
    
4. **Уникальность**: По умолчанию оператор UNION удаляет дубликаты строк из результирующего набора. Если требуется сохранить дубликаты, следует использовать оператор UNION ALL.
    
5. **Порядок строк**: Порядок строк в результирующем наборе не гарантирован, если он не указан явно с помощью оператора ORDER BY.
    
6. **Семантика столбцов**: Предполагается, что столбцы, объединяемые с помощью UNION, имеют одинаковую семантику. Например, если в одном SELECT запросе столбец "Age" содержит возрасты, то в других запросах он также должен содержать возрасты, а не, например, имена.

#### 13. Чем WHERE отличается от HAVING? 
Команды **WHERE** и **HAVING** играют важную роль в фильтрации результатов запроса, но они служат разным целям и применяются на разных этапах выполнения запроса.

WHERE применяется к отдельным строкам до того, как строки сгруппированы в группы с помощью GROUP BY, в то время как HAVING применяется к группам после группировки строк.
###### WHERE
- используется для фильтрации записей из таблицы или при объединении более одной таблицы.
- применяется до любой группировки или агрегации в запросе.
- работает на уровне отдельных записей.
```mysql
-- Выбрать всех сотрудников, у которых возраст больше 30 лет
SELECT name, age
FROM employees
WHERE age > 30;
```
###### HAVING
- используется для фильтрации записей из групп на основе заданного условия.
- применяется после группировки и агрегации данных.
- может содержать агрегатные функции.
- работает на уровне сгруппированных записей.
```mysql
-- Посчитать средний возраст сотрудников в каждом отделе и выбрать только те отделы, где средний возраст больше 35 лет
SELECT department, AVG(age) AS average_age
FROM employees
GROUP BY department
HAVING AVG(age) > 35;
```

#### 14. Что такое GROUP BY? 
Команда **GROUP BY** в SQL используется для группировки строк на основе значений одного или нескольких столбцов.

На практике **GROUP BY** часто используется с агрегатными функциями, такими как **MIN**, **MAX**, **AVG**, **SUM**, или **COUNT**, чтобы вычислить меру(грубо говоря общее значение), которая предоставляет информацию для каждой группы.

Если столбец группировки содержит значения **NULL**, все значения **NULL** суммируются в одну группу, потому что **GROUP BY** считает все значения **NULL** равными.

Важно отметить, что **GROUP BY** является необязательной частью оператора **SELECT**.
```mysql
SELECT column1, column2, aggregate_function(column3)
FROM table_name
GROUP BY column1, column2;
```

#### 15. Что такое ORDER BY? 
При выполнении **SELECT** запроса, строки по умолчанию возвращаются в неопределенном порядке. 

Фактический порядок строк в этом случае зависит от плана соединения и сканирования, а также от порядка расположения данных на диске, поэтому полагаться на него нельзя. Для упорядочивания записей используется конструкция **ORDER BY**.
```mysql
SELECT column_name
FROM table_name
ORDER BY column_name [ASC|DESC][, column_name_n [ASC|DESC]];
```
В этой структуре запроса необязательные параметры указаны в квадратных скобках.

**ASC**(asceding) используется для сортировки данных в порядке **возрастания**(является сортировкой по умолчанию).
**DESC**(descending) используется для сортировки данных в порядке **убывания**.

Правило сортировки применяется только к тому столбцу, за которым оно следует

Если в запросе присутствуют WHERE, GROUP BY или HAVING, то **ORDER BY** должен идти после них.
###### Сортировка по нескольким столбцам
Для сортировки результатов по двум или более столбцам их следует указывать через запятую.

Данные будут сортироваться по первому столбцу, но, в случае если попадаются несколько записей с совпадающими значениями в первом столбце, то они сортируются по второму столбцу. Количество столбцов, по которым можно отсортировать, не ограничено.

Важно отметить, что **ORDER BY** - единственный способ отсортировать строки в результирующем наборе. Без этого оператора, система реляционной базы данных может возвращать строки в любом порядке. Если требуется определенный порядок, **ORDER BY** должен быть указан в операторе SELECT, отправленном приложением.

#### 16. Что такое DISTINCT? Что такое LIMIT? 
Оператор **DISTINCT** используется для выбора уникальных значений из столбца или набора столбцов в таблице. Он позволяет избежать повторений и получить только уникальные записи.
```mysql
SELECT DISTINCT column_name FROM table_name;
```

Оператор **LIMIT** используется для ограничения количества строк, которые возвращаются в результате запроса. Он позволяет выбирать только определенное количество строк из таблицы.

Вывести все уникальные имена из списка. Пропустить две (OFFSET 2), оставить в результате две записи (LIMIT 2).
```mysql
SELECT column_name FROM table_name LIMIT 10 OFFSET 2;
```

>[!INFO]
>Когда мы делаем выборку SELECT FROM, то порядок НЕ гарантирован и может меняться в зависимости от вставки или индекса. Поэтому сначала нужно сделать сортировку (например, по идентификатору), а потом добавлять ограничение LIMIT и OFFSET. Для сортировки используем ORDER BY.
#### 17. Что такое EXISTS? 
Оператор **EXISTS** используется для проверки наличия хотя бы одной строки, удовлетворяющей условию в подзапросе. Он возвращает значение TRUE, если подзапрос возвращает хотя бы одну строку, и FALSE в противном случае.
```mysql
SELECT name
FROM customers
WHERE EXISTS (
    SELECT *
    FROM orders
    WHERE orders.customer_id = customers.customer_id
);
```
Этот запрос выбирает имена клиентов из таблицы customers, для которых существуют заказы в таблице orders. Оператор **EXISTS** проверяет наличие хотя бы одной строки в подзапросе, который выбирает заказы для каждого клиента, используя идентификатор клиента для связи таблиц.

#### 18. Расскажите про операторы IN, BETWEEN, LIKE. 
Оператор **IN** используется для проверки, совпадает ли значение объекта со значением в списке. Он позволяет выбирать данные, которые соответствуют любому из значений в указанном списке. 
```mysql
SELECT column_name FROM table_name WHERE column_name IN (value1, value2, ...);
```

Оператор **BETWEEN** используется для выбора значений в определенном диапазоне. Он позволяет выбирать данные, которые находятся между двумя указанными значениями. Удобен для дат.
```mysql
SELECT column_name FROM table_name WHERE column_name BETWEEN value1 AND value2;
```

Оператор **LIKE** используется, когда нужно сделать выборку по полю (например. по имени). Можем указать любое поле и даже только одну букву. LIKE чувствителен к регистру.
pattern = например строка 'Alex', поле some_name, символы подстановки, такие как `%` (заменяет любое количество символов) и `_` (заменяет один символ)
```mysql
SELECT column_name FROM table_name WHERE column_name LIKE pattern;
```

#### 19. Что делает оператор MERGE? Какие у него есть ограничения? 
Оператор **MERGE** используется для выполнения операции слияния данных из одной таблицы в другую на основе определённого условия. Обычно он используется для обновления или вставки данных в таблицу на основе существующих записей или новых данных.
```mysql
MERGE target_table AS target
USING source_table AS source
ON (target.id = source.id)
WHEN MATCHED THEN UPDATE SET target.column = source.column
WHEN NOT MATCHED THEN INSERT (column) VALUES (source.column);
```
В этом примере, если запись с таким же `id` уже существует в `target_table`, то она обновляется. Если такой записи нет, то она вставляется.

###### Однако, есть некоторые ограничения при использовании оператора MERGE:
- Нельзя изменять поля таблицы в секции UPDATE, по которым идет связывание двух таблиц.
- Данные изменяются или добавляются только для таблицы в предложении MERGE, таблица в предложении USING остается без изменений.
- Производительность оператора MERGE сильно зависит от индексов, используемых для сопоставления как исходной, так и целевой таблиц.
- Также важно оптимизировать условия объединения. Должна быть возможность отфильтровать исходную таблицу, чтобы оператор извлекал только необходимые записи для выполнения необходимых операций.

##### Отличия UNION от JOIN
1. **JOIN (соединение)**:
    - JOIN используется для объединения данных из двух или более таблиц на основе определенного условия.
    - JOIN не изменяет исходные таблицы, а только объединяет их данные для выполнения запроса.
      
2. **UNION (объединение)**:
    - UNION используется для объединения результатов двух или более запросов в один набор данных.
    - UNION не связан с таблицами напрямую, он работает с результатами запросов.
    - UNION возвращает уникальные строки (по умолчанию) или все строки (если используется UNION ALL) из результатов запросов.

##### **Отличия MERGE от JOIN и UNION**
**MERGE** изменяет данные в таблице (*делает апдейт строк, соответствующих условию*), **JOIN** объединяет данные для анализа, а **UNION** объединяет результаты запросов.

#### 20. Какие агрегатные/агрегирующие функции вы знаете? 
Агрегатная функция вычисляет единственное значение (получаем ОДНУ строку), обрабатывая множество строк. Агрегатные функции (иногда называют агрегирующие) есть во всех СУБД.

Агрегатные функции, вычисляющие по столбцу для набора строк:
- **SUM**: сумма
- **AVG**: среднее
- **MAX**: максимум
- **MIN**: минимум
- **COUNT**: количество (есть также вариант со звёздочкой: `SELECT count(*) FROM employees;`)
- **CONCAT**: конкатенация, например, объединение имени и фамилии в одном столбце

Не агрегатные математические функции (их много) – применяют действие ко всем значениям в столбце:
- **UPPER/LOWER**: перевод в верхний/нижний регистр
- **NOW**: текущая дата и т.д

1. **WHERE**:
    - Предложение WHERE используется для фильтрации строк до их группировки и вычисления агрегатных функций.
    - Это означает, что WHERE применяется к отдельным строкам в таблице, прежде чем они объединяются в группы или вычисляются агрегаты.
    - В WHERE вы можете использовать условия, чтобы отобрать только те строки, которые вы хотите увидеть в итоговом результате, но эти условия не могут использовать агрегатные функции.
      
2. **HAVING**:
    - Предложение HAVING применяется после группировки строк и вычисления агрегатных функций.
    - Оно позволяет фильтровать группы строк на основе результатов агрегатных функций.
    - В отличие от WHERE, HAVING позволяет использовать агрегатные функции для определения условий фильтрации групп строк.
      

#### 21. Что такое ограничения (constraints)? Какие вы знаете? 
Ограничения SQL, известные как **constraints**, используются для указания правил для данных в таблице. Ограничения обеспечивают надежность данных и предотвращают внесение недопустимых данных в таблицы. Вот некоторые из них:

1. **PRIMARY KEY**: Это ограничение обеспечивает уникальность каждого значения в столбце или наборе столбцов. Каждая таблица может иметь только один первичный ключ.
    
2. **FOREIGN KEY**: Это ограничение используется для связи двух таблиц. Оно предотвращает действия, которые могут уничтожить связи между таблицами. FOREIGN KEY в одной таблице указывает на PRIMARY KEY в другой. Поэтому данное ограничение нацелено на то, чтобы не было записей FOREIGN KEY, которым не отвечают записи PRIMARY KEY.(ответ в том числе на вопрос, почему внешние ключи - это ограничение?)
    
3. **UNIQUE**: Это ограничение обеспечивает уникальность каждого значения в столбце. Отличие от PRIMARY KEY в том, что таблица может иметь несколько уникальных ограничений, но только один PRIMARY KEY.
    
4. **NOT NULL**: Это ограничение гарантирует, что столбец не может иметь значение NULL.
    
5. **CHECK**: Это ограничение позволяет определить специфические условия, которым должны соответствовать данные в столбце. Например, диапазон значений.
    
6. **DEFAULT**: Это ограничение устанавливает значение по умолчанию для столбца, когда никакое другое значение не указано.
    
7. **INDEX**: Хотя это не ограничение в строгом смысле, индексы используются для ускорения операций поиска/выборки на таблице.
    

Эти ограничения можно установить во время создания таблицы (с помощью оператора CREATE TABLE) или после создания таблицы (с помощью оператора ALTER TABLE).

Есть также неявные ограничения, например по количеству символов для **VARCHAR** (аналог строки, последовательность символов в одинарных кавычках). Указывается в круглых скобках. Один символ char = 1 байт памяти, соответственно 128 – это и количество символов, и количество памяти.

#### 22. Что такое суррогатные ключи? Какие еще есть виды ключей?
1. **Суррогатный ключ (Surrogate Key)**: Это уникальный идентификатор в таблице, который не имеет никакого реального значения или отношения к данным. Суррогатные ключи обычно используются, когда нет подходящего естественного ключа. Они обычно создаются автоматически базой данных и могут быть целыми числами или GUID.
2. **Потенциальный ключ** **(Candidate Key)**: Простой или составной ключ, который уникально идентифицирует каждую запись набора данных. При этом потенциальный ключ должен обладать критерием неизбыточности: при удалении любого из полей набор полей перестает уникально идентифицировать запись. Из множества всех потенциальных ключей набора данных выбирают первичный ключ, все остальные ключи называют альтернативными.
3. **Первичный ключ (Primary Key)**: Это уникальный идентификатор записи в таблице. Первичный ключ должен обладать критерием неизбыточности и не может быть NULL. Критерии выбора первичного ключа включают уникальность, стабильность (значение не должно меняться со временем) и минимальность (должно использоваться как можно меньше полей).
4. **Внешний ключ (Foreign Key)**: Это поле или набор полей в одной таблице, которые ссылается на первичный ключ в другой таблице. Внешний ключ используется для установления связи между таблицами.

###### Дайте определение терминам «простой», «составной» (composite), «потенциальный» (candidate) и «альтернативный» (alternate) ключ.
1. **Простой ключ (Simple Key)**: Это ключ, который состоит из одного поля или столбца в таблице. Простой ключ уникально идентифицирует запись в таблице.
    
2. **Составной ключ (Composite Key)**: Это ключ, который состоит из двух или более полей или столбцов в таблице. Составной ключ используется, когда одного поля недостаточно для уникальной идентификации записи.
    
3. **Потенциальный ключ (Candidate Key)**: Это набор одного или нескольких полей/столбцов, который может быть использован в качестве первичного ключа. В таблице может быть несколько потенциальных ключей, но только один из них будет выбран в качестве первичного ключа.
    
4. **Альтернативный ключ (Alternate Key)**: Это потенциальный ключ, который не был выбран в качестве первичного ключа. Альтернативные ключи также уникальны и могут быть использованы для идентификации записей


#### 23. Теория множеств 
1. **Множества данных**:
    - В SQL данные хранятся и обрабатываются в виде множеств.
    - Таблицы в SQL можно рассматривать как множества строк, где каждая строка представляет отдельную запись, а столбцы определяют типы данных и свойства этих записей.
    - Результаты запросов также представляют собой множества данных, которые могут быть объединены, пересекаемы или разделены для получения нужной информации.
2. **Ограничения для операций со множествами:**
	**Количество полей/столбцов в строках должно совпадать**:
    - При выполнении операций объединения (UNION, UNION ALL), пересечения (INTERSECT) и исключения (EXCEPT) каждый запрос должен возвращать одинаковое количество столбцов.
    - Если количество столбцов в результирующих наборах различается, SQL не сможет выполнить операцию.
      
	**Тип данных в колонках должны совпадать**:
    - Каждый столбец, который участвует в операциях объединения, пересечения или исключения, должен иметь совместимый тип данных во всех запросах.
    - Например, если один столбец имеет тип данных VARCHAR(50), то соответствующий ему столбец в другом запросе должен иметь тот же тип данных VARCHAR(50) или совместимый тип.

![[Pasted image 20240420151410.png]]

#### 24. Какой вид структуры данных (какое дерево) используется при работе с базами данных? 
В базах данных часто используется структура данных, известная как B-дерево (B-tree). B-дерево является сбалансированным деревом, специально разработанным для эффективного хранения и поиска данных на жестких дисках или других устройствах хранения.

**Семейство B-Tree индексов** — это наиболее часто используемый тип данных (индексов), организованных как сбалансированное дерево, упорядоченных ключей и созданы для эффективной работы с дисковой памятью. Они поддерживаются практически всеми СУБД как реляционными, так не реляционными, и практически для всех типов данных

Основные особенности B-дерева:
1. **Сбалансированность**: Все пути от корня до листьев в B-дереве имеют одинаковую длину, что обеспечивает эффективный поиск данных.
    
2. **Многоуровневая структура**: У B-дерева может быть несколько уровней. Это позволяет эффективно хранить большие объемы данных, так как каждый узел может содержать множество ключей и ссылок на другие узлы.
    
3. **Порядок**: B-дерево имеет фиксированный порядок, который определяет максимальное количество ключей, которые могут содержаться в каждом узле. Этот порядок обычно выбирается таким образом, чтобы узлы могли эффективно помещаться в блоки памяти.
    
4. **Эффективность операций**: Операции вставки, удаления и поиска в B-дереве выполняются за время, пропорциональное логарифму от количества ключей в дереве. Это обеспечивает эффективность даже для больших баз данных.
    

B-дерево широко используется для индексации данных. Индексы B-дерева позволяют быстро находить и извлекать данные по ключу или диапазону значений. Они также обеспечивают эффективное выполнение операций сортировки и объединения данных.

Разделяют уровни B-дерева: 
- корневой узел (м.б. из нескольких сегментов) + ссылки на узлы промежуточного ур.
- промежуточные узлы (количество узлов +1 к кол-ву сегментов корневого) + ссылки ???
- узлы-листья (ссылки на следующий уровень отсутствуют)

Операция поиска в B-дереве выполняется за время O(t logt⁡ n), где t - это минимальная степень B-дерева, а n - количество ключей (или элементов) в дереве.

#### 25. Как оценить сложность выполняемого запроса? 
Оценка сложности выполнения запроса в базе данных часто связана с использованием стоимостного оптимизатора. Стоимостный оптимизатор использует статистические данные для предположений о стоимости различных способов выполнения запроса и выбирает наиболее эффективный план выполнения.

В PostgreSQL стоимостной оптимизатор использует два основных показателя для оценки сложности запроса:
1. **page_cost**: Этот параметр отражает стоимость ввода-вывода, измеряемую в единицах стоимости 1.0. Он указывает, сколько страниц нужно считать с диска для выполнения одного запроса (ввод-вывод). Чем выше значение page_cost, тем более дорогостоящим считается ввод-вывод.
    
2. **cpu_cost**: Этот параметр отражает стоимость операций процессора, измеряемую в единицах стоимости 1.0. Он указывает, сколько операций процессора требуется для выполнения запроса. Например, просмотр строки, считывание информации из одной записи в таблице и т. д. Чем выше значение cpu_cost, тем более дорогостоящим считается выполнение запроса процессором.
    
Статистические данные, используемые стоимостным оптимизатором, хранятся в специальной таблице `pg_class`. В этой таблице содержатся сведения о количестве строк и страниц в таблицах, индексах, а также другие статистические данные, которые помогают оптимизатору принимать решения о наилучшем плане выполнения запроса.

#### 26. Как узнать, сколько места занимает таблица в памяти? 
Для оценки размера таблицы в памяти вам нужно учитывать размер каждого поля в таблице и количество строк. В вашем примере, где таблица имеет 6 полей, вы можете рассчитать размер одной строки в байтах, а затем умножить его на количество строк, чтобы получить общий объем данных. Вот как это можно сделать:

1. **Определение размера каждого поля**:
    - Для целочисленных типов данных (например, BIGINT) размер будет фиксированным и зависит от используемого типа данных. Например, для BIGINT в PostgreSQL размер будет 8 байт.
    - Для символьных типов данных (например, VARCHAR) размер будет изменчивым и зависит от фактической длины строки.
      
2. **Определение размера одной строки**:
    - Пройдите по каждому полю в строке и определите его размер в байтах.
    - Сложите размеры каждого поля в строке, чтобы получить общий размер одной строки.
      
3. **Оценка размера всей таблицы**:
    - Умножьте размер одной строки на количество строк в таблице.

Например, предположим, у вас есть таблица с 6 полями, где каждое поле BIGINT (8 байт) и одно поле VARCHAR(50) (предположим, каждая строка занимает 100 байт). Если в таблице 1000 строк, то общий размер таблицы можно оценить следующим образом:
```scss
Размер одной строки = (8 байт * 6) + 100 байт = 148 байт
Общий размер таблицы = 148 байт * 1000 строк = 148 000 байт (или 148 Кб)
```

>[!INFO]
>Приблизительный размер строки `VARCHAR` в байтах с кодировкой UTF-8 может быть оценен как `длина строки в символах * 4` (если учитывать максимальный размер символа в UTF-8, который может составлять до 4 байтов). Однако этот расчет является приблизительным, так как размер символа может варьироваться в зависимости от его кода в таблице символов UTF-8.
###### Выражение `avg(bit_length(some_name) / 8)` позволяет нам получить средний размер текстового значения в байтах в столбце `some_name`:
1. `bit_length(some_name)`: Эта функция вычисляет количество битов в каждом значении столбца `some_name`. Это полезно для текстовых данных, так как каждый символ представляется некоторым количеством битов.
    
2. `bit_length(some_name) / 8`: Мы делим количество битов на 8, чтобы получить количество байтов. В стандартной кодировке UTF-8 каждый символ обычно занимает 1 байт, поэтому это даст нам приблизительный размер каждого значения в байтах.
    
3. `avg(...)`: Это агрегатная функция, которая вычисляет среднее значение. Мы применяем её к результатам вычисления размера в байтах для каждого значения столбца `some_name`.

#### 27. Методы сканирования таблиц 
1. **Полное сканирование (Full Table Scan)**:
    - При полном сканировании каждая строка таблицы проверяется, чтобы удовлетворить условия запроса. Это происходит без использования индексов, что может быть медленным для больших таблиц, но иногда неизбежным, особенно если таблица маленькая или запрос выбирает большую часть данных.
      
2. **Индексное сканирование (Index Scan)**:
    - При использовании индексов СУБД сканирует индекс для быстрого поиска и фильтрации строк, удовлетворяющих условиям запроса. Это может быть эффективным для запросов, которые фильтруют малую часть данных.
      
3. **Bitmap Index Scan**:
    - Это специализированный метод сканирования, который использует несколько индексов для создания "битовой карты" строк, удовлетворяющих определенным условиям. Затем эти битовые карты объединяются для фильтрации строк. Этот метод обычно используется для запросов с несколькими условиями.
      
4. **Использование предварительно вычисленных результатов**:
    - Иногда СУБД может сохранять результаты предыдущих запросов или промежуточных вычислений, чтобы избежать повторного вычисления при выполнении новых запросов. Это особенно полезно для запросов с повторяющимися или ресурсоемкими операциями.
      
5. **Использование параллельного сканирования**:
    - Некоторые СУБД поддерживают параллельное сканирование, при котором несколько процессов одновременно сканируют разные части таблицы, чтобы ускорить выполнение запросов.
      
6. **Использование кэширования**:
    - Кэширование предыдущих результатов запросов или данных таблицы может сократить время сканирования при повторном выполнении запросов.

Выбор метода сканирования зависит от многих факторов, включая размер таблицы, наличие индексов, тип запроса и характеристики аппаратного обеспечения.

#### 28. Что такое индексы? Какие они бывают? 
**Индексы** - это структура данных, которая ускоряет выполнение операций поиска и сортировки в базе данных. Они представляют собой отдельное хранилище, которое содержит отсортированные значения и указатели на строки таблицы. Индексы часто используются для ускорения запросов SELECT, WHERE и ORDER BY.

Таблицы без определенного кластерного индекса (о нем поговорим позже) хранятся в структуре кучи, что в сущности означает, что данные хранятся в виде неупорядоченного набора данных на каждой странице. Основное применение структуры кучи заключается в том случае, когда требуется быстрая производительность вставки в вашу таблицу. С использованием структуры кучи базе данных не нужно выяснять, куда вставить новые данные. Просто добавляются данные на последнюю страницу или, если она заполнена, выделяется новая страница и данные записываются на нее.
Запрос к таблице кучи может быть очень медленным, особенно если на таблице не определены не кластерные индексы. Без каких-либо индексов каждый запрос, обращающийся к таблице кучи, должен выполнять полное сканирование таблицы, и мы все знаем, насколько это дорого, если таблица большая.

##### Clustered Index
**Кластеризованный индекс** - один из основных типов индексов. Кластеризованный индекс хранит ключ индекса в структуре B-дерева вместе с фактическими данными таблицы в каждом листовом узле индекса. Наличие кластеризованного индекса на таблице устраняет структуру таблицы кучи, описанную в предыдущем разделе. Поскольку остальные данные таблицы (например, не ключевые столбцы) хранятся в листовых узлах структуры индекса, таблица может иметь только один кластеризованный индекс. 

(Когда говорится о том, что ключ индекса и фактические данные хранятся в каждом листовом узле индекса, это означает, что каждый лист дерева индекса содержит ключ индекса и соответствующие данные из таблицы. Например, если у нас есть индекс по возрасту, лист дерева будет содержать пары: "Возраст - Данные", где "Возраст" - это ключ индекса, а "Данные" - это фактические данные из таблицы, связанные с этим возрастом.)

**Основное преимущество** заключается **в увеличении производительности запросов.** 
**Недостаток** - накладные расходы при использовании DML операций (INSERT, UPDATE, DELETE). Если вы обновляете фактические значения ключей в индексе, в этом случае все связанные данные таблицы также должны быть перемещены, так как они хранятся в листовом узле записи индекса. В каждом случае будет влияние на производительность DML-запроса.

##### Non-clustered Index 
**Не кластеризованный индекс** - это еще один основной тип индекса, используемый в SQL Server. Подобно своему аналогу - кластеризованному индексу, столбцы ключа индекса хранятся в структуре B-дерева, за исключением того, что фактические данные не хранятся в листовых узлах. В этом типе индекса указатель на фактические данные таблицы хранится в листовом узле. Этот указатель может указывать на значение данных в кластеризованном индексе или в структуре кучи, в зависимости от того, как хранятся данные таблицы.

**Преимущества не кластеризованного индекса** подобны тем, что мы упомянули выше для кластеризованного индекса, основное преимущество - **увеличение производительности запросов.** Однако есть два отличия. Во-первых, вы можете определить несколько не кластеризованных индексов на одной таблице. Это позволяет вам индексировать разные столбцы, что может помочь запросам с разными столбцами в разделе WHERE, позволяя получать данные быстрее, а также в разделе ORDER BY для исключения необходимости в сортировке. Во-вторых, хотя накладные расходы на не кластеризованный индекс при операциях DML все же существуют, они меньше, чем у кластеризованного аналога.

Подобно кластеризованному индексу, основным недостатком не кластеризованного индекса является дополнительные накладные расходы, необходимые для поддержки индекса во время операций DML. Иногда может быть сложно сбалансировать производительность запросов, так как слишком большое количество не кластеризованных индексов на таблице(пока они помогают всем нашим SELECT-запросам), иногда действительно замедляют производительность DML.

##### Где и в виде чего хранятся индексы?
Реализация и хранение индексов зависит от конкретной СУБД, но в общих чертах:

1. **B-деревья (B-trees)**: Это один из наиболее распространенных типов индексов в SQL. B-деревья представляют собой сбалансированные деревья, где каждый узел содержит ключи и указатели на дочерние узлы или на фактические данные в таблице.
    
2. **Хеш-таблицы (Hash tables)**: Индексы на основе хеш-таблиц используют хеш-функции для быстрого поиска значений. Хеш-таблицы могут храниться в виде массивов с указателями на строки данных.
    
3. **Сортированные массивы**: Некоторые СУБД могут использовать сортированные массивы для хранения индексов, особенно для малых наборов данных или для определенных типов индексации.
    
4. **Битовые индексы (Bitmap indexes)**: Этот тип индекса используется для быстрого выполнения операций на множествах данных. Он представляет собой битовые карты, где каждый бит представляет наличие или отсутствие определенного значения в индексе.
    

В зависимости от типа индекса и требований к производительности, индексы могут храниться в памяти, на диске или в комбинации обоих. Обычно базы данных также используют кэширование для хранения часто используемых индексов в оперативной памяти для быстрого доступа.

##### В Postgres есть кластеризованный индекс?*
Да, в PostgreSQL есть понятие кластерного индекса, но оно немного отличается от того, как это понятие используется в некоторых других системах управления базами данных. 

Команда **CLUSTER** в PostgreSQL позволяет физически переупорядочить данные в таблице в соответствии с указанным индексом. Это означает, что данные, имеющие похожие значения индекса, физически хранятся рядом на диске. Однако это однократная операция: когда таблица впоследствии обновляется, изменения не кластеризуются. То есть не делается попытка хранить новые или обновленные строки в соответствии с порядком их индекса.

Также стоит отметить, что PostgreSQL не назначает индексы как кластерные по умолчанию. И даже если индекс номинирован как кластерный, PostgreSQL не автоматически упорядочивает данные таблицы в соответствии с кластерным индексом: для реорганизации данных таблицы необходимо использовать команду CLUSTER. 
```postgresql
CLUSTER [VERBOSE] table_name [USING index_name]
```

#### 29. Как и зачем создавать индекс? 
**Как создавать индекс?**
Для того, чтобы добавить индекс, необходимо использовать команду CREATE INDEX, что позволит указать имя индекса и определить таблицу и колонку или индекс колонки и определить, используется ли индекс по возрастанию или по убыванию.

Создание  индекса в таблице или представлении:
```mysql
CREATE [CLUSTERED / NONCLUSTERED] INDEX index_name ON table_name (column1, column2,...);
```

**Зачем создавать индекс?** 
Индексы используются для ускорения поиска и сортировки данных в базе данных. Они помогают снизить время выполнения запросов и повысить производительность системы. Индексы увеличивают скорость выполнения запросов SELECT, UPDATE и DELETE, так как SQL Server может использовать индексы для быстрого поиска и фильтрации данных. Они также улучшают производительность при сортировке данных, так как индексы позволяют быстро находить нужные записи и сортировать их.

Однако стоит отметить, что индексы замедляют процесс добавления и изменения записей (INSERT, UPDATE, DELETE), так как при каждом изменении данных индекс также должен быть обновлен. Поэтому важно найти баланс между количеством индексов и частотой обновления данных в таблице.

#### 30. Что такое селективность? 
Селективность в контексте баз данных и SQL относится к способности индекса эффективно фильтровать данные. Она измеряется как процент данных, которые индекс способен исключить из результатов поиска.

Селективность может быть высокой или низкой:
- **Высокая селективность** означает, что индекс способен исключить большую часть данных, что делает его очень эффективным. Например, если у вас есть уникальный индекс на столбце, каждое значение в этом столбце уникально, поэтому индекс может исключить 99% данных при поиске конкретного значения.
    
- **Низкая селективность** означает, что индекс исключает малую часть данных. Это может быть неэффективно, потому что базе данных придется просмотреть больше данных для выполнения запроса. Например, если у вас есть индекс на столбце пола (мужской/женский), он будет иметь низкую селективность, потому что каждое значение может исключить только около 50% данных.
    
Оптимизатор запросов базы данных использует селективность индекса, чтобы определить наиболее эффективный план выполнения запроса. Если индекс имеет высокую селективность, оптимизатор запросов может выбрать его для выполнения запроса. Если селективность низкая, оптимизатор запросов может решить выполнить полное сканирование таблицы, что может быть быстрее, чем использование индекса с низкой селективностью.

#### 31. Анализ выполнения запросов (если есть проблемы с производительностью) 
??

#### 32. Чем TRUNCATE отличается от DELETE? 
Если вам нужно быстро удалить все данные из таблицы и необходимость в возможности отката изменений отсутствует, рекомендуется использовать TRUNCATE. Если же нужно удалить определенные строки с возможностью отката изменений или вызвать триггеры на удаление, тогда следует использовать DELETE.

**TRUNCATE**:
- TRUNCATE является DDL (Data Definition Language) операцией, в то время как DELETE является DML (Data Manipulation Language) операцией.
- TRUNCATE удаляет все строки из таблицы, но не сохраняет эти строки в журнале транзакций (log). Поэтому TRUNCATE не может быть отменено (rollback).
- TRUNCATE также сбрасывает счетчик идентификатора (IDENTITY), если он есть на таблице, к начальному значению.
- TRUNCATE выполняется быстрее, чем DELETE, так как он не сохраняет логи и не вызывает триггеры на удаление.

**DELETE**:
- DELETE удаляет строки из таблицы с возможностью использования условий WHERE для определения, какие строки будут удалены.
- DELETE сохраняет удаленные строки в журнале транзакций, что позволяет их откатить (rollback) в случае необходимости.
- DELETE не сбрасывает счетчик идентификатора (IDENTITY).
- DELETE может вызывать триггеры на удаление, если они определены на таблице.

#### 33. Что такое хранимые процедуры? Для чего они нужны? 
**Хранимая процедура** — объект базы данных, представляющий собой набор SQL-инструкций, который хранится на сервере. Хранимые процедуры очень похожи на обыкновенные процедуры языков высокого уровня, у них могут быть входные и выходные параметры и локальные переменные, в них могут производиться числовые вычисления и операции над символьными данными, результаты которых могут присваиваться переменным и параметрам. В хранимых процедурах могут выполняться стандартные операции с базами данных (как DDL, так и DML). Кроме того, в хранимых процедурах возможны циклы и ветвления, то есть в них могут использоваться инструкции управления процессом исполнения. 

**Хранимые процедуры** позволяют повысить производительность, расширяют возможности программирования и поддерживают функции безопасности данных. В большинстве СУБД при первом запуске хранимой процедуры она компилируется (выполняется синтаксический анализ и генерируется план доступа к данным) и в дальнейшем её обработка осуществляется быстрее.

##### Преимущества хранимых процедур. Хранимые процедуры и безопасность. Хранимые процедуры и права доступа.
Хранимые процедуры представляют собой программные блоки, которые компилируются и сохраняются в базе данных для последующего выполнения. Они имеют несколько преимуществ:
1. **Увеличение производительности**: Хранимые процедуры могут уменьшить количество данных, передаваемых между клиентом и сервером, что приводит к снижению нагрузки на сеть и улучшению производительности приложения. Также они выполняются на сервере базы данных, что может ускорить обработку данных.
    
2. **Повторное использование кода**: Хранимые процедуры могут быть повторно использованы в различных частях приложения или даже в разных приложениях, что способствует уменьшению дублирования кода и улучшению его поддержки и расширяемости.
    
3. **Централизация бизнес-логики**: Хранимые процедуры позволяют централизовать бизнес-логику на стороне базы данных, что обеспечивает ее единообразное применение и поддержку.
    

Относительно безопасности и прав доступа:
1. **Ограничение доступа**: Базы данных обычно предоставляют механизмы для управления правами доступа к хранимым процедурам. Это позволяет администраторам баз данных устанавливать права доступа на уровне пользователей или ролей, чтобы контролировать, кто может выполнять, изменять или удалять процедуры.
    
2. **Изоляция данных**: Хранимые процедуры могут быть выполнены с привилегиями пользователя, который вызывает их, что способствует изоляции данных и предотвращает несанкционированный доступ к данным.
    
3. **Целостность данных**: Хранимые процедуры могут помочь обеспечить целостность данных, так как они могут быть написаны с использованием проверок, ограничений и других механизмов, чтобы гарантировать, что данные остаются в согласованном и корректном состоянии.

#### 34. Что такое представления (VIEW)? Для чего они нужны? 
**Представления (VIEW)** в SQL - это виртуальные таблицы, которые представляют собой результат выполнения SELECT-запроса. Они не хранят собственные данные, а предоставляют способ просмотра данных, которые физически находятся в других таблицах.

**Вот некоторые причины, по которым они могут быть полезны:**
1. **Сокрытие сложности**: Представления могут скрыть сложность запроса, объединяющего данные из нескольких таблиц, предоставляя простой интерфейс для работы с данными.
    
2. **Безопасность**: Представления могут ограничивать доступ к определенным столбцам или строкам таблицы, что обеспечивает дополнительный уровень безопасности.
    
3. **Удобство**: Представления могут упростить работу с данными, предоставляя более удобный способ доступа к данным, которые распределены по нескольким таблицам.
    
4. **Изоляция от изменений схемы**: Если схема базы данных изменяется (например, таблицы разделяются или объединяются), представления могут помочь изолировать приложения от этих изменений, поскольку запросы к представлениям могут оставаться неизменными.
    
Важно помнить, что, поскольку представления не хранят собственные данные, любые изменения в базовых таблицах немедленно отражаются в представлениях.


**Materialized View** - это тип представления, который физически хранит результаты запроса в базе данных. В отличие от обычных представлений, которые представляют собой просто сохраненные запросы и не хранят данные, Materialized View содержит результаты запроса на момент создания или последнего обновления.

Вот основные отличия Materialized View от обычного View:
1. **Хранение данных**: Materialized View хранит результаты запроса, в то время как обычное представление не хранит данные.
    
2. **Производительность**: Поскольку Materialized View хранит данные, они могут улучшить производительность запросов, которые используют эти данные. Однако это также может занять больше места на диске.
    
3. **Обновление данных**: Данные в Materialized View обновляются только при явном обновлении, в то время как данные в обычном представлении всегда актуальны, поскольку они получают данные непосредственно из базовых таблиц.
    
4. **Использование: Materialized View часто используются для ускорения запросов в больших и сложных базах данных, где выполнение базового запроса может занять много времени. !! хорошо работает для огромных баз**
    
Важно отметить, что поддержка и поведение Materialized View могут отличаться в разных системах управления базами данных. Некоторые системы могут автоматически обновлять Materialized View, в то время как другие требуют явного обновления.

#### 35. Что такое временные таблицы? Для чего они нужны? 
Временные таблицы в SQL - это специальные типы таблиц, которые автоматически удаляются после окончания сеанса или после выполнения определенного запроса. Они обычно используются для хранения промежуточных результатов, которые нужны только в рамках одного сеанса или запроса.

В основном используется оператор TEMP или TEMPROARY.

Вот некоторые причины, по которым вы можете использовать временные таблицы:
1. **Промежуточные результаты**: Если вам нужно выполнить сложный запрос, который включает в себя несколько этапов, вы можете использовать временные таблицы для хранения промежуточных результатов на каждом этапе.
    
2. **Оптимизация производительности**: Временные таблицы могут помочь улучшить производительность, особенно когда вы работаете с большими объемами данных. Вы можете использовать временные таблицы для хранения подмножества данных, что позволяет уменьшить количество обрабатываемых данных.
    
3. **Изоляция данных**: Временные таблицы изолированы от других сеансов, что означает, что данные, которые вы помещаете во временную таблицу, не будут видны другим пользователям.

Однако стоит помнить, что использование временных таблиц также имеет свои недостатки. Например, они могут занимать место в памяти и увеличивать нагрузку на систему. Поэтому важно использовать их обдуманно.

#### 36. Что такое транзакции? Расскажите про принципы ACID. 
**Транзакция**  — это группа логически объединённых последовательных операций по работе с данными, которая обрабатывается или отменяется целиком.

**ACID (от англ. atomicity, consistency, isolation, durability)** — это набор требований к транзакционной системе, обеспечивающий наиболее надёжную и предсказуемую её работу.

- **Атомарность (Atomicity):** Гарантирует, что никакая транзакция не будет зафиксирована в системе частично. Будут либо выполнены все её подоперации, либо не выполнено ни одной.
- **Согласованность (Consistency):** Транзакция, достигающая своего нормального завершения, сохраняет согласованность базы данных.
- **Изоляция (Isolation):** Во время выполнения транзакции параллельные транзакции не должны оказывать влияния на её результат.
- **Устойчивость/долговечность (Durability):** После того, как транзакция завершена, её эффекты становятся постоянными и продолжают существовать даже в случае сбоя системы.

#### 37. Расскажите про уровни изолированности транзакций. 
**Уровни изолированности транзакций** - это концепция в системах управления базами данных (СУБД), которая определяет, насколько транзакции открыты для чтения и изменения данных другими транзакциями. Стандарт SQL определяет четыре уровня изоляции транзакций:

1. **Read Uncommitted (Чтение незафиксированных данных)**: На этом уровне транзакции могут видеть незафиксированные изменения (т.е. “грязные” данные) других транзакций. Это самый низкий уровень изоляции, и он может привести к таким проблемам, как грязное чтение. (решает проблему lost update)
    
2. **Read Committed (Чтение зафиксированных данных)**: На этом уровне транзакция видит только зафиксированные изменения других транзакций. Это предотвращает грязное чтение, но все еще может привести к таким проблемам, как неповторяющиеся чтения или фантомные строки.
    
3. **Repeatable Read (Повторяемое чтение)**: На этом уровне транзакция может многократно читать одни и те же данные и видеть один и тот же результат, поскольку другие транзакции не могут изменить данные, которые читаются данной транзакцией. Это предотвращает неповторяющиеся чтения, но может привести к проблеме фантомных строк.
    
4. **Serializable (Сериализуемые)**: Это самый высокий уровень изоляции. Он гарантирует, что транзакции выполняются полностью изолированно друг от друга, как если бы они выполнялись последовательно, т.е. одна за другой. Это предотвращает все вышеупомянутые проблемы, но может привести к снижению производительности из-за блокировок.
    

Уровни изоляции транзакций помогают управлять балансом между производительностью (чем выше уровень изоляции, тем больше блокировок и тем ниже производительность) и точностью данных (чем выше уровень изоляции, тем меньше вероятность возникновения проблем с данными).

###### Четыре основные аномалии, которые могут возникнуть при недостаточной изоляции:
1. **Грязное чтение (Dirty Read)**: Это происходит, когда одна транзакция читает данные, измененные другой транзакцией, которая еще не была зафиксирована. Если эта другая транзакция впоследствии откатывается, то первая транзакция будет работать с данными, которые никогда не существовали.
    
2. **Неповторяющееся чтение (Non-Repeatable Read)**: Это происходит, когда во время выполнения одной транзакции другая транзакция изменяет данные, которые уже были прочитаны первой транзакцией. В результате первая транзакция, повторно прочитав данные, получает другой результат.
    
3. **Фантомное чтение (Phantom Read)**: Может возникнуть при выполнении параллельных транзакций в базе данных, когда одна транзакция видит новые строки данных, которые были вставлены или изменены другой транзакцией после начала выполнения первой транзакции.
    
4. **Потерянное обновление (Lost Update)**: Это происходит, когда две транзакции, которые оба читают и обновляют одну и ту же строку данных, перезаписывают обновления друг друга. В результате одно из обновлений теряется.

#### 38. Что такое нормализация и денормализация? Расскажите про 3 нормальные формы. 
##### **Нормализация**
**Нормализация** - это процесс разделения данных в базе данных на отдельные таблицы и установление связей между этими таблицами **для уменьшения избыточности и повышения целостности данных**. Цель нормализации - **избежать аномалий при обновлении, вставке и удалении данных**, а также уменьшить объем хранимой информации.

**Избыточность данных** – это ситуация, когда одни и те же данные хранятся в базе в нескольких местах (таблицах). Именно это и приводит к аномалиям

Нормализация обычно выполняется в несколько этапов, **представленных различными нормальными формами (НФ). Три наиболее распространенные нормальные формы:**

###### **Первая нормальная форма 1НФ**
1. В таблице НЕ должно быть дублирующих строк 
2. В каждой ячейке таблицы хранится атомарное значение (прим.: если у нас есть столбец с датой и временем, то они должны быть разделены в отдельных столбцах, а не храниться в одной ячейке в виде строки) 
3. В столбце хранятся данные одного типа 
4. Отсутствуют массивы и списки в любом виде

###### **Вторая нормальная форма 2НФ** 
1. Таблица должна находиться в 1НФ 
2. Таблица должна иметь ключ 
3. Все неключевые столбцы должны зависеть от полного ключа (в случае, если ключ составной). Это означает, что каждый неключевой столбец в таблице должен зависеть от каждой части составного ключа, а не от его части. Например, если у нас есть составной ключ, состоящий из полей "Номер заказа" и "ID продукта" в таблице "Строки заказа", то все неключевые столбцы (например, "Количество", "Цена") должны быть зависимы от обоих частей ключа, а не только от одной из них.

Исправляется это путем декомпозиции на два отношения, в которых неключевые атрибуты зависят от первичного ключа.

###### **Третья нормальная форма 3НФ**
1. Таблица должна находиться во 2НФ
2. Нет транзитивных зависимостей. Это означает, что неключевые атрибуты не должны зависить друг от друга. Все атрибуты в таблице должны зависеть только от **первичного ключа.**
![[Pasted image 20240421202604.png]]

##### Денормализация
**Денормализация базы данных** — это процесс осознанного приведения базы данных к виду, в котором она не будет соответствовать правилам нормализации. Обычно это необходимо для повышения производительности и скорости извлечения данных, за счет увеличения избыточности данных. 

При денормализации важно сохранить баланс между повышением скорости работы базы и увеличением риска появления противоречивых данных, между облегчением жизни программистам, пишущим Select'ы, и усложнением задачи тех, кто обеспечивает наполнение базы и обновление данных. Поэтому проводить денормализацию базы надо очень аккуратно, очень выборочно, только там, где без этого никак не обойтись. 

Если заранее нельзя подсчитать плюсы и минусы денормализации, то изначально необходимо реализовать модель с нормализованными таблицами, и лишь затем, для оптимизации проблемных запросов проводить денормализацию.

#### 39. Что такое TIMESTAMP?
MySQL
![[Pasted image 20240421203226.png]]

При указании даты допускается использовать любой знак пунктуации в качестве разделительного между частями разделов даты или времени. Также возможно задавать дату вообще без разделительного знака, слитно.(не рекомендуется)
###### Отличия DATETME от TIMESTEMP в MySQL:
1. **Формат хранения:**
   - DATETIME: Хранит дату и время в формате YYYY-MM-DD HH:MM:SS. Он не имеет компонента часового пояса и представляет собой конкретный момент времени без отношения к часовому поясу.
   - TIMESTAMP: Хранит дату и время, но включает информацию о часовом поясе.
2. **Взаимодействие с часовыми поясами:** 
   - TIMESTAMP изменяется в зависимости от текущих настроек часового пояса, в то время как DATETIME остается постоянным.

Также стоит помнить о существенном ограничении TIMESTAMP в диапазоне возможных значений от 1970-01-01 00:00:01 до 2038-01-19 03:14:07, что ограничивает его применении. Так, данный тип данных не подойдет для хранения дат рождения пользователей.

###### Отличия DATETME от TIMESTEMP в Postgres:
1. **Формат хранения:**
- TIMESTAMP: Хранит дату и время в формате YYYY-MM-DD HH:MM:SS. Он может быть с или без информации о часовом поясе. PostgreSQL поддерживает timestamptz как сокращение для timestamp with time zone.
- DATE: Это аналог DATETIME в MySQL. Он хранит только дату без времени.
Взаимодействие с часовыми поясами: TIMESTAMP в PostgreSQL может быть с информацией о часовом поясе или без нее.
2. **Размер хранения:**
- TIMESTAMP: Требует 8 байтов.
- DATE: Требует 4 байта.
3. **Диапазон дат:** 
   - TIMESTAMP и DATE в PostgreSQL имеют очень большой диапазон дат, который составляет от 4713 BC до 294276 AD.

Таким образом, в PostgreSQL TIMESTAMP и DATE обладают большей гибкостью по сравнению с MySQL, особенно когда речь идет о работе с часовыми поясами и большим диапазоном дат. 

#### 40. Расскажи про шардирование баз данных 
**Шардирование**(Sharding or Data Partitioning) - это в основном паттерн архитектуры баз данных, при котором мы разбиваем большой набор данных на более мелкие фрагменты (логические шарды), а затем храним/распределяем эти фрагменты на различных машинах/узлах базы данных (физические шарды).

Каждый фрагмент известен как "шард", и каждый шард имеет ту же структуру базы данных, что и исходная база данных.

**Горизонтальное шардирование** подразумевает разделение хранилища на **сгруппированные по каким-либо критериям строки**. В этом случае каждый шард **содержит одинаковые столбцы, но разные строки данных**. Этот вид шардирования позволяет распределить нагрузку на запись и чтение данных между различными серверами, за каждый из которых отвечает отдельная машина. Например, социальная сеть содержит базу данных пользователей. Чтобы ослабить нагрузку на сервер, разработчики горизонтально делят ее по шардам.

**Недостатки:**
- Согласование запросов, включающих несколько шардов, может быть нелегкой задачей. 
- Плохо управляемое распределение данных может привести к неравномерной нагрузке между шардами.
![[Pasted image 20240421215236.png]]

**Вертикальное шардирование** предполагает **разделение данных по столбцам**. В этом случае каждый шард содержит **часть столбцов и все связанные с ними строки данных**. Вертикальное шардирование может быть полезно, **когда некоторые столбцы используются чаще, а другие — реже**. Это вид шардирования **может использоваться в пределах одного сервера путем обновления оборудования.**
Например, у интернет-магазина накопился большой массив данных о товарах и покупателях. Чтобы увеличить производительность, можно разделить его на два шарда, один из которых вмещает записи о клиентах, а другой — о товарах.

**Недостатки:**
- Некоторые шарды могут стать горячими точками, если они содержат чрезмерно используемые колонки, что приведет к неравномерному распределению нагрузки. Это может привести к узким местам в производительности и снижению общей эффективности системы.
- Внесение изменений в схему, такие как добавление или удаление колонок, может быть более сложным в системе с вертикальным шардированием.
![[Pasted image 20240421215824.png]]

###### Дополнительно: методы шардинга
Существует несколько основных методов шардирования данных. Поскольку все они имеют свои особенности, выбор конкретного зависит от требований продукта. Рассмотрим самые распространенные:

- **Хешированное** — данные разбиваются на шарды на основе хеш-функции, которая принимает входные данные и возвращает хеш-значение. Это значение определяет, в какой шард будет помещена каждая запись данных. Метод позволяет достичь высокой производительности и отсутствия единой точки отказа, однако усложняет поиск данных.
    
- **Диапазонное** — данные разбиваются на шарды на основе диапазона значений. Значения могут присваиваться с помощью ключей (ключевое шардирование) и других атрибутов. Метод прост в реализации и позволяет быстрее находить информацию, чем при хешировании, однако может привести к несбалансированности базы.
    
- **Круговое** — шарды упорядочиваются в виде кольца и каждый из них ответственен за определенный диапазон значений. Запросы на данные маршрутизируются в соответствии с позицией шарда в кольце. Запросы распределяются равномерно, но при добавлении и удалении шардов требуется перераспределение данных.
    
- **Динамическое** — позволяет автоматически масштабировать хранилище в зависимости от текущей производительности и объема данных. Высокая гибкость такого хранилища требует надежную систему мониторинга и балансировки нагрузки, а также хорошо продуманную архитектуру базы данных.

#### 41. Как сделать запрос из двух баз? 
Допустим, у нас есть две таблицы: с товарами (есть поле owner_id, отвечающего за id владельца товара) и с пользователями (есть поле id). Мы хотим одним SQL-запросом получить все записи, причём чтобы в каждой была информация о пользователе и его одном товаре. В следующей записи была информация о том же пользователе и следующем его товаре. Когда товары этого пользователя закончатся, то переходить к следующему пользователю. Таким образом, мы должны соединить две таблицы и получить результат, в котором каждая запись содержит информацию о пользователе и об одном его товаре.
![[Pasted image 20240421220702.png]]

#### 42. Что такое триггер? 
**Триггер** - это специальный тип хранимой процедуры, который автоматически выполняется или активируется, когда происходит определенное событие в базе данных. Триггеры обычно используются для выполнения автоматических действий, таких как обновление, вставка или удаление записей в базе данных.

Триггер запускается сервером автоматически и все производимые им модификации данных рассматриваются как выполняемые в транзакции, в которой выполнено действие, вызвавшее срабатывание триггера. 

Момент запуска триггера определяется с помощью ключевых слов BEFORE (триггер запускается до выполнения связанного с ним события) или AFTER (после события).

Триггеры могут быть разделены на два основных типа:
1. **DML триггеры (Data Manipulation Language)**: Эти триггеры активируются при выполнении операций DML, таких как INSERT, UPDATE или DELETE.
    
2. **DDL триггеры (Data Definition Language)**: Эти триггеры активируются при выполнении операций DDL, таких как CREATE, ALTER или DROP.

#### 43. Что такое sql-injection (SQL инъекции)? 
**SQL-инъекция (SQL Injection)** - это форма атаки на веб-приложения, которая позволяет злоумышленнику выполнить вредоносный SQL-код в базе данных. Целью такой атаки является получение несанкционированного доступа к данным в базе данных или исполнение вредоносных операций.

**SQL-инъекция или SQLi** – уязвимость, которая позволяет атакующему использовать фрагмент вредоносного кода на языке структурированных запросов (SQL) для манипулирования базой данных и получения доступа к потенциально ценной информации.

Это тип атаки на веб-приложения, при которой злоумышленники используют слабые места в обработке пользовательского ввода для внедрения и выполнения вредоносного SQL кода на сервере базы данных.
###### Вот некоторые общие примеры SQL-инъекций:
1. **Получение скрытых данных:** Злоумышленник может изменить SQL-запрос для получения дополнительных результатов.
2. **Подрыв логики приложения:** Злоумышленник может изменить запрос так, чтобы он мешал логике приложения.
3. **UNION-атаки:** Злоумышленник может получить данные из разных таблиц базы данных.
4. **UNION-based SQL инъекция:** Объединение таблиц для получения данных.
5. **Time-based SQL инъекция:** Использование функции задержки для обнаружения данных.
6. **Blind SQL инъекция:** Выведение информации из базы данных без отображения результатов.
7. **Атака типа «1=1»:** Это простейший вид SQL-инъекции. Злоумышленник вводит в поле ввода условие, которое всегда верно, и это позволяет ему получить доступ к данным, на которые он не имеет прав

#### 44. Как выбрать между Statement, PreparedStatement и CallableStatement? 
1. **Statement**: Используйте `Statement`, когда у вас есть простой SQL-запрос без параметров. `Statement` хорошо подходит для выполнения статических SQL-запросов без входных параметров. 
   После выполнения, экземпляр Statement владеет ResultSet-ом, и другими данными о результате выполнения, такими как количество обновленных записей и сгенерированные ключи.
    
2. **PreparedStatement**: `PreparedStatement`(наследник `Statement`) используется, когда вам нужно выполнить один и тот же SQL-запрос множество раз с разными параметрами. Он предварительно компилирует SQL-запрос, что позволяет увеличить производительность при многократном использовании. 
   Входные параметры объявляются в SQL-выражении символом ?, следом сеттерами задаются их типы и значения.
   `PreparedStatement` также автоматически экранирует входные параметры, что помогает предотвратить SQL-инъекции. 
   (Например, если входные данные содержат символ одинарной кавычки (`'`), который в SQL используется для обозначения строки, неэкранированный символ `'` может привести к ошибке выполнения запроса или, что еще хуже, к SQL-инъекции. Однако экранированный символ, например, `\'`, будет интерпретирован базой данных как обычный символ одинарной кавычки внутри строки, а не как конец строки.)
    
3. **CallableStatement**: `CallableStatement`(наследник `PreparedStatement`) используется для вызова хранимых процедур в базе данных. Если у вас есть хранимая процедура, которую нужно вызвать из Java, используйте `CallableStatement`.

Экземпляры всех трех типов создаются методами интерфейса Connection.

#### 45. Какие классы вовлечены в соединение с базой данных? 
**DriverManager** управляет всеми JDBC-драйверами в приложении. Представляет набор 
статических методов. Лениво загружает системным class-loader доступные пред-сконфигурированные драйверы:
- По списку полных имен классов из property jdbc.drivers;
- Через Service Provider Interface

Менеджер занимается созданием экземпляра **Connection** – ключевого класса при работе с базой данных. Альтернативный менеджеру (и даже рекомендуемый) способ соединения с источником данных – ConnectionBuilder. Билдер получают из javax.sql.DataSource – формально это часть Java EE.

**Driver** – главный класс реализации JDBC-драйвера. Когда загружается class-loader-ом, сам регистрирует себя в DriverManager. Так что кроме предсконфигурированных драйверов, дополнительные можно загрузить просто вызвав Class.forName("some.Driver").

#### 46. Что можно делать с классом Connection? 
Класс **Connection** в Java предоставляет множество функций для работы с базой данных:

1. **Выполнение SQL-выражений:** Основная роль класса Connection - это выполнение SQL-выражений с помощью объектов Statement и получение результатов в виде ResultSet.

2. **Управление транзакциями:** Connection предоставляет средства для управления транзакциями. С его помощью можно создать Savepoint, откатиться к нему, закоммитить транзакцию, когда авто-коммит отключен.

3. **Получение мета-информации о базе данных:** Connection предоставляет мета-информацию о базе данных в целом (таблицы, поддерживаемая грамматика SQL, хранимые процедуры, возможности этого соединения и т.д.) в виде класса DatabaseMetaData.

4. **Настройка соединения:** В Connection можно задать множество настроек самого соединения, таких как уровень изоляции транзакций, режим авто-коммита, ключи шардирования и многое другое.

5. **Маппинг типов данных SQL в Java-типы:** Маппинг типов данных SQL в Java-типы задается в Connection с помощью свойства typeMap.

#### 47. Какая разница между @ElementCollection, @OneToMany и @ManyToMany? 
Все эти аннотации – часть **JPA** (Java Persistence API). С их использованием мы регулярно сталкиваемся в реализациях JPA, таких как Hibernate. 
Когда в базу данных сохраняется сущность, в которой есть поле-коллекция, это поле обязано быть помеченным одной из аннотаций. 

**@OneToMany** и **@ManyToMany** хранят вложенные объекты как отдельные полноценные сущности – для них действуют всё те же требования, которые JPA выдвигает для всех @Entity классов. Каждая из аннотаций отвечает за свое отношение. 

**@ElementCollection** создает коллекцию встраиваемых классов. Применять её можно только на коллекции, тип элементов которых помечен @Embeddable, или входит в список стандартных встраиваемых классов (обертки примитивов, строки, даты, и т.д.). 
На уровне хранения в реляционной базе, для @ElementCollection будет также создана отдельная таблица. Технически она будет находиться в отношении one-to-many. 
Коллекция, аннотированная как `@ElementCollection`, будет выглядеть встроенной в Java коде. Элементы такой коллекции не имеют собственных идентификаторов и ими нельзя манипулировать отдельно от родительской сущности. Это отличает их от сущностей, связанных через `@OneToMany` или `@ManyToMany`, которые являются независимыми сущностями с собственными идентификаторами. Единственное, чем такая коллекция отличается от встроенного поля-примитива – её можно загружать лениво (включено по умолчанию).

#### 48. SQL или NoSQL
Выбор между SQL и NoSQL зависит от множества факторов, включая требования вашего приложения, характеристики данных, производительные ограничения и предпочтения разработчиков. Вот некоторые ключевые различия между ними, которые могут помочь в принятии решения:

###### SQL (реляционные базы данных):
1. **Структурированные данные**: SQL базы данных работают с данными, организованными в табличной форме со строгими схемами.
2. **ACID-совместимость**: SQL базы данных обеспечивают ACID-совместимость (атомарность, согласованность, изолированность, долговечность), что гарантирует надежность и целостность данных.
3. **Мощные языки запросов**: SQL предоставляет мощные языки запросов, такие как SQL, для выполнения сложных операций на данных.
4. **Гибкость отношений**: Реляционные базы данных хорошо подходят для данных с жесткими отношениями, такими как транзакционные данные и связанные данные.
5. **Поддержка многих соединений**: SQL базы данных обычно поддерживают множество одновременных соединений и масштабируются вертикально.

###### NoSQL (нереляционные базы данных):
1. **Гибкая схема**: NoSQL базы данных предлагают гибкую схему данных, что позволяет хранить разнородные данные без жестких схем.
2. **Горизонтальное масштабирование**: Многие NoSQL базы данных легко масштабируются горизонтально, что позволяет обрабатывать большие объемы данных и обеспечивает высокую доступность.
3. **Высокая производительность**: NoSQL базы данных часто предлагают высокую производительность и низкую задержку при выполнении операций на данных.
4. **Различные модели данных**: NoSQL базы данных поддерживают различные модели данных, такие как документы, ключ-значение, столбцы и графы, что позволяет выбрать подходящую модель для конкретных потребностей.
5. **Гибкость развертывания**: NoSQL базы данных могут быть легко развернуты в облаке и могут быть более гибкими в управлении и обслуживании.

В общем, выбор между SQL и NoSQL зависит от конкретных требований вашего проекта. Если ваши данные имеют жесткие отношения и высокие требования к целостности, то SQL базы данных могут быть более подходящим выбором. В то же время, если вам нужна гибкость схемы, масштабируемость и высокая производительность, то NoSQL базы данных могут быть предпочтительны.

#### 49. CAP theorem
Теорема CAP (или теорема Брюера) — это важное понятие в области распределенных систем. Она утверждает, что в любой распределенной системе можно обеспечить только две из трех следующих гарантий:
1. **Консистентность (Consistency)**: Каждый запрос к распределенной системе получает самое последнее обновление или ошибку. В контексте CAP, консистентность означает, что все узлы в системе видят одинаковые данные одновременно.
    
2. **Доступность (Availability)**: Каждый запрос к распределенной системе успешно завершается (без ошибки), несмотря на отказы некоторых узлов в системе. В контексте CAP, доступность означает, что система всегда готова к принятию запросов.
    
3. **Устойчивость к разделению (Partition Tolerance)**: Распределенная система продолжает функционировать нормально, даже если сеть разделена на части, и узлы не могут обмениваться сообщениями друг с другом. В контексте CAP, устойчивость к разделению означает, что система может продолжать работу даже в случае сбоев сети или потери связи между узлами.

Теорема CAP утверждает, что невозможно одновременно обеспечить все три свойства - консистентность, доступность и устойчивость к разделению - в распределенной системе в случае ее разделения на части. Вместо этого разработчики систем должны выбирать, какие два из этих свойств им наиболее важны, и оптимизировать свою систему с учетом этих приоритетов.

##### Postgres каким 2 условиям соответствует из CAP теоремы?
PostgreSQL, как большинство RDBMS, обычно обеспечивает согласованность (С) и доступность (A) из CAP-теоремы. Это означает, что база данных всегда предоставляет последние данные и всегда доступна для чтения и записи