#### 1. Что такое «шаблон/ проектирования»? 
**Паттерн проектирования** — это часто встречающееся решение определённой проблемы при проектировании архитектуры программ. 
В отличие от готовых функций или библиотек, паттерн нельзя просто взять и скопировать в программу. Паттерн представляет собой не какой-то конкретный код, а **общую концепцию решения той или** иной проблемы, которую нужно будет ещё подстроить под нужды вашей программы.

Паттерны часто путают с алгоритмами, ведь оба понятия описывают типовые решения каких-то известных проблем. Но если алгоритм — это чёткий набор действий, то паттерн — это высокоуровневое описание решения, реализация которого может отличаться в двух разных программах.

#### 2. Приведите примеры основных паттернов проектирования. 
1. **Делегирование (Delegation pattern)**: Объект делегирует выполнение определенной работы другому объекту, сохраняя при этом свою собственную ответственность.
    
2. **Функциональный дизайн (Functional design)**: Проектирование программного обеспечения с акцентом на функциональные принципы, где каждая сущность выполняет только одну обязанность с минимальным воздействием на другие.
    
3. **Неизменяемый интерфейс (Immutable interface)**: Создание объектов, чье состояние не может быть изменено после создания. Это обеспечивает предсказуемость и упрощает обнаружение ошибок.
    
4. **Интерфейс (Interface)**: Определяет структуру сущности и ее возможные действия. Используется для описания контрактов между компонентами программы.
    
5. **Интерфейс-маркер (Marker interface)**: Интерфейс, не имеющий методов, но служащий для пометки или классификации объектов. Часто заменяется атрибутами или аннотациями в современных языках программирования.
    
6. **Контейнер свойств (Property container)**: Паттерн, позволяющий добавлять дополнительные свойства к сущности, используя внутренний контейнер, вместо расширения объекта новыми свойствами.
    
7. **Канал событий (Event channel)**: Создает централизованный канал для передачи событий между различными компонентами системы. Использует модель издатель-подписчик для передачи событий. 
   Обеспечивает механизм централизованной коммуникации между компонентами системы путем передачи событий через специальный канал. Этот канал предоставляет абстракцию для отправки и получения событий между различными частями приложения, а также между самими компонентами.

#### 3. Назовите основные характеристики паттернов. 
Описания паттернов обычно очень формальны и чаще всего состоят из таких пунктов:

1. **Проблема**: Описывается конкретная проблема, с которой сталкиваются разработчики при проектировании программного обеспечения.
    
2. **Мотивация**: Объясняется, почему данная проблема важна и почему необходимо применять определенный паттерн для ее решения.
    
3. **Структура классов**: Представляется архитектура классов или компонентов, которые составляют решение проблемы.
    
4. **Пример на одном из языков программирования**: Демонстрируется пример кода, реализующего данный паттерн на конкретном языке программирования.
    
5. **Особенности реализации в различных контекстах**: Рассматриваются варианты и нюансы применения паттерна в различных сценариях и окружениях разработки.
    
6. **Связи с другими паттернами**: Обсуждаются взаимосвязи данного паттерна с другими паттернами проектирования и возможные комбинации их использования.

Такой формализм в описании позволил создать обширный каталог паттернов, проверив каждый из них на состоятельность.

#### 4. Назовите три основные группы паттернов (классификация) 
1. **Порождающие паттерны (Creational Patterns)**: Эти паттерны отвечают за механизм создания объектов. Они помогают создавать объекты таким образом, чтобы это было гибко, удобно и не связывалось с конкретными классами.

Примеры порождающих паттернов включают в себя "Одиночка" (Singleton), "Фабричный метод" (Factory Method), "Строитель" (Builder) и "Прототип" (Prototype).

2. **Структурные паттерны (Structural Patterns)**: Эти паттерны касаются композиции объектов и классов. Они помогают организовать объекты таким образом, чтобы изменения в одной части системы не влияли на другие части.

Примеры структурных паттернов включают в себя "Адаптер" (Adapter), "Декоратор" (Decorator), "Мост" (Bridge) и "Фасад" (Facade).

3. **Поведенческие паттерны (Behavioral Patterns)**: Эти паттерны определяют взаимодействие между объектами и ответственны за эффективную коммуникацию и распределение обязанностей между ними.

Примеры поведенческих паттернов включают в себя "Наблюдатель" (Observer), "Стратегия" (Strategy), "Цепочка обязанностей" (Chain of Responsibility) и "Команда" (Command).

Самые **низкоуровневые** и простые паттерны — это **идиомы**. Они не универсальны, поскольку применимы только в рамках одного языка программирования. 
Самые **универсальные** — это **архитектурные паттерны**, которые можно реализовать практически на любом языке. Они нужны для проектирования всей программы, а не отдельных её элементов.

###### Примеры идиом в Java:
1. Вызов equals() для строкового литерала или известного объекта
2. Использование entrySet для перебора HashMap
3. Использование Enum в качестве синглтона
4. Использование Arrays.asList() для инициализации Collection или List.of(), Set.of()
5. Проверка условия wait() в цикле
6. Перехват CloneNotSupportedException и возврат экземпляра SubClass
7. Использование интерфейсов везде, где это возможно
8. Использование Iterator для обхода списка
9. Написание кода с учетом внедрения зависимостей
10. Закрытие потоков в блоке try-with-resources

https://javarush.com/groups/posts/4108-kofe-breyk-222-10-idiom-java-kotorihe-dolzhen-znatjh-kazhdihy-razrabotchik

#### 5. Расскажите про паттерн Одиночка (Singleton). 
 **Паттерн Одиночка** (или **Singleton**) — это один из популярных порождающих паттернов проектирования в Java. Его цель — гарантировать, что у класса есть **только один экземпляр**, и предоставить к нему **глобальную точку доступа**.

**Признаки применения паттерна:** Одиночку можно определить по статическому создающему методу, который возвращает один и тот же объект.

Для реализации одноэлементного шаблона у нас есть разные подходы, но все они имеют следующие общие концепции. 
- Private конструктор для ограничения создания экземпляра класса из других классов. Private static variable of the same class that is the only instance of the class. 
- Private static переменная того же класса, который является единственным экземпляром класса. 
- Public static метод, который возвращает экземпляр класса, это глобальная точка доступа для внешнего мира, чтобы получить экземпляр одноэлементного класса.
```java
public class Singleton {
    private static Singleton instance;

    private Singleton() {
    }

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }

    public void showMessage() {
        System.out.println("Пример приветствия из синглтона!");
    }
}
```

#### 6. Почему Singleton называют анти-паттерном? 
1. **Сложность тестирования:** Использование синглтона может затруднить тестирование кода, так как он создает глобальное состояние, которое может влиять на другие тесты. Это может привести к нестабильности и сложностям в создании независимых тестовых случаев.
   Поэтому, если нужно протестировать какой-то класс, то нужно вместе с ним тестировать и Singleton, но это ещё полбеды. Состояние «Одиночки» может меняться, что порождает следующие проблемы: 
   -  Порядок тестов теперь имеет значение
   - Тесты могут иметь нежелательные сторонние эффекты, порождённые Singleton’ом 
   - Вы не можете запускать несколько тестов параллельно 
   - Несколько вызовов одного и того же теста могут приводить к разным результатам.
     
2. **Зависимость от глобального состояния:** Синглтон создает глобальное состояние, которое может быть доступно из любой части программы. Это может привести к проблемам с управлением состоянием и усложнению отладки и поддержки кода.
   
3. **Сложность расширения:** Использование синглтона может затруднить расширение функциональности, так как он предоставляет только один экземпляр класса. Если вам потребуется создать другую версию класса или добавить новые возможности, вам придется изменять сам синглтон.
   
4. **Нарушение принципа единственной ответственности:** Синглтон может нарушать принцип единственной ответственности, так как он отвечает не только за создание экземпляра класса, но и за предоставление глобальной точки доступа к этому экземпляру. Это может привести к нарушению модульности и усложнению понимания кода.

5. **Поток-небезопасность:** Один из популярных вариантов реализации Singleton содержит ленивую инициализацию. Это значит, что объект класса создаётся не в самом начале, а лишь когда будет получено первое обращение к нему. Однако здесь начинаются проблемы с потоками, которые могут создавать несколько различных объектов. Происходит это примерно так:
	- Первый поток обращается к `getInstance()`, когда объект ещё НЕ создан.
	- В это время второй тоже обращается к этому методу, пока первый ещё не успел создать объект, и сам создаёт его.
	- Первый поток создаёт ещё один, второй, экземпляр класса.
	  
	  Разумеется, можно просто пометить метод как `synchronized`, и эта проблема исчезнет. Проблема заключается в том, что, сохраняя время на старте программы, мы теперь будем терять его каждый раз при обращении к Singleton’у из-за того, что метод синхронизирован, а это очень дорого, если к экземпляру приходится часто обращаться. Единственный раз, когда свойство `synchronized` действительно требуется — первое обращение к методу. Есть два способа решить эту проблему.
	  
	  Первый — пометить как `synchronized` не весь метод, а только блок, где создаётся объект. Не забывайте, что это нельзя использовать в версии Java ниже, чем 1.5, потому что там используется иная модель памяти. Также не забудьте пометить поле `instance` как `volatile`.
	  
	  Второй путь — использовать паттерн «Lazy Initialization Holder». Это решение основано на том, что вложенные классы не инициализируются до первого их использования.
	  ``` java
	  public class Singleton {
    // Приватный конструктор, чтобы предотвратить создание экземпляров извне класса
    private Singleton() {}

    // Статический метод для получения экземпляра класса
    public static Singleton getInstance() {
        return SingletonHolder.INSTANCE;
    }

    // Вложенный статический класс-держатель для инициализации экземпляра синглтона
    private static class SingletonHolder {
        // Статическое поле для хранения единственного экземпляра класса
        private static final Singleton INSTANCE = new Singleton();
    }
}
```

В целом, синглтон может быть полезным в некоторых случаях, но его использование должно быть оправдано и осознанным. Рекомендуется обдумать альтернативные подходы и рассмотреть другие паттерны проектирования, прежде чем применять синглтон.

#### 7. Расскажите про паттерн Строитель (Builder). 
**Паттерн Строитель (Builder)** — это один из порождающих паттернов проектирования, который используется для создания сложных объектов, разделенных на несколько этапов.  С помощью этого паттерна клиент может пошагово задавать параметры объекта, не заботясь о деталях реализации.

**Суть паттерна**
Паттерн Строитель позволяет вынести конструирование объекта за пределы его собственного класса, поручив это дело отдельным объектам, которые следует называть строителями. Строитель предлагает разбить процесс конструирования объекта на отдельные шаги. Причём не нужно запускать все шаги, а только те, что нужны для производства объекта определённой конфигурации. Промежуточный результат всегда остаётся защищён.

Представим, что мы хотим создать объект Дом. Чтобы построить стандартный дом, нужно поставить 4 стены, установить двери, вставить пару окон и положить крышу. Но что, если вы хотите дом побольше и светлее, имеющий сад, бассейн и прочее добро? Самое простое решение — расширить класс Дом, создав подклассы для всех комбинаций параметров дома. Однако такой подход приведет к громадному количеству классов, что усложнит программу.

Вместо этого мы можем использовать паттерн Строитель. Мы вынесем процесс конструирования дома в отдельный класс-строитель. Этот строитель будет иметь методы для пошагового создания дома: построить стены, установить двери, вставить окна, положить крышу и т. д. При этом мы можем выбирать только те шаги, которые соответствуют конкретной конфигурации дома. Например, для деревянного дома мы вызовем методы “построить стены из дерева” и “вставить окна из стекла”, а для каменного — “построить стены из камня” и "вставить окна из железа".

Вы можете пойти дальше и выделить вызовы методов строителя в отдельный класс, называемый **директором**. В этом случае **директор** будет задавать порядок шагов строительства, а **строитель** — выполнять их. 
**Директор** полезен, если у вас есть несколько способов конструирования продуктов, отличающихся порядком и наличием шагов конструирования. В этом случае вы сможете объединить всю эту логику в одном классе.
###### Когда применять данный паттерн?

1. **Когда у объекта слишком много параметров конструктора:** Если у вас есть класс с множеством параметров конструктора, особенно если многие из них необязательные, использование паттерна Строитель может упростить процесс создания объекта, предоставляя методы для пошагового задания параметров.
    
2. **Когда нужно создавать объекты с различными конфигурациями:** Паттерн Строитель позволяет создавать объекты с различными конфигурациями, изменяя набор параметров или порядок их задания. Это особенно полезно, если у вас есть объекты с множеством возможных вариантов конфигурации.
	   
3. **Когда нужно скрыть сложность создания объекта:** Паттерн Строитель позволяет скрыть сложность создания объекта от клиентского кода, предоставляя простой интерфейс для его конструирования.
    
4. **Когда нужно обеспечить иммутабельность создаваемого объекта:** Если вы хотите, чтобы созданный объект был неизменяемым (immutable), паттерн Строитель может быть полезным, поскольку вы можете гарантировать, что все необходимые параметры будут установлены в момент создания объекта.

Строитель конструирует объекты пошагово, а не за один проход. Более того, шаги строительства можно выполнять рекурсивно. А без этого не построить древовидную структуру, вроде Компоновщика. 
Строитель не позволяет посторонним объектам иметь доступ к конструируемому объекту, пока тот не будет полностью готов. Это предохраняет клиентский код от получения незаконченных «битых» объектов.

Перед началом строительства клиент должен связать определённого строителя с директором. Это можно сделать либо через конструктор, либо через сеттер, либо подав строителя напрямую в строительный метод директора.
###### Шаги реализации:
- Убедитесь в том, что создание разных представлений объекта можно свести к общим шагам. 
- Опишите эти шаги в общем интерфейсе строителей. 
- Для каждого из представлений объекта-продукта создайте по одному классу-строителю и реализуйте их методы строительства. 
- Подумайте о создании класса директора. Его методы будут создавать различные конфигурации продуктов, вызывая разные шаги одного и того же строителя. 
- Клиентский код должен будет создавать и объекты строителей, и объект директора.
- Результат строительства можно вернуть из директора, но только если метод возврата продукта удалось поместить в общий интерфейс строителей. Иначе вы жёстко привяжете директора к конкретным классам строителей.

#### 8. Расскажите про паттерн Фабричный метод (Factory Method). 
**Фабричный метод (Factory Method)** является одним из наиболее распространенных порождающих паттернов проектирования. **Он позволяет создавать объекты определенного типа, но делегирует сам процесс создания подклассам, позволяя подклассам изменять тип создаваемых объектов.**

Основная идея паттерна Фабричный метод заключается в том, чтобы определить метод, который отвечает за создание объектов внутри абстрактного класса или интерфейса, а затем реализовать этот метод в конкретных подклассах. Таким образом, различные подклассы могут создавать разные типы объектов, соответствующие их особенностям.


Представим, у нас есть кофейня, и мы хотим создавать разные виды кофе. Вместо того чтобы создавать кофе напрямую с помощью оператора `new`, мы определяем абстрактный метод `createCoffee()` в базовом классе (фабрике). Подклассы (например, `Americano`, `Cappuccino`, `Espresso`) реализуют этот метод, чтобы создавать конкретные виды кофе.
```java
// Абстрактный класс кофе
abstract class Coffee {
    public abstract void grindCoffee();
    public abstract void makeCoffee();
    public abstract void pourIntoCup();
}

// Конкретные виды кофе
class Americano extends Coffee {
    // Реализация методов
}

class Cappuccino extends Coffee {
    // Реализация методов
}

// Фабрика для создания кофе
class CoffeeFactory {
    public Coffee createCoffee(CoffeeType type) {
        switch (type) {
            case AMERICANO:
                return new Americano();
            case CAPPUCCINO:
                return new Cappuccino();
            // Добавьте другие виды кофе по аналогии
            default:
                throw new IllegalArgumentException("Unknown coffee type");
        }
    }
}

// Перечисление видов кофе
enum CoffeeType {
    AMERICANO,
    CAPPUCCINO
}
```

###### Когда применять?
1. **Когда необходимо делегировать создание объектов подклассам:** Если у вас есть иерархия классов и каждый подкласс должен создавать свои собственные объекты, паттерн Фабричный метод позволяет делегировать этот процесс подклассам, избегая создания объектов в базовом классе.
    
2. **Когда тип создаваемого объекта определяется подклассами:** Если тип создаваемого объекта зависит от конкретного подкласса, например, в зависимости от параметров или состояния объекта, паттерн Фабричный метод позволяет каждому подклассу решать, какой тип объекта создавать.
    
3. **Когда нужно расширять функциональность создания объектов:** Паттерн Фабричный метод позволяет добавлять новые типы объектов, не изменяя существующий код. Новые подклассы могут реализовать фабричный метод для создания новых типов объектов, что обеспечивает расширяемость и гибкость.
    
4. **Когда требуется инверсия зависимостей:** Использование фабричного метода позволяет инвертировать зависимости, разрывая прямую зависимость между клиентским кодом и создаваемыми объектами. Клиентский код зависит только от абстрактного интерфейса фабрики, а не от конкретных классов.
    
5. **Когда нужно соблюсти принцип открытости/закрытости:** Паттерн Фабричный метод способствует соблюдению принципа открытости/закрытости, так как новые типы объектов могут быть добавлены без изменения существующего кода, только за счет создания новых подклассов и реализации фабричного метода.
   
Представьте, сколько действий нужно совершить, чтобы повторно использовать существующие объекты: 
- Сначала вам следует создать общее хранилище, чтобы хранить в нём все создаваемые объекты.
- При запросе нового объекта нужно будет заглянуть в хранилище и проверить, есть ли там неиспользуемый объект. А затем вернуть его клиентскому коду. 
- Но если свободных объектов нет — создать новый, не забыв добавить его в хранилище. Весь этот код нужно куда-то поместить, чтобы не засорять клиентский код.

Самым удобным местом был бы конструктор объекта, ведь все эти проверки нужны только при создании объектов. Но, увы, конструктор всегда создаёт новые объекты, он не может вернуть существующий экземпляр. 
Значит, нужен другой метод, который бы отдавал как существующие, так и новые объекты. Им и станет фабричный метод.

###### Шаги реализации:
- Приведите все создаваемые продукты к общему интерфейсу 
- В классе, который производит продукты, создайте пустой фабричный метод. В качестве возвращаемого типа укажите общий интерфейс продукта. 
- Найдите все участки кода класса, создающие продукты. Поочерёдно замените эти участки вызовами фабричного метода, перенося в него код создания различных продуктов. 
- В фабричный метод, возможно, придётся добавить несколько параметров, контролирующих, какой из продуктов нужно создать.
- Для каждого типа продуктов заведите подкласс и переопределите в нём фабричный метод. Переместите туда код создания соответствующего продукта из суперкласса.
- Если создаваемых продуктов слишком много для существующих подклассов создателя, вы можете подумать о введении параметров в фабричный метод, которые позволят возвращать различные продукты в пределах одного подкласса.
- Если после всех перемещений фабричный метод стал пустым, можете сделать его абстрактным. Если в нём что-то осталось — не беда, это будет его реализацией по умолчанию

#### 9. Расскажите про паттерн Абстрактная фабрика (Abstract Factory). 
**Абстрактная фабрика** — это порождающий паттерн проектирования, который предоставляет интерфейс для создания семейств взаимосвязанных или взаимозависимых объектов, без привязки к их конкретным классам.

Нужен такой способ создавать объекты продуктов, чтобы они сочетались с другими продуктами того же семейства. Это важно, так как клиенты расстраиваются, если получают несочетающуюся мебель.

**Проблема:**
Для начала паттерн Абстрактная фабрика предлагает выделить общие интерфейсы для отдельных продуктов, составляющих семейства. Так, все вариации кресел получат общий интерфейс Кресло, все диваны реализуют интерфейс Диван и так далее.

**Решение:**
Для начала паттерн Абстрактная фабрика предлагает выделить общие интерфейсы для отдельных продуктов, составляющих семейства. Так, все вариации кресел получат общий интерфейс Кресло, все диваны реализуют интерфейс Диван и так далее.

Далее вы создаёте абстрактную фабрику — общий интерфейс, который содержит методы создания всех продуктов семейства (например, создатьКресло, создатьДиван и создатьСтолик). Эти операции должны возвращать абстрактные типы продуктов, представленные интерфейсами, которые выделили ранее — Кресла, Диваны и Столики.

Клиентский код должен работать как с фабриками, так и с продуктами только через их общие интерфейсы. Это позволит подавать в классы любой тип фабрики и производить любые продукты, ничего не ломая. 
Осталось прояснить последний момент: кто создаёт объекты конкретных фабрик, если клиентский код работает только с интерфейсами фабрик? Обычно программа создаёт конкретный объект фабрики при запуске, причём тип фабрики выбирается, исходя из параметров окружения или конфигурации.

###### Когда применять?
1. Когда бизнес-логика программы должна работать с разными видами связанных друг с другом продуктов, не завися от конкретных классов продуктов. 
   Абстрактная фабрика скрывает от клиентского кода подробности того, как и какие конкретно объекты будут созданы. Но при этом клиентский код может работать со всеми типами создаваемых продуктов, поскольку их общий интерфейс был заранее определён.
2. Когда в программе уже используется Фабричный метод, но очередные изменения предполагают введение новых типов продуктов. 
   В хорошей программе каждый класс отвечает только за одну вещь. Если класс имеет слишком много фабричных методов, они способны затуманить его основную функцию. Поэтому имеет смысл вынести всю логику создания продуктов в отдельную иерархию классов, применив абстрактную фабрику.

###### Шаги реализации:
 - Создайте таблицу соотношений типов продуктов к вариациям семейств продуктов.
 - Сведите все вариации продуктов к общим интерфейсам.
 - Определите интерфейс абстрактной фабрики. Он должен иметь фабричные методы для создания каждого из типов продуктов. 
 - Создайте классы конкретных фабрик, реализовав интерфейс абстрактной фабрики. Этих классов должно быть столько же, сколько и вариаций семейств продуктов. 
 - Измените код инициализации программы так, чтобы она создавала определённую фабрику и передавала её в клиентский код. 
 - Замените в клиентском коде участки создания продуктов через конструктор вызовами соответствующих методов фабрики.

#### 10. Расскажите про паттерн Прототип (Prototype). 
**Прототип (Prototype)** — это порождающий паттерн проектирования, который позволяет создавать новые объекты путем клонирования существующих экземпляров, вместо создания объектов с нуля.

Основная идея паттерна Прототип заключается в том, чтобы использовать готовый объект (прототип) как основу для создания новых объектов. При этом сам процесс создания нового объекта основывается на копировании (клонировании) существующего объекта.

**Проблема** 
У вас есть объект, который нужно скопировать. Как это сделать? Нужно создать пустой объект такого же класса, а затем поочерёдно скопировать значения всех полей из старого объекта в новый. Но не каждый объект удастся скопировать таким образом, ведь часть его состояния может быть приватной, а значит недоступной для остального кода. 
Есть и другая проблема. Копирующий код станет зависим от классов копируемых объектов. Чтобы перебрать все поля объекта, нужно привязаться к его классу. Из-за этого нельзя копировать объекты, зная только их интерфейсы, а не конкретные классы.

**Решение** 
Паттерн Прототип поручает создание копий самим копируемым объектам. Он вводит общий интерфейс для всех объектов, поддерживающих клонирование. Это позволяет копировать объекты, не привязываясь к их конкретным классам. Обычно такой интерфейс имеет всего один метод clone().
Реализация этого метода в разных классах очень схожа. Метод создаёт новый объект текущего класса и копирует в него значения всех полей собственного объекта. Так получится скопировать даже приватные поля, так как большинство языков программирования разрешает доступ к приватным полям любого объекта текущего класса.

Объект, который копируют, называется прототипом (отсюда и название паттерна). Когда объекты программы содержат сотни полей и тысячи возможных конфигураций, прототипы могут служить своеобразной альтернативой созданию подклассов. 
В этом случае все возможные прототипы заготавливаются и настраиваются на этапе инициализации программы. Потом, когда программе нужен новый объект, она создаёт копию из приготовленного прототипа.

###### Кода применять?
1. **Когда ваш код не должен зависеть от классов копируемых объектов.** 
   Такое часто бывает, если ваш код работает с объектами, поданными извне через какой-то общий интерфейс. Вы не можете привязаться к их классам, даже если бы хотели, поскольку их конкретные классы неизвестны. 
   Паттерн прототип предоставляет клиенту общий интерфейс для работы со всеми прототипами. Клиенту не нужно зависеть от всех классов копируемых объектов, а только от интерфейса клонирования. 
2. **Когда имеете уйму подклассов, которые отличаются начальными значениями полей. Кто-то мог создать все эти классы, чтобы иметь возможность легко порождать объекты с определённой конфигурацией.** 
   Паттерн прототип предлагает использовать набор прототипов, вместо создания подклассов для описания популярных конфигураций объектов. Таким образом, вместо порождения объектов из подклассов, вы будете копировать существующие объекты-прототипы, в которых уже настроено внутреннее состояние. Это позволит избежать взрывного роста количества классов в программе и уменьшить её сложность.

###### Шаги реализации
- Создайте интерфейс прототипов с единственным методом clone. Если у вас уже есть иерархия продуктов, метод клонирования можно объявить непосредственно в каждом из её классов. 
- Добавьте в классы будущих прототипов альтернативный конструктор, принимающий в качестве аргумента объект текущего класса. Этот конструктор должен скопировать из поданного объекта значения всех полей, объявленных в рамках текущего класса, а затем передать выполнение родительскому конструктору, чтобы тот позаботился о полях, объявленных в суперклассе
- Метод клонирования обычно состоит всего из одной строки: вызова оператора new с конструктором прототипа. Все классы, поддерживающие клонирование, должны явно определить метод clone, чтобы использовать собственный класс с оператором new. В обратном случае результатом клонирования станет объект родительского класса.
- Опционально, создайте центральное хранилище прототипов. В нём удобно хранить вариации объектов, возможно, даже одного класса, но по-разному настроенных.
- Наконец, нужно избавиться от прямых вызовов конструкторов объектов, заменив их вызовами фабричного метода хранилища прототипов

#### 11. Расскажите про паттерн Адаптер (Adapter). 
**Адаптер** — это структурный паттерн проектирования, который позволяет объектам с несовместимыми интерфейсами работать вместе.

**Проблема** 
Представьте, что вы делаете приложение для торговли на бирже. Ваше приложение скачивает биржевые котировки из нескольких источников в XML, а затем рисует красивые графики. 
В какой-то момент вы решаете улучшить приложение, применив стороннюю библиотеку аналитики. Но вот беда — библиотека поддерживает только формат данных JSON, несовместимый с вашим приложением. 
Вы смогли бы переписать библиотеку, чтобы та поддерживала формат XML. Но, во-первых, это может нарушить работу существующего кода, который уже зависит от библиотеки. А во-вторых, у вас может просто не быть доступа к её исходному коду.

**Решение**
Вы можете создать адаптер. Это объект-переводчик, который трансформирует интерфейс или данные одного объекта в такой вид, чтобы он стал понятен другому объекту. 
При этом адаптер оборачивает один из объектов, так что другой объект даже не знает о наличии первого. Например, вы можете обернуть объект, работающий в метрах, адаптером, который бы конвертировал данные в футы.

Адаптеры могут не только переводить данные из одного формата в другой, но и помогать объектам с разными интерфейсами работать сообща. Это работает так: 
- Адаптер имеет интерфейс, который совместим с одним из объектов. 
- Поэтому этот объект может свободно вызывать методы адаптера. 
- Адаптер получает эти вызовы и перенаправляет их второму объекту, но уже в том формате и последовательности, которые понятны второму объекту. 
  
  Иногда возможно создать двухсторонний адаптер, который работает в обе стороны. Таким образом, в приложении биржевых котировок вы могли бы создать класс `XML_To_JSON_Adapter`, который бы оборачивал объект того или иного класса библиотеки аналитики. Ваш код посылал бы адаптеру запросы в формате XML, а адаптер сначала транслировал входящие данные в формат JSON, а затем передавал бы их методам обёрнутого объекта аналитики.

###### Когда применять?
1. **Когда вы хотите использовать сторонний класс, но его интерфейс не соответствует остальному коду приложения.** 
   Адаптер позволяет создать объект-прокладку, который будет превращать вызовы приложения в формат, понятный стороннему классу. 
2. **Когда нужно использовать несколько существующих подклассов, но в них не хватает какой-то общей функциональности, причём расширить суперкласс нельзя.** 
   Можно создать ещё один уровень подклассов и добавить в них недостающую функциональность, но при этом придётся дублировать один и тот же код в обеих ветках подклассов.
   
   Более элегантным решением было бы поместить недостающую функциональность в адаптер и приспособить его для работы с суперклассом. Такой адаптер сможет работать со всеми подклассами иерархии.

###### Шаги реализации
- Убедитесь, что у вас есть два класса с несовместимыми интерфейсами: 
	- полезный сервис — служебный класс, который вы не можете изменять (он либо сторонний, либо от него зависит другой код); 
	- один или несколько клиентов — существующих классов приложения, несовместимых с сервисом из-за неудобного или несовпадающего интерфейса. 
- Опишите клиентский интерфейс, через который классы приложения смогли бы использовать класс сервиса.
- Создайте класс адаптера, реализовав этот интерфейс. 
- Поместите в адаптер поле, которое будет хранить ссылку на объект сервиса. Обычно это поле заполняют объектом, переданным в конструктор адаптера. В случае простой адаптации этот объект можно передавать через параметры методов адаптера. 
- Реализуйте все методы клиентского интерфейса в адаптере. Адаптер должен делегировать основную работу сервису. 
- Приложение должно использовать адаптер только через клиентский интерфейс. Это позволит легко изменять и добавлять адаптеры в будущем.

#### 12. Расскажите про паттерн Декоратор (Decorator). 
**Декоратор** — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в полезные «обёртки».

**Проблема**
Вы работаете над библиотекой оповещений, которую можно подключать к разным программам, чтобы получать уведомления о важных событиях.
Основой библиотеки является класс `Notifier` с методом `send`, который принимает на вход строку-сообщение и высылает её всем администраторам по электронной почте. Сторонняя программа должна создать и настроить этот объект, указав кому отправлять оповещения, а затем использовать его каждый раз, когда что-то случается. 
В какой-то момент стало понятно, что одних email оповещений пользователям мало. Некоторые из них хотели бы получать извещения о критических проблемах через SMS. Другие хотели бы получать их в виде сообщений Facebook. Корпоративные пользователи хотели бы видеть сообщения в Slack.

Сначала вы добавили каждый из этих типов оповещений в программу, унаследовав их от базового класса `Notifier`. Теперь пользователь выбирал один из типов оповещений, который и использовался в дальнейшем.

Но затем кто-то резонно спросил, почему нельзя выбрать несколько типов оповещений сразу? Ведь если вдруг в вашем доме начался пожар, вы бы хотели получить оповещения по всем каналам, не так ли? Вы попытались реализовать все возможные комбинации подклассов оповещений.

После того, как вы добавили первый десяток классов, стало ясно, что такой подход невероятно раздувает код программы. Нужен другой способ комбинирования поведения объектов, который не приводит к взрыву количества подклассов.

**Решение**
Наследование — это первое, что приходит в голову, когда нужно расширить какое-то существующее поведение. Но механизм наследования имеет несколько досадных проблем.
- Он статичен. Вы не можете изменить поведение существующего объекта. Для этого вам надо создать новый объект, выбрав другой подкласс. 
- Он не разрешает наследовать поведение нескольких классов одновременно. Из-за этого приходится создавать множество подклассов-комбинаций для получения совмещённого поведения.

Одним из способов обойти эти проблемы является **замена наследования агрегацией либо композицией. Это когда один объект содержит ссылку на другой и делегирует ему работу, вместо того чтобы самому наследовать его поведение.**

**Как раз на этом принципе построен паттерн Декоратор. Декоратор имеет альтернативное название — обёртка.** 
Оно более точно описывает суть паттерна: вы помещаете целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё. 
Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. Вы можете использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу. В примере с оповещениями оставим в базовом классе простую отправку по электронной почте, а расширенные способы отправки сделаем декораторами.

Сторонняя программа, выступающая клиентом, во время первичной настройки будет заворачивать объект оповещений в те обёртки, которые соответствуют желаемому способу оповещения. 
Последняя обёртка в списке и будет тем объектом, с которым клиент будет работать в остальное время. Для остального клиентского кода, по сути, ничего не изменится, ведь все обёртки имеют точно такой же интерфейс, что и базовый класс оповещений. 
Таким же образом можно изменять не только способ доставки оповещений, но и форматирование, список адресатов и так далее. К тому же клиент может «до-обернуть» объект любыми другими обёртками, когда ему захочется

**Когда применять?** 
1. **Когда вам нужно добавлять обязанности объектам на лету, незаметно для кода, который их использует.** 
   Объекты помещают в обёртки, имеющие дополнительные поведения. Обёртки и сами объекты имеют одинаковый интерфейс, поэтому клиентам без разницы, с чем работать — с обычным объектом данных или с обёрнутым. 
   
2. **Когда нельзя расширить обязанности объекта с помощью наследования.** 
   Во многих языках программирования есть ключевое слово final, которое может заблокировать наследование класса. Расширить такие классы можно только с помощью Декоратора.

**Шаги реализации**
разобраться на примере кода с сайта. по методе непонятно

#### 13. Расскажите про паттерн Заместитель (Proxy). 
**Заместитель** — это структурный паттерн проектирования, который позволяет подставлять вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.

**Проблема** 
Для чего вообще контролировать доступ к объектам? Рассмотрим такой пример: у вас есть внешний ресурсоёмкий объект, который нужен не все время, а изредка. 
Мы могли бы создавать этот объект не в самом начале программы, а только тогда, когда он кому-то реально понадобится. Каждый клиент объекта получил бы некий код отложенной инициализации. Но, вероятно, это привело бы к множественному дублированию кода. 
В идеале, этот код хотелось бы поместить прямо в служебный класс, но это не всегда возможно. Например, код класса может находиться в закрытой сторонней библиотеке.

**Решение** 
Паттерн Заместитель предлагает создать новый класс-дублёр, имеющий тот же интерфейс, что и оригинальный служебный объект. При получении запроса от клиента объект-заместитель сам бы создавал экземпляр служебного объекта и переадресовывал бы ему всю реальную работу. 

Но в чём же здесь польза? Вы могли бы поместить в класс заместителя какую-то промежуточную логику, которая выполнялась бы до (или после) вызовов этих же методов в настоящем объекте. А благодаря одинаковому интерфейсу, объект-заместитель можно передать в любой код, ожидающий сервисный объект. 

Платёжная карточка — это заместитель пачки наличных. И карточка, и наличные имеют общий интерфейс — ими можно оплачивать товары. Для покупателя польза в том, что не надо таскать с собой тонны наличных, а владелец магазина рад, что ему не нужно делать дорогостоящую инкассацию наличности в банк — деньги поступают к нему на счёт напрямую.
##### Когда применять?
1. **Ленивая инициализация (виртуальный прокси):** Когда у вас есть тяжёлый объект, грузящий данные из файловой системы или базы данных. Вместо того, чтобы грузить данные сразу после старта программы, можно сэкономить ресурсы и создать объект тогда, когда он действительно понадобится.

2. **Защита доступа (защищающий прокси):** Когда в программе есть разные типы пользователей, и вам хочется защищать объект от неавторизованного доступа. Например, если ваши объекты — это важная часть операционной системы, а пользователи — сторонние программы (хорошие или вредоносные). Прокси может проверять доступ при каждом вызове и передавать выполнение служебному объекту, если доступ разрешён.

3. **Локальный запуск сервиса (удалённый прокси):** Когда настоящий сервисный объект находится на удалённом сервере. В этом случае заместитель транслирует запросы клиента в вызовы по сети в протоколе, понятном удалённому сервису.

4. **Логирование запросов (логирующий прокси):** Когда требуется хранить историю обращений к сервисному объекту. Заместитель может сохранять историю обращения клиента к сервисному объекту.

5. **Кеширование объектов («умная» ссылка):** Когда нужно кешировать результаты запросов клиентов и управлять их жизненным циклом. Заместитель может подсчитывать количество ссылок на сервисный объект, которые были отданы клиенту и остаются активными. Когда все ссылки освобождаются, можно будет освободить и сам сервисный объект (например, закрыть подключение к базе данных).
   Кроме того, Заместитель может отслеживать, не менял ли клиент сервисный объект. Это позволит использовать объекты повторно и экономить ресурсы, особенно если речь идёт о больших прожорливых сервисах.

###### Шаги реализации
1. **Определение интерфейса:** Сначала определите интерфейс, который будет делать заместитель и оригинальный объект взаимозаменяемыми. Этот интерфейс будет содержать методы, которые будут вызываться клиентом.
    
2. **Создание класса заместителя:** Затем создайте класс заместителя, который будет реализовывать этот интерфейс. В большинстве случаев, заместитель будет содержать ссылку на сервисный объект. Этот объект может быть создан заместителем или передан ему через конструктор.
    
3. **Реализация методов заместителя:** Методы заместителя должны быть реализованы в зависимости от его предназначения. В большинстве случаев, заместитель должен делегировать выполнение запроса реальному сервисному объекту, который он содержит.
    
4. **Использование фабрики (по желанию):** Вы можете рассмотреть возможность использования фабрики для создания объектов заместителя или реального сервисного объекта. Это может быть полезно, если логика выбора объекта зависит от каких-то условий.
    
5. **Ленивая инициализация:** Подумайте о том, нужно ли вам реализовать ленивую инициализацию сервисного объекта при первом обращении клиента к методам заместителя. Это может быть полезно, если создание сервисного объекта требует много ресурсов или если он необходим только при определенных условиях.

#### 14. Расскажите про паттерн Итератор (Iterator). 
**Итератор** — это поведенческий паттерн проектирования, который даёт возможность последовательно обходить элементы составных объектов, не раскрывая их внутреннего представления.

**Идея паттерна Итератор состоит в том, чтобы вынести поведение обхода коллекции из самой коллекции в отдельный класс.** 

Объект-итератор будет отслеживать состояние обхода, текущую позицию в коллекции и сколько элементов ещё осталось обойти. Одну и ту же коллекцию смогут одновременно обходить различные итераторы, а сама коллекция не будет даже знать об этом. К тому же, если вам понадобится добавить новый способ обхода, вы сможете создать отдельный класс итератора, не изменяя существующий код коллекции.

**Когда применять?** 
1. **Когда у вас есть сложная структура данных, и вы хотите скрыть от клиента детали её реализации (из-за сложности или вопросов безопасности)**
   Итератор предоставляет клиенту всего несколько простых методов перебора элементов коллекции. Это не только упрощает доступ к коллекции, но и защищает её данные от неосторожных или злоумышленных действий.
   
2. **Когда нужно иметь несколько вариантов обхода одной и той же структуры данных.**
   Нетривиальные алгоритмы обхода структуры данных могут иметь довольно объёмный код. Этот код будет захламлять всё вокруг — будь то сам класс коллекции или часть бизнес-логики программы. Применив итератор, вы можете выделить код обхода структуры данных в собственный класс, упростив поддержку остального кода.
   
3. **Когда хочется иметь единый интерфейс обхода различных структур данных.**
   Итератор позволяет вынести реализации различных вариантов обхода в подклассы. Это позволит легко взаимо-заменять объекты итераторов, в зависимости от того, с какой структурой данных приходится работать.

**Шаги реализации**
- **Создайте общий интерфейс итераторов.** 
  Обязательный минимум — это операция получения следующего элемента коллекции. Но для удобства можно предусмотреть и другое. Например, методы для получения предыдущего элемента, текущей позиции, проверки окончания обхода и прочие. 
- **Создайте интерфейс коллекции и опишите в нём метод получения итератора.** Важно, чтобы сигнатура метода возвращала общий интерфейс итераторов, а не один из конкретных итераторов.
- **Создайте классы конкретных итераторов для тех коллекций, которые нужно обходить с помощью паттерна.** 
  Итератор должен быть привязан только к одному объекту коллекции. Обычно эта связь устанавливается через конструктор. 
- **Реализуйте методы получения итератора в конкретных классах коллекций.** 
  Они должны создавать новый итератор того класса, который способен работать с данным типом коллекции. Коллекция должна передавать ссылку на собственный объект в конструктор итератора. 
- **В клиентском коде и в классах коллекций не должно остаться кода обхода элементов.** 
  Клиент должен получать новый итератор из объекта коллекции каждый раз, когда ему нужно перебрать её элементы.

#### 15. Расскажите про паттерн Шаблонный метод (Template Method). 
**Шаблонный метод** — это поведенческий паттерн проектирования, который определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Паттерн позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.

###### **Проблема**
Вы пишете программу для дата-майнинга в офисных документах. Пользователи будут загружать в неё документы в разных форматах (PDF, DOC, CSV), а программа должна извлекать из них полезную информацию.

В первой версии вы ограничились только обработкой DOC-файлов. В следующей версии добавили поддержку CSV. А через месяц прикрутили работу с PDF-документами.

В какой-то момент вы заметили, что код всех трёх классов обработки документов хоть и отличается в части работы с файлами, но содержат довольно много общего в части самого извлечения данных. Было бы здорово избавится от повторной реализации алгоритма извлечения данных в каждом из классов.

К тому же остальной код, работающий с объектами этих классов, наполнен условиями, проверяющими тип обработчика перед началом работы. Весь этот код можно упростить, если слить все три класса воедино либо свести их к общему интерфейсу.

###### **Решение**
Паттерн Шаблонный метод предлагает разбить алгоритм на последовательность шагов, описать эти шаги в отдельных методах и вызывать их в одном _шаблонном_ методе друг за другом.

Это позволит подклассам переопределять некоторые шаги алгоритма, оставляя без изменений его структуру и остальные шаги, которые для этого подкласса не так важны.

В нашем примере с дата-майнингом мы можем создать общий базовый класс для всех трёх алгоритмов. Этот класс будет состоять из шаблонного метода, который последовательно вызывает шаги разбора документов.
![[Pasted image 20240514185636.png]]

Для начала шаги шаблонного метода можно сделать абстрактными. Из-за этого все подклассы должны будут реализовать каждый из шагов по-своему. В нашем случае все подклассы и так содержат реализацию каждого из шагов, поэтому ничего дополнительно делать не нужно.

По-настоящему важным является следующий этап. Теперь мы можем определить общее для всех классов поведение и вынести его в суперкласс. В нашем примере шаги открытия, считывания и закрытия могут отличаться для разных типов документов, поэтому останутся абстрактными. А вот одинаковый для всех типов документов код обработки данных переедет в базовый класс.

Получилось два вида шагов: **_абстрактные_**, которые каждый подкласс обязательно должен реализовать, а также шаги **_с реализацией по умолчанию_**, которые можно переопределять в подклассах, но не обязательно.

Но есть и третий тип шагов — **_хуки_**: их не обязательно переопределять, но они не содержат никакого кода, выглядя как обычные методы. Шаблонный метод останется рабочим, даже если ни один подкласс не переопределит такой хук. Однако, хук даёт подклассам дополнительные точки «вклинивания» в шаблонный метод. Суть хуков заключается в том, что они позволяют программисту создавать свои собственные обработчики событий или аспекты и подключать их к уже существующему коду без необходимости изменения его исходного кода. Это обеспечивает гибкость и расширяемость программы, так как позволяет добавлять или изменять функциональность приложения без изменения его основной логики.

###### Аналогия из жизни
Строители используют подход, похожий на шаблонный метод при строительстве типовых домов. У них есть основной архитектурный проект, в котором расписаны шаги строительства: заливка фундамента, постройка стен, перекрытие крыши, установка окон и так далее.

Но, несмотря на стандартизацию каждого этапа, строители могут вносить небольшие изменения на любом из этапов, чтобы сделать дом чуточку непохожим на другие.

###### Когда применять?
1. **Когда подклассы должны расширять базовый алгоритм, не меняя его структуры.**
   Шаблонный метод позволяет подклассам расширять определённые шаги алгоритма через наследование, не меняя при этом структуру алгоритмов, объявленную в базовом классе.

 2. **Когда у вас есть несколько классов, делающих одно и то же с незначительными отличиями. Если вы редактируете один класс, то приходится вносить такие же правки и в остальные классы.**
    Паттерн шаблонный метод предлагает создать для похожих классов общий суперкласс и оформить в нём главный алгоритм в виде шагов. Отличающиеся шаги можно переопределить в подклассах.
    Это позволит убрать дублирование кода в нескольких классах с похожим поведением, но отличающихся в деталях.

###### Шаги реализации
1. **Изучите алгоритм и подумайте, можно ли его разбить на шаги.** Прикиньте, какие шаги будут стандартными для всех вариаций алгоритма, а какие — изменяющимися.
    
2. **Создайте абстрактный базовый класс.** Определите в нём шаблонный метод. Этот метод должен состоять из вызовов шагов алгоритма. Имеет смысл сделать шаблонный метод финальным, чтобы подклассы не могли переопределить его (если ваш язык программирования это позволяет).
    
3. **Добавьте в абстрактный класс методы для каждого из шагов алгоритма.** Вы можете сделать эти методы абстрактными или добавить какую-то реализацию по умолчанию. В первом случае все подклассы _должны_ будут реализовать эти методы, а во втором — только если реализация шага в подклассе отличается от стандартной версии.
    
4. **Подумайте о введении в алгоритм хуков.** Чаще всего, хуки располагают между основными шагами алгоритма, а также до и после всех шагов.
    
5. **Создайте конкретные классы, унаследовав их от абстрактного класса.** Реализуйте в них все недостающие шаги и хуки.

###### Преимущества
-  Облегчает повторное использование кода.
###### Недостатки
-  Вы жёстко ограничены скелетом существующего алгоритма.
-  Вы можете нарушить _принцип подстановки Барбары Лисков_, изменяя базовое поведение одного из шагов алгоритма через подкласс.
-  С ростом количества шагов шаблонный метод становится слишком сложно поддерживать.
###### Отношения с другими паттернами
- Фабричный метод можно рассматривать как частный случай Шаблонного метода. Кроме того, Фабричный метод нередко бывает частью большого класса с Шаблонными методами.
- Шаблонный метод использует наследование, чтобы расширять части алгоритма. Стратегия использует делегирование, чтобы изменять выполняемые алгоритмы на лету. Шаблонный метод работает на уровне классов. Стратегия позволяет менять логику отдельных объектов.

#### 16. Расскажите про паттерн Цепочка обязанностей (Chain of Responsibility). 
**Цепочка обязанностей** — это поведенческий паттерн проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков. Каждый последующий обработчик решает, может ли он обработать запрос сам и стоит ли передавать запрос дальше по цепи.

###### Проблема
Представьте, что вы делаете систему приёма онлайн-заказов. Вы хотите ограничить к ней доступ так, чтобы только авторизованные пользователи могли создавать заказы. Кроме того, определённые пользователи, владеющие правами администратора, должны иметь полный доступ к заказам.

Вы быстро сообразили, что эти проверки нужно выполнять последовательно. Ведь пользователя можно попытаться «залогинить» в систему, если его запрос содержит логин и пароль. Но если такая попытка не удалась, то проверять расширенные права доступа попросту не имеет смысла.
На протяжении следующих нескольких месяцев вам пришлось добавить ещё несколько таких последовательных проверок.

- Кто-то резонно заметил, что неплохо бы проверять данные, передаваемые в запросе перед тем, как вносить их в систему — вдруг запрос содержит данные о покупке несуществующих продуктов.
    
- Кто-то предложил блокировать массовые отправки формы с одним и тем же логином, чтобы предотвратить подбор паролей ботами.
    
- Кто-то заметил, что форму заказа неплохо бы доставать из кэша, если она уже была однажды показана.

С каждой новой «фичей» код проверок, выглядящий как большой клубок условных операторов, всё больше и больше раздувался. При изменении одного правила приходилось трогать код всех проверок. А для того, чтобы применить проверки к другим ресурсам, пришлось продублировать их код в других классах.

Поддерживать такой код стало не только очень хлопотно, но и затратно. И вот в один прекрасный день вы получаете задачу рефакторинга...

###### Решение
Как и многие другие поведенческие паттерны, Цепочка обязанностей базируется на том, чтобы превратить отдельные поведения в объекты. В нашем случае каждая проверка переедет в отдельный класс с единственным методом выполнения. Данные запроса, над которым происходит проверка, будут передаваться в метод как аргументы.

А теперь по-настоящему важный этап. Паттерн предлагает связать объекты обработчиков в одну цепь. Каждый из них будет иметь ссылку на следующий обработчик в цепи. Таким образом, при получении запроса обработчик сможет не только сам что-то с ним сделать, но и передать обработку следующему объекту в цепочке.

Передавая запросы в первый обработчик цепочки, вы можете быть уверены, что все объекты в цепи смогут его обработать. При этом длина цепочки не имеет никакого значения.

И последний штрих. Обработчик не обязательно должен передавать запрос дальше, причём эта особенность может быть использована по-разному.

В примере с фильтрацией доступа обработчики прерывают дальнейшие проверки, если текущая проверка не прошла. Ведь нет смысла тратить попусту ресурсы, если и так понятно, что с запросом что-то не так.

Но есть и другой подход, при котором обработчики прерывают цепь только когда они _могут_ обработать запрос. В этом случае запрос движется по цепи, пока не найдётся обработчик, который может его обработать. Очень часто такой подход используется для передачи событий, создаваемых классами графического интерфейса в результате взаимодействия с пользователем.

Например, когда пользователь кликает по кнопке, программа выстраивает цепочку из объекта этой кнопки, всех её родительских элементов и общего окна приложения на конце. Событие клика передаётся по этой цепи до тех пор, пока не найдётся объект, способный его обработать. Этот пример примечателен ещё и тем, что цепочку всегда можно выделить из древовидной структуры объектов, в которую обычно и свёрнуты элементы пользовательского интерфейса.
![[Pasted image 20240514191416.png]]
Очень важно, чтобы все объекты цепочки имели общий интерфейс. Обычно каждому конкретному обработчику достаточно знать только то, что следующий объект в цепи имеет метод `выполнить`. Благодаря этому связи между объектами цепочки будут более гибкими. Кроме того, вы сможете формировать цепочки на лету из разнообразных объектов, не привязываясь к конкретным классам.

###### Структура
1. **Обработчик** определяет общий для всех конкретных обработчиков интерфейс. Обычно достаточно описать единственный метод обработки запросов, но иногда здесь может быть объявлен и метод выставления следующего обработчика.
    
2. **Базовый обработчик** — опциональный класс, который позволяет избавиться от дублирования одного и того же кода во всех конкретных обработчиках.
    
    Обычно этот класс имеет поле для хранения ссылки на следующий обработчик в цепочке. Клиент связывает обработчики в цепь, подавая ссылку на следующий обработчик через конструктор или сеттер поля. Также здесь можно реализовать базовый метод обработки, который бы просто перенаправлял запрос следующему обработчику, проверив его наличие.
    
3. **Конкретные обработчики** содержат код обработки запросов. При получении запроса каждый обработчик решает, может ли он обработать запрос, а также стоит ли передать его следующему объекту.
    
    В большинстве случаев обработчики могут работать сами по себе и быть неизменяемыми, получив все нужные детали через параметры конструктора.
    
4. **Клиент** может либо сформировать цепочку обработчиков единожды, либо перестраивать её динамически, в зависимости от логики программы. Клиент может отправлять запросы любому из объектов цепочки, не обязательно первому из них.

###### Когда применять?
1. **Когда программа должна обрабатывать разнообразные запросы несколькими способами, но заранее неизвестно, какие конкретно запросы будут приходить и какие обработчики для них понадобятся.**
   С помощью Цепочки обязанностей вы можете связать потенциальных обработчиков в одну цепь и при получении запроса поочерёдно спрашивать каждого из них, не хочет ли он обработать запрос.

2. **Когда важно, чтобы обработчики выполнялись один за другим в строгом порядке.**
   Цепочка обязанностей позволяет запускать обработчиков последовательно один за другим в том порядке, в котором они находятся в цепочке.

3. **Когда набор объектов, способных обработать запрос, должен задаваться динамически.**
   В любой момент вы можете вмешаться в существующую цепочку и переназначить связи так, чтобы убрать или добавить новое звено.

###### Шаги реализации
1. **Создайте интерфейс обработчика и опишите в нём основной метод обработки.**
    Продумайте, в каком виде клиент должен передавать данные запроса в обработчик. Самый гибкий способ — превратить данные запроса в объект и передавать его целиком через параметры метода обработчика.
    
2. **Имеет смысл создать абстрактный базовый класс обработчиков, чтобы не дублировать реализацию метода получения следующего обработчика во всех конкретных обработчиках.**
    Добавьте в базовый обработчик поле для хранения ссылки на следующий объект цепочки. Устанавливайте начальное значение этого поля через конструктор. Это сделает объекты обработчиков неизменяемыми. Но если программа предполагает динамическую перестройку цепочек, можете добавить и сеттер для поля.
    
    Реализуйте базовый метод обработки так, чтобы он перенаправлял запрос следующему объекту, проверив его наличие. Это позволит полностью скрыть поле-ссылку от подклассов, дав им возможность передавать запросы дальше по цепи, обращаясь к родительской реализации метода.
    
3. **Один за другим создайте классы конкретных обработчиков и реализуйте в них методы обработки запросов. При получении запроса каждый обработчик должен решить:**
    - Может ли он обработать запрос или нет?
    - Следует ли передать запрос следующему обработчику или нет?
      
4. **Клиент может собирать цепочку обработчиков самостоятельно, опираясь на свою бизнес-логику, либо получать уже готовые цепочки извне. В последнем случае цепочки собираются фабричными объектами, опираясь на конфигурацию приложения или параметры окружения.**
    
5. **Клиент может посылать запросы любому обработчику в цепи, а не только первому. Запрос будет передаваться по цепочке до тех пор, пока какой-то обработчик не откажется передавать его дальше, либо когда будет достигнут конец цепи.**
    
6. **Клиент должен знать о динамической природе цепочки и быть готов к таким случаям:**
    - Цепочка может состоять из единственного объекта.
    - Запросы могут не достигать конца цепи.
    - Запросы могут достигать конца, оставаясь необработанными.

###### Преимущества
-  Уменьшает зависимость между клиентом и обработчиками.
-  Реализует _принцип единственной ответственности.
-  Реализует _принцип открытости/закрытости_.
###### Недостатки
-  Запрос может остаться никем не обработанным.
###### Отношения с другими паттернами
- [Цепочка обязанностей](https://refactoring.guru/ru/design-patterns/chain-of-responsibility), [Команда](https://refactoring.guru/ru/design-patterns/command), [Посредник](https://refactoring.guru/ru/design-patterns/mediator) и [Наблюдатель](https://refactoring.guru/ru/design-patterns/observer) показывают различные способы работы отправителей запросов с их получателями:
    - _Цепочка обязанностей_ передаёт запрос последовательно через цепочку потенциальных получателей, ожидая, что какой-то из них обработает запрос.
    - _Команда_ устанавливает косвенную одностороннюю связь от отправителей к получателям.
    - _Посредник_ убирает прямую связь между отправителями и получателями, заставляя их общаться опосредованно, через себя.
    - _Наблюдатель_ передаёт запрос одновременно всем заинтересованным получателям, но позволяет им динамически подписываться или отписываться от таких оповещений.
      
- Цепочку обязанностей часто используют вместе с [Компоновщиком](https://refactoring.guru/ru/design-patterns/composite). В этом случае запрос передаётся от дочерних компонентов к их родителям.
    
- Обработчики в Цепочке обязанностей могут быть выполнены в виде [Команд](https://refactoring.guru/ru/design-patterns/command). В этом случае множество разных операций может быть выполнено над одним и тем же контекстом, коим является запрос.
    
    Но есть и другой подход, в котором сам запрос является _Командой_, посланной по цепочке объектов. В этом случае одна и та же операция может быть выполнена над множеством разных контекстов, представленных в виде цепочки.
    
- Цепочка обязанностей и [Декоратор](https://refactoring.guru/ru/design-patterns/decorator) имеют очень похожие структуры. Оба паттерна базируются на принципе рекурсивного выполнения операции через серию связанных объектов. Но есть и несколько важных отличий.
    
    Обработчики в _Цепочке обязанностей_ могут выполнять произвольные действия, независимые друг от друга, а также в любой момент прерывать дальнейшую передачу по цепочке. С другой стороны _Декораторы_ расширяют какое-то определённое действие, не ломая интерфейс базовой операции и не прерывая выполнение остальных декораторов.


#### 17. Какие паттерны используются в Spring Framework? 
- **Singleton** - Creating beans with default scope
- **Factory** - Bean Factory classes 
- **Prototype** - Bean scopes 
- **Adapter** - Spring Web and Spring MVC 
- **Proxy** - Spring Aspect Oriented Programming support 
- **Template Method** - JdbcTemplate, HibernateTemplate etc 
- **Front Controller** - Spring MVC DispatcherServlet
- **Data Access Object** - Spring DAO support 
- **Dependency Injection** and Aspect Oriented Programming

**Паттерн Команда (Command)** — это поведенческий шаблон проектирования, который используется для инкапсуляции запроса в виде объекта. Объект команды представляет действие и его параметры. Он позволяет параметризовать клиентов с разными запросами и поддерживать отмену операций. Этот паттерн может быть связан с [инъекцией прототипа в синглтон](https://itsobes.ru/JavaSobes/kak-rabotaet-inuekciya-prototipa-v-singlton/).

1. **Singleton**:
    - Этот паттерн гарантирует, что у нас есть только один экземпляр класса во всем приложении.
    - В Spring Singleton используется по умолчанию для создания бинов (компонентов).
    - Это означает, что Spring создает только один экземпляр бина и использует его повторно при каждом запросе.
      
2. **Factory**:
    - Фабричные классы в Spring отвечают за создание бинов.
    - Они предоставляют абстракцию для создания объектов, скрывая детали реализации.
    - Пример: `BeanFactory` и `ApplicationContext`.
      
3. **Prototype**:
    - **Прототипный паттерн** позволяет создавать новые объекты, копируя существующие, чтобы избежать дорогостоящей инициализации.
    - В Spring прототипный бин создается каждый раз, когда он запрашивается.
    - Это полезно, когда нам нужно создавать новый экземпляр бина для каждого запроса.
    - Пример: если у нас есть бин, представляющий сессию пользователя, мы можем использовать прототипный бин, чтобы создавать новую сессию для каждого пользователя.
    
4. **Adapter**:
	- Адаптер оборачивает существующий класс новым интерфейсом, чтобы сделать его совместимым с необходимым интерфейсом.
	- В Spring адаптер может быть полезен, например, при интеграции с внешними системами, которые имеют другой формат данных или интерфейс.
	
5. **Proxy**:
	- Предоставляет объект-заместитель, который управляет доступом к другому объекту. Другими словами, создается объект-суррогат, который может выступать в роли другого объекта и перехватывать все вызовы к нему.
	- В **Spring** прокси просто оборачивает бин (объект), позволяя добавить логику до и после выполнения методов. Это полезно, например, для логирования, обработки транзакций или кэширования.
	  
	- **Spring AOP** (Aspect-Oriented Programming) использует два варианта проксирования:
		1. **Динамические прокси JDK**:
			- JDK Dynamic Proxy позволяет проксировать любой интерфейс (или набор интерфейсов).
			- Если целевой объект реализует хотя бы один интерфейс, то будет создан прокси-объект, который оборачивает оригинальный объект.
			- Все вызовы методов направляются на прокси, который может выполнять дополнительные действия перед или после вызова метода оригинального объекта.
		2. **Прокси-сервер CGLIB**:
		    - Если целевой объект не реализует интерфейсов, Spring AOP использует CGLIB Proxy.
			- CGLIB (Code Generation Library) создает динамический класс-потомок для целевого объекта.
			- Этот класс-потомок переопределяет методы целевого объекта и добавляет логику аспектов.
			- Все вызовы методов направляются на этот класс-потомок, который выполняет аспекты.
		    - Если вы хотите принудительно использовать проксирование CGLIB (например, чтобы проксировать каждый метод, определенный для целевого объекта), вы можете установить атрибут `proxy-target-class` элемента `<aop:config>` в значение `true`.
	
6. **Template Method:**
	- Этот паттерн используется для обработки повторяющегося кода, такого как закрытие соединений с базой данных или другие общие операции.
	- Примеры в **Spring**:
	    - **JdbcTemplate**: Предоставляет шаблонный метод для выполнения SQL-запросов с автоматическим управлением ресурсами.
	
7. **Front Controller:**
	- Этот паттерн используется для централизованной обработки входящих запросов.
	- В **Spring MVC** это реализуется через **DispatcherServlet**, который обрабатывает все запросы и направляет их на соответствующие контроллеры.
	
8. **Data Access Object (DAO)**:
	- Паттерн **DAO** используется для абстрагирования доступа к данным.
	- В **Spring** есть поддержка **DAO** через **JdbcTemplate** и **Spring Data JPA**.
	- **JdbcTemplate** облегчает выполнение SQL-запросов, а **Spring Data JPA** предоставляет более высокоуровневый способ работы с базой данных.
	
9. **Dependency Injection (DI) и Aspect Oriented Programming (AOP)**:
	- **DI** — это паттерн, который позволяет внедрять зависимости в объекты, вместо того чтобы создавать их внутри самих объектов.
	- **Spring** активно использует **DI** для управления зависимостями между компонентами.
	- **AOP** позволяет внедрять дополнительную функциональность (например, логирование, безопасность, транзакции) в методы объектов без изменения их кода.
	- **Spring AOP** использует паттерн **Proxy** для реализации аспектов.(**Аспекты** — это переиспользуемые модули, которые содержат логику, выполняющуюся перед, после или вокруг методов других объектов.)

#### 18. Какие паттерны используются в Hibernate? 
1. **Domain Model Pattern (Паттерн “Модель домена”)**:
    - В **Hibernate** доменная модель представляется как **POJO** (Plain Old Java Object).
    - Доменная модель — это объектная модель предметной области, которая объединяет как поведение, так и данные.
    - Этот паттерн помогает абстрагировать работу с данными от деталей базы данных.
      
2. **Proxy Design Pattern (Паттерн “Прокси”)**:
    - **Hibernate** использует прокси для реализации ленивой загрузки (lazy loading).
    - Прокси — это заместитель или заполнитель для другого объекта, который контролирует доступ к нему.
    - Пример: **Hibernate** создает прокси для ассоциированных объектов, чтобы избежать избыточной загрузки данных из базы.
      
3. **Factory Design Pattern (Паттерн “Фабрика”)**:
    - **SessionFactory** в **Hibernate** — это пример паттерна “Фабрика”.
    - Этот паттерн определяет интерфейс для создания объекта, но позволяет подклассам решать, какой класс инстанцировать.
    - **SessionFactory** создает сессии для взаимодействия с базой данных.
      
4. **Data Mapper Pattern (Паттерн “Отображение данных”)**:
	- Слой мапперов (Mappers), который передает данные между объектами и базой данных, сохраняя их независимыми друг от друга и себя.

#### 19. Что такое Dependency Injection? 
**Dependency Injection (внедрение зависимости)** – набор паттернов и принципов разработки программного обеспечения, которые позволяют писать слабо связанный код. 

В полном соответствии с принципом единой ответственности объект отдаёт заботу о построении требуемых ему зависимостей внешнему, специально предназначенному для этого общему механизму.

#### 20. Что такое «антипаттерн»? Какие антипаттерны знаете?
Антипаттерн (anti-pattern) — это распространённый подход к решению класса часто 
встречающихся проблем, являющийся неэффективным, рискованным или непродуктивным.

**Poltergeists (полтергейсты)**
Полтергейсты — это классы с ограниченной ответственностью и ролью в системе, чьё единственное предназначение — передавать информацию в другие классы. 
Их эффективный жизненный цикл непродолжителен. Полтергейсты нарушают стройность 
архитектуры программного обеспечения, создавая избыточные (лишние) абстракции, они 
чрезмерно запутанны, сложны для понимания и трудны в сопровождении. Обычно такие 
классы задумываются как классы-контроллеры, которые существуют только для вызова 
методов других классов, зачастую в предопределенной последовательности.

**Признаки появления и последствия антипаттерна:**
- Избыточные межклассовые связи.
- Временные ассоциации.
- Классы без состояния (содержащие только методы и константы).
- Временные объекты и классы (с непродолжительным временем жизни).
- Классы с единственным методом, который предназначен только для создания или  вызова других классов посредством временной ассоциации.
- Классы с именами методов в стиле «управления», такие как startProcess.

**Типичные причины:**
1. Отсутствие объектно-ориентированной архитектуры (архитектор не понимает объектно-ориентированной парадигмы).
2. Неправильный выбор пути решения задачи.
3. Предположения об архитектуре приложения на этапе анализа требований (до объектно-ориентированного анализа) могут также вести к проблемам на подобии этого антипаттерна.

**Внесенная сложность (Introduced complexity):**
	Необязательная сложность дизайна. Вместо одного простого класса выстраивается целая иерархия интерфейсов и классов. Типичный пример «Интерфейс - Абстрактный класс - Единственный класс реализующий интерфейс на основе абстрактного».

**Инверсия абстракции (Abstraction inversion):**
	Сокрытие части функциональности от внешнего использования, в надежде на то, что никто не будет его использовать.

**Неопределённая точка зрения (Ambiguous viewpoint):**
	Представление модели без спецификации её точки рассмотрения.

**Большой комок грязи (Big ball of mud):**
	Система с нераспознаваемой структурой.

**Божественный объект (God object):**
	Концентрация слишком большого количества функций в одной части системы (классе).

**Затычка на ввод данных (Input kludge):**
	Забывчивость в спецификации и выполнении поддержки возможного неверного ввода.

**Раздувание интерфейса (Interface bloat):**
	Разработка интерфейса очень мощным и очень сложным для реализации.

**Волшебная кнопка (Magic pushbutton):**
	Выполнение результатов действий пользователя в виде неподходящего (недостаточно абстрактного) интерфейса. Например, написание прикладной логики в обработчиках нажатий на кнопку.

**Перестыковка (Re-Coupling):**
	Процесс внедрения ненужной зависимости.

**Дымоход (Stovepipe System):**
	Редко поддерживаемая сборка плохо связанных компонентов.

**Состояние гонки (Race hazard):**
	Непредвидение возможности наступления событий в порядке, отличном от ожидаемого.

**Членовредительство (Mutilation):**
	Излишнее «затачивание» объекта под определенную очень узкую задачу таким образом, что он не способен будет работать с никакими иными, пусть и очень схожими задачами.

**Сохранение или смерть (Save or die):**
	Сохранение изменений лишь при завершении приложения.

#### 21. Еще что использовали на практике? 
##### **Фасад** — это структурный паттерн проектирования, который предоставляет простой интерфейс к сложной системе классов, библиотеке или фреймворку.
###### Проблема
Вашему коду приходится работать с большим количеством объектов некой сложной библиотеки или фреймворка. Вы должны самостоятельно инициализировать эти объекты, следить за правильным порядком зависимостей и так далее.

В результате бизнес-логика ваших классов тесно переплетается с деталями реализации сторонних классов. Такой код довольно сложно понимать и поддерживать.

###### Решение
Фасад — это простой интерфейс для работы со сложной подсистемой, содержащей множество классов. Фасад может иметь урезанный интерфейс, не имеющий 100% функциональности, которой можно достичь, используя сложную подсистему напрямую. Но он предоставляет именно те фичи, которые нужны клиенту, и скрывает все остальные.

Фасад полезен, если вы используете какую-то сложную библиотеку со множеством подвижных частей, но вам нужна только часть её возможностей.

К примеру, программа, заливающая видео котиков в социальные сети, может использовать профессиональную библиотеку сжатия видео. Но все, что нужно клиентскому коду этой программы — простой метод `encode(filename, format)`. Создав класс с таким методом, вы реализуете свой первый фасад.

Аналогия с реальной жизнью: когда вы звоните в магазин и делаете заказ по телефону, сотрудник службы поддержки является вашим фасадом ко всем службам и отделам магазина. Он предоставляет вам упрощённый интерфейс к системе создания заказа, платёжной системе и отделу доставки.
###### Когда применять?
1. **Когда вам нужно представить простой или урезанный интерфейс к сложной подсистеме.**
   Часто подсистемы усложняются по мере развития программы. Применение большинства паттернов приводит к появлению меньших классов, но в бóльшем количестве. Такую подсистему проще повторно использовать, настраивая её каждый раз под конкретные нужды, но вместе с тем, применять подсистему без настройки становится труднее. Фасад предлагает определённый вид системы по умолчанию, устраивающий большинство клиентов.

 2. **Когда вы хотите разложить подсистему на отдельные слои.**
    Используйте фасады для определения точек входа на каждый уровень подсистемы. Если подсистемы зависят друг от друга, то зависимость можно упростить, разрешив подсистемам обмениваться информацией только через фасады.
    Например, возьмём  сложную систему видеоконвертации. Вы хотите разбить её на слои работы с аудио и видео. Для каждой из этих частей можно попытаться создать фасад и заставить классы аудио и видео обработки общаться друг с другом через эти фасады, а не напрямую.

##### **Наблюдатель** — это поведенческий паттерн проектирования, который создаёт механизм подписки, позволяющий одним объектам следить и реагировать на события, происходящие в других объектах.

###### Проблема
Представьте, что вы имеете два объекта: `Покупатель` и `Магазин`. В магазин вот-вот должны завезти новый товар, который интересен покупателю.

Покупатель может каждый день ходить в магазин, чтобы проверить наличие товара. Но при этом он будет злиться, без толку тратя своё драгоценное время.

С другой стороны, магазин может разослать спам каждому своему покупателю. Многих это расстроит, так как товар специфический, и не всем он нужен.

Получается конфликт: либо покупатель тратит время на периодические проверки, либо магазин тратит ресурсы на бесполезные оповещения.

###### Решение
Давайте называть `Издателями` те объекты, которые содержат важное или интересное для других состояние. Остальные объекты, которые хотят отслеживать изменения этого состояния, назовём `Подписчиками`.

Паттерн Наблюдатель предлагает хранить внутри объекта издателя список ссылок на объекты подписчиков, причём издатель не должен вести список подписки самостоятельно. Он предоставит методы, с помощью которых подписчики могли бы добавлять или убирать себя из списка.

Теперь самое интересное. Когда в издателе будет происходить важное событие, он будет проходиться по списку подписчиков и оповещать их об этом, вызывая определённый метод объектов-подписчиков.

Издателю безразлично, какой класс будет иметь тот или иной подписчик, так как все они должны следовать общему интерфейсу и иметь единый метод оповещения.

Увидев, как складно всё работает, вы можете выделить общий интерфейс, описывающий методы подписки и отписки, и для всех издателей. После этого подписчики смогут работать с разными типами издателей, а также получать оповещения от них через один и тот же метод.

В этом примере **Наблюдатель** позволяет объекту текстового редактора оповещать другие объекты об изменениях своего состояния.
![[Pasted image 20240514223619.png]]
Список подписчиков составляется динамически, объекты могут как подписываться на определённые события, так и отписываться от них прямо во время выполнения программы.

В этой реализации редактор не ведёт список подписчиков самостоятельно, а делегирует это вложенному объекту. Это даёт возможность использовать механизм подписки не только в классе редактора, но и в других классах программы.

Для добавления в программу новых подписчиков не нужно менять классы издателей, пока они работают с подписчиками через общий интерфейс.
#### 22. Стратегии обработки ошибок: Circuit Breaker pattern (автоматический выключатель, предохранитель)
**Микросервисная архитектура**:
    Микросервисная архитектура представляет собой подход, при котором единое приложение разбивается на небольшие сервисы, каждый из которых работает в собственном процессе и общается с другими.
    Основные принципы микросервисов включают **High Cohesion** (высокую связность) и **Low Coupling** (низкую связанность), а также независимость каждого микросервиса.

**Проблема**:
     В вашем приложении есть множество микросервисов, которые обмениваются данными между собой. Один из сервисов отвалился, и это привело к проблемам в цепочке обработки данных.

 **Варианты решения**:
1. **Idempotency Key (ключ идемпотентности)**:
    -  Каждый запрос из сервиса А снабжается ключом и подписывается.
    - Сервис B узнает, что запрос принадлежит к определенному пользователю.
    - Этот метод подходит для идемпотентных запросов (например, GET, HEAD, PUT, DELETE).        
    - Требуется доработка стороннего сервиса или БД.
      
2.  **Переотправка запросов (Retry pattern)**:
    - Переотправляем запрос до успешного выполнения.
    - Перед повторной отправкой можно проверить тип ошибки.
    - Если исчерпано максимальное количество попыток, лучше показать ошибку пользователю.
    - При ошибках типа timeout или too many requests дайте серверу время восстановиться перед следующей попыткой.

###### **Стратегии ожидания**
- Стратегии ожидания определяют, как приложение будет повторять запросы при возникновении ошибок.
- Варианты включают:
    - **Без ожидания (no delay)**: Сразу повторяем запрос без паузы.
    - **С константным значением (constant)**: Устанавливаем строго заданный лимит между повторными запросами.
    - **С линейным значением (linear)**: Увеличиваем задержку между запросами линейно.
    - **С экспоненциальным значением (exponential)**: Увеличиваем задержку между запросами экспоненциально.

###### В каких случаях стоит и когда не стоит использовать Retry паттерн?
- Применяется, когда приложение работает с удаленным сервисом, и могут возникать временные ошибки.
- При временных ошибках, следующие запросы могут успешно завершиться.
- Не стоит использовать Retry паттерн для долговременных ошибок или ошибок, связанных с бизнес-логикой приложения.

##### Circuit Breaker pattern
В Spring обычно берут реализацию из Netflix стека, которая называется Hystrix. 
Hystrix — это библиотека задержек и отказоустойчивости, это имплементация паттерна Circuit Breaker. 
Как сказано из официальной документации: Hystrix — это библиотека, которая помогает вам контролировать взаимодействие между этими распределенными сервисами, добавляя терпимость к задержкам и логику отказоустойчивости.

###### **Паттерн Circuit Breaker:**
- Предотвращает попытки приложения выполнить операцию, которая скорее всего завершится неудачно.
- Позволяет продолжить работу, не тратя важные ресурсы, пока проблема не устранена.
- Выступает как прокси-сервис между приложением и удаленным сервисом.
###### **Состояния Circuit Breaker**:
- **Closed**: В этом состоянии запросы направляются напрямую к сервису. Счетчик ошибок равен 0, и приложение функционирует нормально.
  
- **Open**: Если количество ошибок за определенный промежуток времени превышает заданный порог, Circuit Breaker переходит в состояние Open. В этом состоянии запросы немедленно завершаются с ошибкой, и исключение возвращается в приложение.
  
- **Half-Open**: После истечения таймера ожидания, ограниченному количеству запросов от приложения разрешено обратиться к сервису. Если эти запросы успешны, считается, что предыдущая ошибка исправлена, и Circuit Breaker переходит в состояние Closed (счетчик ошибок сбрасывается на 0). Если любой из запросов завершился ошибкой, считается, что ошибка все еще присутствует, и Circuit Breaker возвращается в состояние Open, чтобы дать системе дополнительное время на восстановление после сбоя.

**Пример с оплатой картой**:
- При оплате картой, если Circuit Breaker находится в состоянии **Closed**, запрос отправляется на сервер, и попытка оплаты выполняется.
- Если произошла ошибка, Circuit Breaker переходит в состояние **Open**, запускает таймер и показывает ошибку пользователю.
- При следующей попытке оплаты, если Circuit Breaker находится в состоянии **Open**, проверяется таймер. Если он не истек, запрос завершается с ошибкой, которая была в предыдущем запросе.
- Если таймер истек, выполняется новая попытка оплаты. Если успешно, Circuit Breaker переходит в состояние **Closed**, и оплата заказа завершается. В противном случае возвращаемся на шаг **Open**.

**Когда использовать Circuit Breaker**:
- Для предотвращения попыток обращения к сервису или разделяемым ресурсам, когда вероятность возникновения ошибки высока и эти ошибки имеют продолжительный характер.

**Когда не использовать Circuit Breaker**:
- Для обращения к приватным ресурсам приложения, так как это добавит только дополнительный overhead.
- Как замена обработки исключений бизнес-логики приложения.