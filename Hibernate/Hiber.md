#### 1. Что такое ORM?
**ORM** расшифровывается как **"Object-Relational Mapping"** - это техника программирования, которая позволяет разработчикам работать с базами данных, используя объектно-ориентированный подход. Суть ORM заключается в том, чтобы упростить взаимодействие с базой данных, скрывая детали её структуры и SQL-запросов за объектно-ориентированным интерфейсом.

Вместо того, чтобы писать SQL-запросы напрямую, разработчики могут взаимодействовать с базой данных через объекты, которые представляют собой модели данных в их приложении. ORM-библиотеки обеспечивают маппинг между объектами в приложении и таблицами в базе данных, позволяя создавать, читать, обновлять и удалять данные, используя объектно-ориентированный синтаксис.

**Проблема:**
Когда мы хотим, чтобы наше приложение получило доступ к информации, хранящейся в БД, мы должны понимать крайне важную деталь.
Существует огромная разница между объектной моделью и реляционной.

Например, после того, как мы создали и Jаvа-класс и таблицу в БД, нам необходимо изменить БД, у нас сразу же возникает проблема.

К тому же, когда мы записываем или читаем данные в/из БД, у нас есть 5 проблем, которые связаны с разницей между объектно-ориентированной (далее — ОО) моделью и реляционной моделью:

1) **Наследование**
В реляционной модели нет никакого понятия, похожего на наследование, которое является одним из ключевых принципов ООП.

2) **Идентификация**
Для БД есть только одна сущность, по которому объект может быть идентифицирован — это Первичный Ключ (Primary Key).
В то время, как в Java у нас есть такие вещи, как (entity1 == entity2) и (obj1.equals(obj2).

3) **Абстракция**
В Java мы используем ссылки на объекты для абстракции, а в реляционной модели — Внешний Ключ (Foreign Key).

4) **Доступ**
В Java и в реляционной БД абсолютно разные способы получения доступа к объекту.

5) **Инкапсуляция**
Крайне часто, при разработке приложений, вы будете сталкиваться с тем, что наша ОО модель имеет больше классов, чем таблиц в нашей БД.

###### ORM состоит из:
1) API, который реализует базовые CRUD-операции объектов-моделей.
2) Средства настройки метаданных связывания.
3) Технику взаимодействия с транзакциями, которая позволяет реализовывать функции dirty checking, lazy association fetching, eager и др.

###### Эти понятия относятся к различным аспектам работы с ORM (Object-Relational Mapping) и обычно используются в контексте специфических функций и подходов, применяемых в ORM-библиотеках.
1. **Dirty Checking (Проверка на "грязные" объекты)**:

    - Dirty Checking - это механизм, используемый в ORM для отслеживания изменений в состоянии объектов и автоматического обновления данных в базе данных при необходимости. Когда объект загружается из базы данных, ORM сохраняет копию его состояния. После этого, если состояние объекта изменяется (например, изменяется значение его поля), ORM обнаруживает эти изменения (т.е. объект становится "грязным") и автоматически синхронизирует изменения с базой данных при выполнении операции сохранения или обновления.
      
2. **Lazy Association Fetching (Ленивая загрузка связей)**:
    - Lazy Association Fetching - это методика, используемая в ORM для отложенной загрузки связанных объектов из базы данных. Когда объект загружается из базы данных, связанные объекты могут быть загружены сразу (это называется "жадная загрузка") или только по мере необходимости (это и есть "ленивая загрузка"). Ленивая загрузка полезна в случаях, когда связанные объекты могут быть большими или часто не нужны в процессе выполнения приложения, что помогает уменьшить нагрузку на базу данных и улучшить производительность.
      
3. **Eager Loading (Жадная загрузка)**:
    - Напротив ленивой загрузки, жадная загрузка предполагает, что связанные объекты будут загружены сразу при запросе основного объекта. Это означает, что все данные связанных объектов будут загружены из базы данных сразу, что может быть полезно, когда эти связанные данные будут использоваться непосредственно после получения основного объекта.


#### 2. Что такое JPA?
**JPA (Java Persistence API)** - это стандартный Java API для управления сохранением и извлечением объектов в реляционных базах данных. Он является частью Java EE (Enterprise Edition) и предоставляет удобный способ работать с базами данных, используя объектно-ориентированный подход.
###### Основные возможности JPA включают:
1. **Аннотации**: JPA использует аннотации для маппинга Java классов на таблицы базы данных, а также для определения отношений между этими классами и таблицами.
    
2. **ORM (Object-Relational Mapping)**: JPA позволяет работать с объектами Java, представляющими данные, без прямого использования SQL-запросов. ORM-провайдер (например, Hibernate, EclipseLink) выполняет преобразование объектов в соответствующие записи в базе данных и наоборот.
    
3. **JPQL (Java Persistence Query Language)**: JPQL предоставляет возможность выполнять запросы к базе данных, используя объектную модель данных, а не SQL. JPQL аналогичен SQL, но работает с объектами и их свойствами, а не с таблицами и столбцами.
    
4. **Управление жизненным циклом объектов**: JPA предоставляет механизмы для управления жизненным циклом объектов, включая сохранение, загрузку, обновление и удаление объектов из базы данных.
    
5. **Транзакции**: JPA поддерживает управление транзакциями, что обеспечивает целостность данных и консистентность в базе данных.
    
6. **Кеширование**: JPA предоставляет возможности кэширования, которые позволяют улучшить производительность приложения путем кэширования часто используемых данных в памяти.

Сам JPA не умеет ни сохранять, ни управлять объектами, JPA только определяет правила игры: как должен действовать каждый провайдер (Hibernate, EclipseLink, OJB, Torque и т.д.), реализующий стандарт JPA. 
Также JPA определяет правила, как должны описываться метаданные отображения и как должны работать провайдеры.

#### 3. Что появилось раньше: JPA или Hibernate?
Hibernate появился раньше, чем JPA. Первый релиз Hibernate был выпущен 23 мая 2001 года. В то время как спецификация JPA 1.0 была выпущена 11 мая 2006 года. Таким образом, Hibernate появился на пять лет раньше, чем JPA.

#### 4. Что такое Hibernate?
**Hibernate** - это один из самых популярных и широко используемых ORM-фреймворков для Java. Он предоставляет мощные инструменты для отображения объектов Java на таблицы баз данных и автоматического управления данными в базе с использованием Java-объектов.
###### Ключевые аспекты:
1. **Создание объектного слоя между кодом и БД, чтобы работать с таблицами, как с объектами**: Hibernate позволяет работать с данными в базе данных как с объектами, обеспечивая удобство и естественность взаимодействия между кодом и базой данных. 
    
2. **Устранение спагетти-кода**: Hibernate сокращает количество кода, необходимого для работы с базой данных, путем автоматизации рутины, связанной с управлением ресурсами JDBC.
    
3. **Поддержка различных способов маппинга**: Hibernate позволяет использовать аннотации и XML-конфигурации для описания маппинга между объектами и таблицами, что делает его гибким и удобным для использования.
    
4. **Мощный язык запросов (HQL)**: HQL позволяет разработчикам выполнять запросы к базе данных, используя объектно-ориентированный подход, и включает в себя множество возможностей, таких как наследование, полиморфизм и ассоциации.
    
5. **Широкое распространение и поддержка**: Hibernate является широко используемым и поддерживаемым open source проектом, что обеспечивает доступность множества ресурсов и документации для разработчиков.
    
6. **Интеграция с другими фреймворками**: Hibernate легко интегрируется с другими Java EE фреймворками, такими как Spring Framework, что облегчает разработку и поддержку приложений.
    
7. **Ленивая инициализация и кэширование**: Hibernate поддерживает ленивую инициализацию и различные уровни кэширования, что способствует повышению производительности приложения.
    
8. **Поддержка различных баз данных и оптимизация запросов**: Hibernate поддерживает чистый SQL и может работать с различными базами данных, а также позволяет оптимизировать запросы и использовать специфические функции каждой базы данных.
    
9. **Неявное управление транзакциями**: Hibernate неявно использует управление транзакциями, что обеспечивает целостность данных и упрощает работу с транзакциями в приложении.
    
10. **Использование HibernateException**: Hibernate использует HibernateException (unchecked), что упрощает обработку исключений и уменьшает необходимость проверки их в коде.

#### 5. Какие ключевые интерфейсы использует Hibernate?
1. **SessionFactory**: Этот интерфейс представляет собой фабрику сессий (Session) в Hibernate. SessionFactory создается один раз при запуске приложения и обеспечивает доступ к сессиям, которые в свою очередь выполняют операции с базой данных.
    
2. **Session**: Сессия Hibernate представляет собой единственную потокобезопасную сессию с базой данных. Он используется для выполнения операций CRUD (Create, Read, Update, Delete) с объектами и выполнения запросов к базе данных.
    
3. **Transaction**: Интерфейс Transaction представляет транзакцию в Hibernate. Он используется для управления транзакциями при выполнении операций с базой данных, такими как сохранение, обновление или удаление объектов.
    
4. **Query**: Query - это интерфейс, который представляет запрос к базе данных в Hibernate. Он используется для выполнения запросов к базе данных, включая HQL (Hibernate Query Language) запросы и критерии запросов.
    
5. **Criteria**: Criteria - это интерфейс, который представляет критерии запроса в Hibernate. Он используется для построения динамических запросов к базе данных на основе критериев, определенных в коде приложения.
    
6. **Configuration**: Configuration - это интерфейс, который представляет конфигурацию Hibernate. Он используется для настройки и инициализации Hibernate приложения, включая настройку соединения с базой данных, маппинг классов и настройку кеша.

###### Интерфейсы `Persistence`, `EntityManagerFactory`, `EntityManager`, `EntityTransaction` и `Query` .
Являются частью Java Persistence API (JPA), который является стандартом для работы с объектно-реляционным отображением (ORM) в Java. 
![[images/Pasted image 20240429151156.png]]
1. **Persistence**:
    - Сначала используется статический метод `createEntityManagerFactory()` класса `Persistence`, чтобы создать объект `EntityManagerFactory`. Этот метод использует конфигурацию JPA (например, `persistence.xml`) для создания фабрики сущностей.
      
2. **EntityManagerFactory**:
    - Создается объект `EntityManagerFactory`, который представляет собой фабрику `EntityManager`. Он инициализируется на основе конфигурации JPA и предоставляет `EntityManager` для работы с сущностями в базе данных.
      
3. **EntityManager**:
    - После получения `EntityManagerFactory` создается объект `EntityManager`, который используется для выполнения операций с базой данных, таких как сохранение, загрузка, обновление и удаление сущностей. Оба интерфейса(`EntityManager`, `Session`) управляют жизненным циклом объектов и их персистентностью. `EntityManager` работает с сущностями JPA, в то время как `Session` работает с классами Persistent Hibernate. `EntityManager` является стандартным интерфейсом JPA, который предоставляет базовый набор функций для работы с сущностями и транзакциями, в то время как `Session` предоставляет расширенные возможности, специфичные для Hibernate. Внутри `EntityManager` используется `Session` для выполнения операций с базой данных.
      
4. **EntityTransaction**:
    - При необходимости начинается транзакция с помощью метода `getTransaction()` объекта `EntityManager`. Объект `EntityTransaction` представляет собой транзакцию с базой данных, которая обеспечивает атомарность, согласованность и изолированность операций.
      
5. **Query**:
    - С помощью объекта `EntityManager` можно создать объект `Query`, который используется для выполнения запросов к базе данных. `Query` предоставляет различные методы для создания запросов, включая JPQL (Java Persistence Query Language), Criteria API и нативные SQL-запросы.
      
6. **Операции с сущностями**:
    - С использованием `EntityManager` можно выполнять операции с сущностями, такие как сохранение (persist), загрузка (find), обновление (merge) и удаление (remove).
      
7. **Commit / Rollback**:
    - По завершении операций с базой данных транзакция завершается с помощью метода `commit()` или `rollback()` объекта `EntityTransaction`. `Commit` фиксирует изменения в базе данных, а `rollback` отменяет изменения и откатывает транзакцию.
      
8. **Закрытие EntityManager**:
    - Наконец, `EntityManager` закрывается с помощью метода `close()`, который освобождает ресурсы и завершает взаимодействие с базой данных.


#### 6. PROXY: что это такое, для чего и как применяется в Hibernate.
В контексте Hibernate, **прокси (proxy)** - это объект, который используется для ленивой инициализации ассоциаций между сущностями (объектами), когда это необходимо. Прокси создается Hibernate во время загрузки объекта из базы данных, когда не все его ассоциации должны быть загружены сразу из-за производительности или избежания избыточной работы с базой данных. 
**Заместитель PROXY — структурный шаблон проектирования. Предоставляет объект-суррогат, который контролирует доступ к другому объекту, перехватывая все вызовы.**

**Паттерн прокси (Proxy)** - это структурный паттерн проектирования, который предоставляет заменитель или структурную оболочку для другого объекта с целью контроля доступа к нему, управления его созданием или упрощения его интерфейса.
###### Вот как прокси используется в Hibernate:
1. **Ленивая инициализация**: Когда объект сущности загружается из базы данных, ассоциации этого объекта могут быть помечены как "ленивые" с использованием аннотации `@ManyToOne`, `@OneToMany`, `@OneToOne` или `@ManyToMany`. Это означает, что данные ассоциации не будут загружены сразу, а будут загружены только тогда, когда к ним будет обращение в коде.
    
2. **Создание прокси**: Вместо того, чтобы загружать связанные объекты сразу при загрузке основного объекта, Hibernate создает прокси-объекты для этих связанных сущностей. Прокси является фиктивным объектом, который ведет себя как настоящий объект, но загружает свои данные только при обращении к ним.
    
3. **Обращение к прокси**: Когда код обращается к ассоциации, содержащей прокси, Hibernate загружает данные из базы данных. На этом этапе прокси превращается в настоящий объект сущности, и код продолжает работать с ним как с обычным объектом.

###### Hibernate может использовать разные библиотеки для создания PROXY: 
- ByteBuddy (начиная с Hibernate 5.3)
- Javaassist (заменил cglib, но все еще есть в исходниках) 
- Сglib (использовался в первых версиях Hibernate)
###### Преимущества использования прокси в Hibernate:
- **Улучшение производительности**: Ленивая инициализация позволяет избежать загрузки лишних данных из базы данных, что может значительно улучшить производительность приложения, особенно при работе с большими объемами данных.
    
- **Экономия ресурсов**: Прокси не загружает данные из базы данных до тех пор, пока они не понадобятся, что позволяет экономить ресурсы базы данных и снижать нагрузку на неё.
    
- **Управление памятью**: Загрузка данных только при необходимости помогает управлять объемом памяти, используемым приложением, и избежать загрузки больших объемов данных в память.

###### Когда использовать прокси?
1. **Удалённый заместитель (remote proxies)**:
    - Когда необходимо осуществлять взаимодействие по сети, и объект-прокси должен имитировать поведение объекта в другом адресном пространстве. Это позволяет снизить накладные издержки при передаче данных через сеть.
      
2. **Виртуальный заместитель (virtual proxies)**:
    - Когда нужно управлять доступом к ресурсу, создание которого требует больших затрат. Прокси-объект может загружать ресурс только при необходимости, а до этого все запросы к нему обрабатываются прокси. Это помогает оптимизировать использование ресурсов.
      
3. **Защищающий заместитель (protection proxies)**:
    - Когда необходимо разграничить доступ к вызываемому объекту в зависимости от прав вызывающего объекта. Прокси может проверять различные условия доступа перед выполнением операции над реальным объектом, обеспечивая контроль доступа.
      
4. **"Умные ссылки" (smart reference)**:
    - Когда нужно вести подсчет ссылок на объект или обеспечить потокобезопасную работу с реальным объектом. Прокси может отслеживать количество ссылок на объект и выполнять различные операции в зависимости от этого, например, освобождать ресурсы при отсутствии ссылок на объект.

###### Proxy объект получаем через метод session.load(), если вызываем геттеры и сеттеры, то выполняется SELECT в базу на получение реального объекта.
В Hibernate метод `session.load()` используется для получения прокси-объекта сущности из базы данных. Прокси-объект представляет собой объект-заместитель, который загружается из базы данных только при необходимости, например, когда к нему обращаются его методы или свойства (геттеры и сеттеры).

Когда вы вызываете метод `session.load()` для получения объекта по его идентификатору (обычно первичному ключу), Hibernate возвращает прокси-объект сущности, который является пустым объектом-заместителем. Этот прокси содержит только идентификатор объекта и не содержит других данных.

Когда вы вызываете геттеры или сеттеры на этом прокси-объекте, Hibernate понимает, что требуется доступ к реальным данным объекта, которые еще не загружены. Поэтому Hibernate выполняет запрос к базе данных (обычно SELECT), чтобы загрузить реальный объект из базы данных. После загрузки реального объекта, вызывается соответствующий геттер или сеттер.

Этот механизм ленивой инициализации позволяет уменьшить накладные расходы на загрузку данных из базы данных, поскольку объекты загружаются только тогда, когда к ним действительно есть запросы. Таким образом, вы можете получить доступ к данным по мере необходимости, а не загружать их все сразу, что может быть полезно при работе с большими объемами данных.

#### 7. Расскажи про Hibernate кэширование (уровни кэша и что под капотом)
**Кэширование в Hibernate** - это один из способов оптимизации работы приложения, **ключевой задачей которого является уменьшение количества прямых обращений к базе данных.** Hibernate поддерживает три уровня кэширования:

1. **Кэш первого уровня (First Level Cache):** Это кэш сессии (Session), который является обязательным. Через него проходят все запросы. Перед тем, как отправить объект в БД, сессия хранит объект за счёт своих ресурсов. Если мы закроем сессию, то все объекты, находящиеся в кэше теряются.
2. **Кэш второго уровня (SessionFactory)**: Это глобальный кэш, который хранит данные, загруженные из базы данных, и предназначен для использования между различными сеансами Hibernate. Этот кэш не привязан к конкретной сессии и используется для общего кэширования данных в приложении.
2. **Кэш запросов (Query Cache)**: Это кэш, который хранит результаты выполнения запросов к базе данных и интегрирован с кэшем второго уровня. Он эффективен для кэширования результатов запросов с одинаковыми параметрами и позволяет избежать повторного выполнения запросов к базе данных.

Hibernate хранит отслеживаемые **сущности в Map, ключами которой являются id сущностей, а значениями — сами объекты-сущности.**
###### Важно:  кэш запросов хранит результат запроса, причём ключом является сам запрос и те параметры, которые были переданы в запросе. Сохраняет не объекты целиком, а их id.
Это означает, что кэш запросов в Hibernate хранит результаты выполненных запросов к базе данных. Каждый запрос вместе с его параметрами рассматривается как уникальный ключ, по которому сохраняется результат выполнения этого запроса.

Таким образом, если приложение выполняет один и тот же запрос с теми же параметрами, то Hibernate может извлечь результат этого запроса из кэша, минуя фактическое выполнение запроса к базе данных. Это может значительно сэкономить время и ресурсы, особенно для часто используемых запросов.

**Но важно отметить, что кэш запросов сохраняет не сами объекты целиком, а только их идентификаторы (id). То есть в кэше хранятся только идентификаторы объектов, которые были возвращены в результате выполнения запроса, а не сами объекты. Когда запрос выполняется повторно, Hibernate использует эти идентификаторы для извлечения соответствующих объектов из кэша второго уровня или из базы данных.**

#### 8. Как работать с кэшем второго уровня?
Если кэш первого уровня привязан к объекту сессии, то кэш второго уровня привязан к объекту – фабрике сессий (Session Factory object) => видимость этого кэша гораздо шире.

Для включения необходимо добавить следующие строки в конфиг файле JPA (persistence.xml):
![image](images/Pasted image 20240429155346.png)
Hibernate сам не реализует кеширование как таковое. А лишь предоставляет структуру для его реализации, поэтому подключить можно любую реализацию, которая соответствует спецификации ORM фреймворка. Из популярных реализаций можно выделить: EHCache, OSCache, SwarmCache, JBoss TreeCache.

Также понадобится отдельно настроить и саму реализацию кэша. В случае с провайдером кэширования EHCache это нужно сделать в файле ehcache.xml Еще нужно указать самому Hibernate, что именно кэшировать. Это легко можно сделать с помощью аннотации `@Cache`.

Зависимости класса по умолчанию также не кэшируются, т.е. на них тоже нужно вешать `@Cache`. 
Чтение из кэша второго уровня происходит только в том случае, если нужный объект не был найден в кэше первого уровня.

>[!WARNING]
>Hibernate НЕ хранит объекты классов, а хранит информацию в виде массивов строк, чисел и т. д. И идентификатор объекта выступает указателем на эту информацию. Концептуально это нечто вроде Map, в которой id объекта — ключ, а массивы данных — значение. Приблизительно это выглядит так:
>![image](images/Pasted image 20240429155611.png)

##### Стратегии кеширования 
Проблема заключается в том, что кэш второго уровня доступен из нескольких сессий сразу и несколько потоков программы могут одновременно в разных транзакциях работать с одним и тем же объектом. Следовательно, надо как-то обеспечивать их одинаковым представлением этого объекта.

1. **Read-only (только чтение)**:
    - Эта стратегия подходит для сущностей, которые никогда не изменяются. Она обеспечивает высокую производительность, поскольку не требует никаких блокировок или синхронизации.
      
2. **Read-write (чтение-запись)**:
    - Стратегия обеспечивает строгую согласованность, используя "мягкие" блокировки. Когда сущность обновляется, на нее накладывается мягкая блокировка, чтобы предотвратить параллельные транзакции от чтения или записи устаревших данных из кэша.
      
3. **Nonstrict-read-write (нестрогое чтение-запись)**:
    - В этой стратегии кэш обновляется после того, как транзакция закоммитила изменения в базу данных. Однако это может привести к временному окну, когда параллельная транзакция может получить устаревшие данные из кэша.
      
4. **Transactional (транзакционное)**:
    - Эта стратегия обеспечивает полное разделение транзакций, гарантируя, что каждая сессия и каждая транзакция видят объекты, как если бы только они с ними работали последовательно.

#### 9. Что такое Persistence Context?
Persistence Context в Java Persistence API (JPA) представляет собой среду, в которой управляются экземпляры сущностей (Entity) в рамках транзакции. Он играет роль кэша данных первого уровня для объектов, загруженных или созданных EntityManager'ом в рамках текущей транзакции.

В JPA существуют два основных типа Persistence Context:
1. **Persistence контекст области транзакции (Transaction scope persistence context)**:
    - Этот тип Persistence Context связан с жизненным циклом транзакции. Каждая транзакция имеет свой собственный Persistence Context. Это означает, что объекты, полученные или созданные в рамках одной транзакции, находятся в том же Persistence Context и отслеживаются EntityManager'ом до завершения транзакции. После завершения транзакции Persistence Context очищается.
      
2. **Расширенный persistence контекст (Extended persistence context)**:
    - Этот тип Persistence Context не ограничен жизненным циклом транзакции и может существовать в течение длительного времени, например, в рамках сессии пользователя в веб-приложении. Обычно используется в сценариях, когда требуется сохранить состояние сущностей между несколькими транзакциями или запросами к базе данных. EntityManager, управляемый приложением (application-managed), использует расширенный Persistence Context.

Когда вы создаете EntityManager, управляемый контейнером (container-managed), вы можете указать тип Persistence Context с помощью атрибута `type` в аннотации `@PersistenceContext`. По умолчанию используется Persistence Context области транзакции. Однако для EntityManager, управляемого приложением, тип Persistence Context всегда является расширенным, и выбор типа контекста недоступен.

#### 10. Что такое EntityManager?
**EntityManager** - это интерфейс JPA, используемый для взаимодействия с persistence context. Он предоставляет API для выполнения основных операций над сущностями (Entity) и получения данных из базы данных. С помощью EntityManager можно сохранять, обновлять, удалять и искать сущности, а также выполнять запросы к базе данных.

Основные методы EntityManager включают:
- **persist:** Делает экземпляр сущности управляемым и постоянным.
- **merge:** Объединяет состояние сущности с текущим контекстом.
- **remove:** Удаляет экземпляр сущности из базы данных.
- **find:** Ищет сущность по ее первичному ключу.
- **createQuery:** Создает запрос JPQL для получения данных из базы данных.

**EntityManagerFactory** - это фабрика EntityManager, которая создает и управляет экземплярами EntityManager. Создание EntityManagerFactory обычно является дорогостоящей операцией, поэтому обычно создается один раз в приложении и используется для создания всех EntityManager'ов, необходимых для выполнения операций с базой данных. Чаще всего даже не создают сами, а делегируют это фреймворку, такому как Spring, например Интерфейс Session из Hibernate представлен в JPA как раз интерфейсом EntityManager.

#### 11. Методы интерфейса EntityManager
- `persist(Object entity)`: Делает экземпляр управляемым и постоянным.
- `merge(T entity)`: Объединяет состояние данного объекта с текущим контекстом сохраняемости.
- `remove(Object entity)`: Удаляет экземпляр сущности.
- `find(Class<T> entityClass, Object primaryKey)`: Находит по первичному ключу. Поиск объекта указанного класса и первичного ключа. Если экземпляр объекта содержится в контексте постоянства, он возвращается оттуда.
- `flush()`: Синхронизирует контекст сохраняемости с базовой бд.
- `lock(Object entity, LockModeType lockMode)`: Блокирует экземпляр сущности, содержащийся в контексте постоянства, с указанным типом режима блокировки.
- `refresh(Object entity)`: Обновляет состояние экземпляра из базы данных, перезаписав изменения, внесенные в сущность, если таковые имеются.
- `clear()`: Очищает контекст сохраняемости, в результате чего все управляемые объекты станут отсоединенными. Изменения, внесенные в объекты, которые не были сброшены в базу данных, не будут сохранены.
- `detach(Object entity)`: Используется для отсоединения сущности от текущего persistence context. Сущность перестает быть управляемой (`managed`) EntityManager, и все изменения в ней больше не будут отслеживаться и автоматически синхронизироваться с базой данных при завершении транзакции. Объекты, которые ранее ссылались на отсоединенный объект, будут продолжать ссылаться на него.
- `contains(Object entity)`: Используется для проверки, находится ли сущность в текущем контексте хранения (persistence context). Этот метод возвращает `true`, если указанная сущность находится в контексте хранения, и `false`, если не находится.
- `getLockMode(Object entity)`: Получает текущий режим блокировки для экземпляра объекта.
- `createQuery(String qlString)`: Создаёт экземпляр Query для выполнения оператора языка запросов Java Persistence (JPQL).

#### 12. Какие функции он выполняет?
1. EntityManager управляет объектами сущностей в контексте постоянства (persistence context) и отслеживает их изменения.
   
2. EntityManager синхронизирует статусы объектов сущностей в persistence контексте и таблице базы данных непосредственно перед перед коммитом транзакции.
   
3. Пакетная обработка операторов SQL для обновления данных позволяет сократить время блокировки базы данных и улучшить параллельное выполнение.
   
4. EntityManager предоставляет API для выполнения операций сущностей, таких как добавление, изменение, удаление, обновление и блокирование, а также для получения данных и работы с графом сущностей (EntityGraph).
   
5. Объекты EntityManager не являются потокобезопасными. Это означает, что каждый поток должен получить свой экземпляр EntityManager, поработать с ним и закрыть его в конце.

#### 13. Каким условиям должен удовлетворять класс, чтобы являться Entity?
1. **Аннотация @Entity**: Класс должен быть аннотирован аннотацией `@Entity`, которая указывает JPA, что этот класс представляет собой сущность, отображаемую в базе данных.

2. **Идентификатор (Primary Key)**: Класс должен иметь одно или несколько полей, обозначенных как идентификаторы сущности (Primary Key). Это поле обычно отмечается аннотацией `@Id`, а также может быть указано, какое поле или комбинация полей являются уникальным идентификатором сущности.

3. **Конструктор без аргументов**: Класс должен иметь конструктор без аргументов. Этот конструктор может быть public или protected. Он также может иметь конструкторы с аргументами.

4. **Геттеры и сеттеры**: Доступ к полям сущности должен осуществляться через геттеры и сеттеры. Хотя это не строгое требование, использование геттеров и сеттеров считается хорошей практикой и может быть необходимо для некоторых операций, например, при использовании прокси-объектов.

5. **Спецификация equals() и hashCode()**: Для корректной работы JPA с объектами сущностей, реализация методов `equals()` и `hashCode()` должна быть корректной и учитывать поля, определяющие уникальность сущности.

6. **Неспособность быть final или enum**: Класс не должен быть объявлен как final или enum, так как JPA требует возможности создания прокси-объектов для управления сущностями.

7. **Класс должен быть сериализуемым**: Это требование не является обязательным, но рекомендуется для обеспечения лучшей совместимости.

8. **Top-level class:** Entity класс должен быть классом верхнего уровня.

###### Существует два основных подхода к доступу к состоянию сущности в JPA:
1. **Доступ через поля (Field Access)**:
    - В этом подходе аннотации JPA (`@Id`, `@Column` и т. д.) применяются к полям класса.
    - В этом случае провайдер, например, Hibernate, обращается к полям класса напрямую, используя Reflection.
    - Этот подход обычно используется, когда требуется простое сопоставление между полями сущности и столбцами в таблице базы данных.
      
2. **Доступ через методы (Property Access)**:
    - В этом подходе аннотации JPA применяются к методам доступа (`getter` и `setter`).
    - В этом случае провайдер, например, Hibernate, обращается к полям класса через методы.
    - Этот подход предоставляет большую гибкость, поскольку методы доступа могут выполнять дополнительную логику при чтении или записи значений поля.

###### Требования к Entity классу в Hibernate МЯГЧЕ, т.е. Hibernate не так строг. Отличия от JPA:
1. **Конструктор без аргументов**:
    - Может иметь любой модификатор доступа, включая пакетный (package).
    - Это отличается от JPA, где конструктор должен быть `public` или `protected`.
      
2. **Класс сущности необязательно должен быть классом верхнего уровня**:
    - Может быть вложенным классом в другой класс.
      
3. **Возможность сохранения финальных классов или классов с финальными методами**:
    - Технически Hibernate может работать с финальными классами или методами.
    - Однако, использование финальных классов или методов может привести к ограничениям в работе с отложенной загрузкой сущностей из-за невозможности создания прокси-объектов.
      
4. **Прямой доступ к переменным экземпляра**:
    - Hibernate не запрещает прямой доступ к переменным экземпляра и ссылки на них извне класса сущности.
    - Однако, это спорный подход, так как нарушает принцип инкапсуляции и может затруднить поддержку и понимание кода.

#### 14. Расскажи про жизненный цикл сущности Entity, перечисли четыре статуса ЖЦ Entity объекта (Entity Instance’s Life Cycle).
1. **Transient:** Объект создан, не имеет primary key, не является частью persistent context (не управляется JPA). Каждый Entity объект, который вы создали явно с помощью Java-кода, а не загрузили из базы данных с помощью Hibernate, имеет статус Transient. Hibernate понятия не имеет об этом объекте, и никакие действия с объектом не влияют на Hibernate, как и работа Hibernate на этот объект.
   
2. **Persistent (or Managed):** Объект создан, имеет primary key, является частью persistent context (управляется JPA). 
   Способов получить объект с таким статусом ровно два: Загрузить объект из Hibernate. Сохранить объект в Hibernate. 
   В этом состоянии. каждый объект представляет собой одну строку в таблице БД. Следовательно, если внести какие-либо изменения в данные, то hibernate обнаружит это и внесет изменения в таблицу базы данных.
   
3. **Detached:** Объект создан, имеет primary key, не является (или больше не является) частью persistent context. Для преобразования объекта из постоянного в отсоединенное состояние нужно либо закрыть сессию, либо очистить кеш. Поскольку сессия будет закрыта или кеш очищен, любые изменения, внесенные в данные, не повлияют на таблицу базы данных. При необходимости отсоединенный объект можно повторно подключить к новой сессии. 
   
4. **Removed:** Объект создан, является частью persistent context, будет удален при commit-е транзакции (закрытии сессии или вызове метода `flush()`). Когда объект сущности удаляется из базы данных, объект сущности находится в удаленном состоянии. Это делается путем вызова операции `delete()`. Поскольку Entity объект находится в удаленном состоянии, любое изменение данных не повлияет на таблицу базы данных.

#### 15. Как влияют операции persist, remove, merge, refresh, detach на Entity объекты каждого из четырех статусов?
| Операция  | Transient                                                                                | Managed                                                                               | Detached                                                                                    | Removed                    |
| --------- | ---------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------- | -------------------------- |
| *Persist* | Managed (объект сохранен в базе при commit'е транзакции или в результате flush операций) | Не влияет, но зависимые Entity могут измениться на managed                            | Exception                                                                                   | Managed                    |
| *Remove*  | Не применяется                                                                           | Статус изменяется на removed, запись будет удалена при commit'е транзакции            | Exception                                                                                   | Не применяется             |
| *Merge*   | Будет создана новая managed entity, в которую будут скопированы данные объекта           | Не влияет, но операция merge сработает на каскадно зависимые Entity                   | Создает новую managed entity и копирует данные, либо  копирует данные в существующую entity | Exception                  |
| *Refresh* | Exception                                                                                | Восстанавливает изменения из базы данных и производит refresh всех зависимых объектов | Exception                                                                                   | Exception                  |
| *Detach*  | Не применяется                                                                           | Статус становится detached                                                            | Не применяется                                                                              | Статус становится detached |

#### 16. Может ли абстрактный класс быть Entity?
Абстрактный класс может быть Entity классом. Абстрактный Entity класс отличается от обычных Entity классов только тем, что нельзя создать объект этого класса. 
Имена абстрактных классов могут использоваться в запросах. 

Абстрактные Entity классы используются в наследовании, когда их потомки наследуют поля абстрактного класса.

#### 17. Может ли Entity класс наследоваться от не Entity классов (non-entity classes)?
Да, сущности могут наследоваться от НЕ Entity классов, которые, в свою очередь, могут быть как абстрактными, так и обычными. 

Состояние (поля) НЕ Entity суперкласса НЕ является персистентным, то есть не хранится в БД и не обрабатывается провайдером (Hibernate), поэтому любое такое состояние (поля), унаследованное Entity классом, также НЕ будет отображаться в БД. 

Не Entity суперклассы не могут участвовать в операциях EntityManager или Query. Любые маппинги или аннотации отношений в не Entity суперклассах игнорируются.

#### 18. Может ли Entity класс наследоваться от других Entity классов?
Да, может.

#### 19. Может ли не Entity класс наследоваться от Entity класса? 
Да, может.

#### 20. Что такое встраиваемый (Embeddable) класс?
**Embeddable класс** – это класс, который не используется сам по себе, а только как часть одного или нескольких Entity классов. Entity класс может содержать как одиночные встраиваемые классы, так и коллекции таких классов. Также такие классы могут быть использованы как ключи или значения map.

Во время выполнения каждый встраиваемый класс принадлежит только одному объекту Entity класса и не может быть использован для передачи данных между объектами Entity классов (то есть такой класс не является общей структурой данных для разных объектов). 

В целом, такой класс служит для того, чтобы выносить определение общих атрибутов для нескольких Entity, можно считать, что JPA просто встраивает в Entity вместо объекта такого класса те атрибуты, которые он содержит. 

**Hibernate** называет эти классы компонентами, а JPA встраиваемыми. В любом случае, концепция одна и та же: композиция значений.

**Особенности встраиваемых классов:**
- Все поля встраиваемого класса, даже коллекции, станут полями класса, в который происходит встраивание.
- Встраиваемые классы могут быть встроены в одну и ту же сущность несколько раз, нужно только поменять имена полей.
- Экземпляры встраиваемых классов, в отличие от экземпляров сущностей, не имеют собственного персистентного состояния, вместо этого они существуют только как часть состояния объекта, которому они принадлежат.
- Встраиваемые классы **могут использовать в качестве полей**:
    - базовые типы;
    - коллекции базовых типов (с аннотацией `@ElementCollection`);
    - другие встраиваемые классы;
    - коллекции других встраиваемых классов (с аннотацией `@ElementCollection`);
    - сущности;
    - коллекции сущностей.
- Сущность может использовать в качестве полей одиночные встраиваемые классы и коллекции встраиваемых классов.
- Встраиваемые классы могут использоваться в качестве ключей и значений `Map`.

#### 21. Какие требования JPA устанавливает к встраиваемым (Embeddable) классам?
1. **Соответствие требованиям для сущностей**: Встраиваемые классы должны соответствовать большинству требований, установленных для сущностей, за исключением того, что у встраиваемых классов не ставится аннотация `@Entity`, и может отсутствовать первичный ключ (`@Id`).
    
2. **Аннотация `@Embeddable`**: Классы должны быть аннотированы аннотацией `@Embeddable`, чтобы указать, что они могут быть встроены в другие сущности.

#### 22. Для чего нужны аннотации @Embedded и @Embeddable?
**Аннотация `@Embeddable`** размещается над классом для указания того, что класс является встраиваемым в другие классы и будет внедрен другими сущностями, **то есть поля этого встраиваемого класса будут добавляться к полям других сущностей** и будут представлять столбцы в таблице этой сущности. Так, во встраиваемый класс мы можем выделить общие поля для разных сущностей, не создавая для него таблицу. **Встраиваемый класс сам не является сущностью.**

**Аннотация `@Embedded`** применяется к полю или свойству в сущности, чтобы указать, что это поле является встраиваемым объектом.

#### 23. Что такое Mapped Superclass?
**Mapped Superclass** - это аннотация JPA, которая используется для указания, что класс является родительским классом для других сущностей, и его поля могут быть отображены в базе данных. Однако сам по себе класс не является сущностью и не отображается в отдельной таблице в базе данных.

Эти суперклассы чаще всего используются, когда есть общая для нескольких классов сущностей информация о состоянии и отображении, которую можно вынести в Mapped Superclass.
###### Особенности Mapped Superclass:
1. **Аннотация @MappedSuperclass**: Класс должен быть помечен аннотацией `@MappedSuperclass` или описан в XML-файле как суперкласс для других сущностей.
2. **Не может использоваться напрямую**: Mapped Superclass не может использоваться в операциях EntityManager или Query напрямую. Вместо этого он предназначен для наследования другими классами-сущностями.
3. **Не может быть в отношениях с другими сущностями**: Нельзя создать поле типа Mapped Superclass в другой сущности. Это означает, что Mapped Superclass не может участвовать в отношениях с другими сущностями.
4. **Может быть абстрактным**: Mapped Superclass может быть абстрактным классом, что позволяет определить общие характеристики для всех наследующих сущностей.
5. **Нет собственной таблицы в БД**: Для Mapped Superclass не создается отдельной таблицы в базе данных. Его поля могут быть включены в таблицы сущностей, которые наследуют его.

Основной недостаток использования Mapped Superclass заключается в невозможности выполнения полиморфных запросов. Это означает, что нельзя загрузить все сущности, которые наследуют от Mapped Superclass в одном запросе.

###### Пояснение:
Предположим, у вас есть иерархия классов: `Vehicle` (Mapped Superclass), `Car` и `Bike`, обе наследующие от `Vehicle`. Если вы хотите выполнить запрос, который выбирает все объекты `Vehicle`, независимо от их конкретного типа (то есть как `Car`, так и `Bike`), вы не сможете это сделать непосредственно через `Vehicle`, потому что он не является сущностью сам по себе.

##### Mapped Superclass v.s. Embeddable class
**Сходства:**
- Не являются сущностями и могут иметь все аннотации, кроме @Entity.
- Не имеют своих таблиц в БД.
- Не могут использоваться в операциях EntityManager или Query.

**Различия:**
- **MappedSuperclass** – это наследование, а **Embeddable class** – это композиция (экземпляр «части» может входить только в одно целое (или никуда не входить)).
- Поля из **Mapped Superclass** могут быть у сущности в одном экземпляре, а полей из **Embeddable class** может быть сколько угодно (встроив в сущность Embeddable class несколько раз и поменяв имена полей).
- В Entity нельзя создать поле с типом **MappedSuperclass**, а с Embeddable можно и нужно.

#### 24. Какие стратегии маппинга иерархии наследования (Inheritance Mapping Strategies) описаны в JPA?
Стратегии наследования нужны для того, чтобы дать понять провайдеру (Hibernate) КАК отображать в БД сущности-наследники. Для этого нужно декорировать родительский класс аннотацией `@Inheritance` и указать один из типов отображения: `SINGLE_TABLE, TABLE_PER_CLASS, JOINED`.

1. **Single Table (Одна таблица)**:
    - Все сущности и их подклассы хранятся в одной таблице базы данных.
    - Для каждого класса в иерархии используется одна и та же таблица, в которой добавляется специальный столбец, указывающий тип сущности.
    - Это простая стратегия, которая обеспечивает хорошую производительность чтения, но может привести к избыточности данных и проблемам с производительностью при больших иерархиях сущностей.
    - Используется по умолчанию, если `@Inheritance` не указана в родительском классе или указана, но без конкретной стратегии.
      
2. **Joined Table (Соединенная таблица)**:
    - Каждая сущность и ее подклассы хранятся в отдельной таблице базы данных.
    - Для каждого класса создается собственная таблица, а для сущностей-подклассов создаются таблицы, связанные с таблицей родительской сущности через внешние ключи.
    -  Обеспечивает хорошую поддержку полиморфных отношений.
    - Эта стратегия предоставляет нормализованную схему базы данных, что может быть полезно для больших и сложных иерархий сущностей, но может привести к необходимости использования объединений при чтении данных, что может снизить производительность.
      
3. **Table Per Class (Таблица на класс)**:
	- Каждая сущность и ее подклассы хранятся в отдельной таблице базы данных.
	- Для каждого класса в иерархии создается отдельная таблица в базе данных, где хранятся все атрибуты этого класса и его подклассов.
	- Использование этой стратегии может привести к нежелательной нагрузке на базу данных из-за необходимости выполнения множества отдельных SQL-запросов для выборки данных из таблиц всех подклассов или использования оператора `UNION`, чтобы объединить результаты выборки. Это может сказаться на производительности, особенно в глубоких иерархиях классов.
	- Также требуется выполнение операций соединения таблиц при создании экземпляров подклассов сущностей, что также может повлиять на производительность.

#### 25. Как мапятся Enum-ы?
В JPA для маппинга перечислений (Enum) обычно используется аннотация `@Enumerated`. Эта аннотация позволяет указать способ хранения значений Enum в базе данных.

Существуют два основных способа маппинга Enum:
1. **ORDINAL:** В этом режиме значения Enum сохраняются в виде их порядкового номера (индекса). Например, если у вас есть Enum `Status`, у которого первый элемент - `PENDING`, второй - `IN_PROGRESS`, и третий - `COMPLETED`, то при выборе этого режима в базе данных будут сохраняться значения 0, 1 и 2 соответственно.
   Проблема с этим типом отображения возникает, когда нам нужно изменить наш Enum. Если мы добавим новое значение в середину или просто изменим порядок перечисления, мы сломаем существующую модель данных. Такие проблемы могут быть трудно уловимыми, и нам придется обновлять все записи базы данных.
    
2. **STRING:** Означает, что в базе будут храниться имена Enum. Так мы можем безопасно добавлять новые значения перечисления или изменять порядок перечисления. Однако переименование значения enum все равно нарушит работу базы данных. 
   Кроме того, даже несмотря на то, что это представление данных гораздо более читаемо по сравнению с параметром @Enumerated(EnumType.ORDINAL), оно потребляет намного больше места, чем необходимо. Это может оказаться серьезной проблемой, когда нам нужно иметь дело с большим объемом данных.

Дополнительные:
1. **@PostLoad и @PrePersist:** Эти аннотации используются для выполнения пользовательских действий после загрузки сущности из базы данных (`@PostLoad`) или перед сохранением сущности в базу данных (`@PrePersist`). Вы можете использовать их для преобразования строковых значений Enum в соответствующие Enum-константы и обратно.
   Несмотря на то, что этот вариант дает нам большую гибкость по сравнению с ранее описанными решениями, он не идеален.
   Просто кажется неправильным иметь в entity целых два атрибута, представляющих одно перечисление. Кроме того, если мы используем этот вариант, мы не сможем использовать значение Enum в запросах JPQL.
```java
public enum Status { PENDING, IN_PROGRESS, COMPLETED }

@Entity
public class Task {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String statusValue; // Строковое значение Enum

    @Transient
    private Status status; // Enum

    @PostLoad
    public void fillEnum() {
        this.status = Status.valueOf(statusValue); // Преобразование строки в Enum после загрузки из базы
    }

    @PrePersist
    public void fillString() {
        this.statusValue = status.name(); // Преобразование Enum в строку перед сохранением в базу
    }

    // Геттеры, сеттеры и другие поля
}
```

2. **Converter**: Это более универсальный способ маппинга, который позволяет вам явно указать способы преобразования значений при сохранении и загрузке из базы данных. Для `Enum` вы можете написать свой собственный конвертер или использовать стандартные конвертеры. 
   Все, что нужно сделать, это создать новый класс, который реализует интерфейс `javax.persistence.AttributeConverter` и аннотировать его с помощью `@Converter`. 
   `@Converter(autoApply=true)`, чтобы JPA автоматически применял логику преобразования ко всем сопоставленным атрибутам нашего `Enum`. В противном случае пришлось бы поместить аннотацию `@Converter` непосредственно над полем `Enum` у каждой сущности, где оно имеется.
   Более того, можно безопасно добавлять новые значения enum или изменять существующие, не нарушая уже сохраненные данные. Это решение просто в реализации и устраняет все недостатки с `@Enumerated(EnumType.ORDINAL)`, `@Enumerated(EnumType.STRING)` и методами обратного вызова.
```java
public enum Status { PENDING, IN_PROGRESS, COMPLETED }

@Entity
public class Task {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Convert(converter = StatusConverter.class)
    private Status status;

    // Геттеры, сеттеры и другие поля
}

@Converter(autoApply = true)
public class StatusConverter implements AttributeConverter<Status, String> {
    @Override
    public String convertToDatabaseColumn(Status status) {
        return status != null ? status.name() : null;
    }

    @Override
    public Status convertToEntityAttribute(String dbData) {
        return dbData != null ? Status.valueOf(dbData) : null;
    }
}
```

#### 26. Как мапятся даты (до Java 8 и старше)?
До появления Java 8 и нового API `java.time` даты в JPA мапились с использованием классов из пакетов `java.sql` и `java.util`.
1. **java.sql.Date, java.sql.Time, java.sql.Timestamp:**
    - `java.sql.Date` представляет календарную дату.
    - `java.sql.Time` представляет время дня.
    - `java.sql.Timestamp` представляет дату и время с точностью до миллисекунды.
    - Сопоставляются с SQL типами `DATE`, `TIME` и `TIMESTAMP`.
    - Использование типов java.sql для полей сущностей не всегда может быть хорошим выбором. Эти классы специфичны для JDBC и содержат множество устаревших функций. Чтобы избежать зависимостей от пакета java.sql, начали использовать классы даты/времени из пакета java.util вместо классов java.sql.Timestamp и java.sql.Time.
      
2. **java.util.Date и java.util.Calendar:**
    - `java.util.Date` хранит дату и время с точностью до миллисекунды.
    - `java.util.Calendar` позволяет работать с датами и временем более гибко. Разница между `Date` лишь в том, что Hibernate не поддерживает отображение (маппинг) `Calendar` на `TIME`.
    - Обычно используются с аннотацией `@Temporal`, чтобы дать понять SQL, с каким конкретно типом данных она работает.
    - Менее предпочтительны из-за своей неэффективности и не потокобезопасности.
      
3. **Настройка часового пояса:**
    - Рекомендуется установить определенный часовой пояс для драйвера JDBC или через свойство `hibernate.jdbc.time_zone` в Hibernate для независимости от часового пояса системы.

С появлением Java 8 появился новый пакет `java.time`, предоставляющий более современные и эффективные средства для работы с датой и временем. В контексте JPA эти классы также используются для маппинга дат.

Использование классов из `java.time` рекомендуется из-за их неизменяемости, потокобезопасности и точности. Кроме того, они напрямую отображаются на соответствующие SQL типы без необходимости указания аннотаций `@Temporal`.

1. **java.time.LocalDate, java.time.LocalTime, java.time.LocalDateTime:**
    - `LocalDate` представляет только дату без времени.
    - `LocalTime` представляет только время без даты.
    - `LocalDateTime` представляет дату и время без учета временной зоны.
    - Сопоставляются с SQL типами `DATE`, `TIME` и `TIMESTAMP`.
    - Не требуют использования аннотации `@Temporal`, так как они напрямую отображаются на SQL типы.
      
2. **java.time.OffsetTime, java.time.OffsetDateTime:**
    - `OffsetTime` представляет время с учетом смещения относительно UTC.
    - `OffsetDateTime` представляет дату и время с учетом смещения относительно UTC.
    - Сопоставляются с SQL типами `TIME` и `TIMESTAMP`.
    
3. **java.time.Instant:**
    - `Instant` представляет момент времени в UTC с точностью до наносекунды.
    - Сопоставляется с SQL типом `TIMESTAMP`.
      
4. **java.time.ZonedDateTime:**
    - `ZonedDateTime` представляет дату и время с учетом временной зоны.
    - Сопоставляется с SQL типом `TIMESTAMP WITH TIME ZONE`.

#### 27. Как Hibernate работает с разными типами?
Для экземпляров классов ТИПОМ считается название класса, например при объявлении экземпляра `TextView` используется `TextView tv = findViewById(R.id.some_id);`

Hibernate использует свою систему типов, которая обеспечивает мост между SQL типами данных и Java типами данных. Это позволяет Hibernate корректно обрабатывать данные при их сохранении и извлечении из базы данных.

1. **Типы значений** в Hibernate - это простые типы, которые не содержат своих собственных полей. Они включают в себя примитивные типы Java, их обертки и другие простые типы, такие как String и Date. Мы говорим, что они «принадлежат» чему-то другому (в частности, сущности, как мы увидим позже), которая определяет их жизненный цикл. Типы значений далее подразделяются на три подкатегории:
	- **Основные типы(базовые):**
	  В Hibernate основные типы значений обычно сопоставляют одно значение базы данных (один столбец) с одним неагрегированным Java-типом. Это означает, что каждый столбец в таблице базы данных обычно сопоставляется с одним полем в классе Java.
	  Hibernate предоставляет ряд встроенных базовых типов, которые обеспечивают это сопоставление. Например, тип `java.lang.String` обычно сопоставляется с типом SQL `VARCHAR`, а `java.lang.Integer` - с `INTEGER`.
	  Эти сопоставления следуют естественным сопоставлениям, рекомендованным в спецификации JDBC, что обеспечивает совместимость между Hibernate и различными базами данных.
	  
	- **Составные типы(встраиваемые):**
	  JPA называет их **встроенные (@Embeddable)** типы, тогда как Hibernate традиционно называет их **компонентами**. Просто имейте в виду, что оба термина используются и означают одно и то же когда обсуждается Hibernate.
	  Компоненты представляют собой агрегацию значений в один тип Java. Они могут быть очень полезны для организации и группировки связанных данных. Однако, важно помнить, что компоненты не имеют собственного жизненного цикла и не определяют идентификатор. Это означает, что они не могут существовать независимо от сущности, к которой они принадлежат. 
	  
	- **Типы коллекций:**
	  Коллекция относится к структуре данных, которая может содержать базовые типы, составные типы или типы сущностей. Сама коллекция не имеет своего идентификатора и существует как часть сущности.

2. **Типы сущностей**, с другой стороны, представляют собой более сложные типы данных, которые имеют свои собственные поля и обычно соответствуют таблице в базе данных.
   Понятие независимости сущности может быть изменено разработчиком приложения **с использованием концепции каскадов**. Каскады позволяют некоторым операциям продолжать выполняться (каскадом) через объединение от одной сущности к другой.

#### 28. Как сохранять в базе данных коллекции базовых типов?
Для сохранения коллекций базовых типов в базе данных с использованием Hibernate вы можете использовать аннотацию `@ElementCollection`. Эта аннотация используется для указания, что поле или свойство является коллекцией простых типов или встроенных типов.

Аннотация `@ElementCollection` похожа на отношение `@OneToMany`, но вместо сущностей она работает с базовыми и встраиваемыми типами. Это делает ее очень полезной для работы с коллекциями простых типов.
```java
@Entity
public class Person {
    @Id
    @GeneratedValue
    private Long id;

    @ElementCollection
    private List<String> phoneNumbers;

    // другие поля и методы...
}
```
В этом примере `phoneNumbers` - это коллекция базового типа `String`. Hibernate автоматически создаст дополнительную таблицу для хранения элементов этой коллекции. Каждый элемент коллекции будет сохранен в отдельной строке этой таблицы.

При использовании `@ElementCollection` Hibernate будет обрабатывать коллекцию как целостный объект. Это означает, что при обновлении, добавлении или удалении элементов из коллекции Hibernate будет обновлять все строки в соответствующей таблице. Это может быть неэффективным для больших коллекций, поэтому важно учитывать это при проектировании вашего приложения.

В Hibernate аннотация `@CollectionTable` используется для указания имени таблицы коллекции, а `@JoinColumn` - для указания столбца, который ссылается на первичную таблицу. Это позволяет вам более точно управлять отображением коллекции в базе данных.

Аннотации `@AttributeOverrides` и `@AttributeOverride` можно использовать для настройки отображения полей базовых или встраиваемых типов в таблице. Это может быть полезно, если вы хотите изменить имя столбца или другие атрибуты отображения для определенного поля.

```java
@Entity
public class User {
    @Id
    @GeneratedValue
    private Long id;

    @ElementCollection
    @MapKeyColumn(name="Phone")
    @Column(name="Phone_number")
    @CollectionTable(name="user_phones", 
    joinColumns=@JoinColumn(name="user_id"))
    Map<String, String> phoneNumbers = new HashMap<String, String>(); 
    // maps from phone type (home, office) to phone number
}
```
В этом примере у пользователя есть коллекция телефонных номеров, которые сохраняются в отдельной таблице `user_phones`. Ключи и значения `Map` сохраняются в столбцах `Phone` и `Phone_number` соответственно.

`@ElementCollection` используется для встраиваемых классов или базовых типов, а `@OneToMany` или `@ManyToMany` используются, когда значение `Map` является сущностью. Это важно помнить при проектировании ваших сущностей и отношений между ними в Hibernate.

 Когда вы добавляете, удаляете или изменяете элемент в коллекции, Hibernate не может просто вставить, удалить или обновить соответствующую строку в таблице коллекции, потому что элементы коллекции не имеют своего уникального идентификатора. Вместо этого Hibernate удаляет все старые строки и вставляет все новые строки, что может быть очень неэффективно.

Вот почему `@ElementCollection` лучше всего подходит для небольших коллекций. Для больших коллекций или когда вам нужно более гибкое управление отношениями, лучше использовать `@OneToMany` или `@ManyToMany` с сущностями.

#### 29. Какие есть виды связей (маппинг ассоциаций)?
| Вид связи  | Описание                                                                                                 | Пример                                                               | Тип загрузки по умолчанию |
| ---------- | -------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------- | ------------------------- |
| *OneToOne*   | Один экземпляр Entity может быть связан не больше, чем с одним экземпляром другого Entity                | Один гражданин – одно место рождения                                 | EAGER                     |
| *OneToMany*  | Один экземпляр Entity может быть связан с несколькими экземплярами других Entity (коллекцией сущностей)  | Один гражданин – много паспортов (гражданский и парочка заграничных) | LAZY                      |
| *ManyToOne*  | Несколько экземпляров Entity (коллекция сущностей) могут быть связаны с одним экземпляром другого Entity | Много студентов учатся на одной кафедре                              | EAGER                     |
| *ManyToMany* | Экземпляры Entity могут быть связаны с несколькими экземплярами друг друга                               | Много студентов учатся у разных преподавателей                       | LAZY                      |
**Однонаправленные отношения** (unidirectional associations) означают, что одна сторона (сущность) знает о связи, а другая нет. В этом случае, только одна сторона может навигировать по связи. Например, если у нас есть класс `Review` с полем `book`, аннотированным как `@ManyToOne`, то экземпляры `Review` могут ссылаться на `Book`, но `Book` не имеет прямого доступа к своим `Review`.

**Двунаправленные отношения** (bidirectional associations) означают, что обе стороны знают о связи и могут по ней навигировать. Например, в классе `Book` может быть поле-коллекция `reviews`, аннотированное как `@OneToMany`. Это позволяет экземпляру `Book` получить доступ ко всем своим `Review`.

Важно помнить, что в двунаправленных отношениях одна из сторон должна быть владельцем связи (обычно это сторона `@ManyToOne`, в зависимой сущности также используем атрибут `mappedBy`, чтобы указать на имя поля в связанной сущности, которое управляет этим отношением).
```java
@Entity
public class Book {
    @Id
    @GeneratedValue
    private Long id;

    @OneToMany(mappedBy = "book")
    private List<Review> reviews = new ArrayList<>();

    // getters and setters
}

@Entity
public class Review {
    @Id
    @GeneratedValue
    private Long id;

    @ManyToOne
    private Book book;

    // getters and setters
}
```

**1. Однонаправленное отношение @ManyToOne / @OneToMany:**
В этом случае у нас есть две сущности: `Employee` и `Department`. Каждый `Employee` принадлежит одному `Department`, но `Department` не знает о своих `Employee`.
```java
@Entity
public class Employee {
    @Id
    @GeneratedValue
    private Long id;

    @ManyToOne
    @JoinColumn(name = "department_id")
    private Department department;
}

@Entity
public class Department {
    @Id
    @GeneratedValue
    private Long id;
}
```

**2. Двунаправленное отношение @ManyToOne / @OneToMany:**
В этом случае `Department` знает о своих `Employee`.
```java
@Entity
public class Employee {
    @Id
    @GeneratedValue
    private Long id;

    @ManyToOne
    private Department department;
}

@Entity
public class Department {
    @Id
    @GeneratedValue
    private Long id;

    @OneToMany(mappedBy = "department")
    private List<Employee> employees;
}
```

**3. Однонаправленное отношение @OneToOne:**
В этом случае у нас есть две сущности: `User` и `Profile`. Каждый `User` имеет один `Profile`, но `Profile` не знает о своем `User`.
```java
@Entity
public class User {
    @Id
    @GeneratedValue
    private Long id;

    @OneToOne
    @JoinColumn(name = "profile_id")
    private Profile profile;
}

@Entity
public class Profile {
    @Id
    @GeneratedValue
    private Long id;
}
```

**4. Двунаправленное отношение @OneToOne:**
В этом случае `Profile` знает о своем `User`.
```java
@Entity
public class User {
    @Id
    @GeneratedValue
    private Long id;

    @OneToOne
    private Profile profile;
}

@Entity
public class Profile {
    @Id
    @GeneratedValue
    private Long id;

    @OneToOne(mappedBy = "profile")
    private User user;
}
```

**5. Отношение @ManyToMany:**
В этом случае `Student` может быть записан на несколько `Course`, и `Course` может иметь несколько `Student`. Это достигается с помощью дополнительной таблицы `student_course`(в итоге у нас 3 таблицы, 2 основных, и 3-я для "связывания"), которая связывает `Student` и `Course` вместе.
```java
@Entity
public class Student {
    @Id
    @GeneratedValue
    private Long id;

    @ManyToMany
    @JoinTable(
        name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id"))
    private List<Course> courses;
}

@Entity
public class Course {
    @Id
    @GeneratedValue
    private Long id;

    @ManyToMany(mappedBy = "courses")
    private List<Student> students;
}
```

#### 30. Что такое владелец связи? 
**Владелец связи** - это сущность, которая инициирует или определяет отношение между двумя сущностями в Hibernate. В однонаправленной связи владелец является инициатором связи, в то время как в двунаправленной связи его необходимо явно указать.

Общий принцип: **владелец связи - это та сущность, на которую ссылаются другие сущности.**

В однонаправленной связи параметры внешнего ключа таблицы настраиваются во владеющей сущности. В двунаправленной связи владеющая сторона определяет параметры, а противоположная указывает в поле `mappedBy` имя соответствующего параметра владеющей связью сущности.

Каждая связь может быть однонаправленной или двунаправленной, и каждая из них может быть разных типов. Для оптимизации производительности часто задается тип загрузки сущности (`fetch`), который по умолчанию устанавливается как `LAZY` для `@OneToMany` и `@ManyToMany`, и `EAGER` для `@OneToOne` и `@ManyToOne`.

Также можно упорядочить элементы в коллекциях с помощью аннотаций `@OrderBy` и `@OrderColumn`, но это может снизить производительность, так как требует поддержания актуальности индексного столбца.

#### 31. Что такое каскады?
**Каскады в Hibernate** — это механизм, который позволяет автоматически распространять определенные операции с одной сущности на связанные с ней сущности. По сути представляет собой `Enum` с этапами жц entity.

1. **Что такое каскадирование?**
	- Отношения между сущностями часто зависят от существования другой сущности. Например, у нас есть сущности “Пользователь” и “Адрес”. Без пользователя адрес не имеет смысла.
	- Каскадирование позволяет автоматически применять определенные действия (например, сохранение, обновление или удаление) к связанным сущностям при выполнении операций над родительской сущностью. Таким образом, когда мы выполняем действие над одной сущностью, оно распространяется на связанные с ней сущности.
	  
2. **Типы каскадов в Hibernate:**
	- В JPA (Java Persistence API) определены следующие типы каскадов:
		- **CascadeType.ALL:** Применяет все операции (сохранение, обновление, удаление и отсоединение) от родительской сущности к дочерним.
		- **CascadeType.PERSIST:** Применяет операцию сохранения от родительской сущности к дочерним.
		- **CascadeType.MERGE:** Применяет операцию слияния от родительской к дочерним объектам.
		- **CascadeType.REMOVE:** Применяет операцию удаления от родительской сущности к дочерним.
		- **CascadeType.REFRESH:** Применяет операцию обновления от родительской сущности к дочерним.
		- **CascadeType.DETACH:** Применяет операцию отсоединения от родительской сущности к дочерним.
	
3. **Пример использования:**
	- Предположим, у нас есть сущности “Пользователь” и “Адрес”. Связь между ними — один-ко-многим (один пользователь может иметь несколько адресов).
	- В классе `Person` мы указываем каскадный тип для ассоциации `@OneToMany`, а в классе `Address` указываем связь с `Person`. 
	  Теперь, при сохранении или удалении пользователя, операции также будут применяться к связанным адресам.
```java
@Entity
public class Person {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private int id;
    private String name;
    
    @OneToMany(mappedBy = "person", cascade = CascadeType.ALL)
    private List<Address> addresses;
}
    @Entity
public class Address {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @JoinColumn(name = "person_id")
    private int id;
    private String street;
    // ...
    @ManyToOne(fetch = FetchType.LAZY)
    private Person person;
    // ...
}
```

#### 32. Какие два типа fetch стратегии в JPA вы знаете?
Для чтения связанных объектов из БД используются две стратегии загрузок (fetch type): 
`EAGER` и `LAZY`. В первом случае объекты коллекции сразу загружаются в память, во 
втором случае — только при обращении к ним. Оба этих подхода имеют достоинства и 
недостатки.

В случае `FetchType.EAGER` в памяти будут находиться все загруженные объекты, даже 
если нужен только один объект из десятка (сотен/тысяч). При использовании данной 
стратегии необходимо быть внимательным, поскольку при загрузке какого-нибудь 
корневого объекта, который связан со всеми остальными объектами и коллекциями, 
можно случайно попытаться загрузить в память и всю базу.

Согласно стратегии `FetchType.LAZY` связанные объекты загружаются только по мере 
необходимости, т.е. при обращении. Но при этом требуется, чтобы соединение с базой 
(или транзакция) сохранялись. Если точно, то требуется, чтобы объект был `attached(managed)`. 
Поэтому для работы с `lazy` объектами тратится больше ресурсов на поддержку 
соединений.

#### 33. Для чего нужна аннотация Basic?
Аннотация **`@Basic`** в **Java Persistence API (JPA)** используется для определения базовых свойств поля сущности. Вот некоторые ключевые моменты:

1. **Цель аннотации @Basic**:
    - Определяет, что поле является простым (базовым) атрибутом сущности.
    - Поле, помеченное аннотацией `@Basic`, не имеет дополнительных настроек и используется по умолчанию.
      
2. **Пример использования**:
    - Предположим, у нас есть сущность `Product`, и мы хотим определить простое поле `price`:
```java
@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String name;
    @Basic
    private double price;
    // ...
}
```
- В данном примере поле `price` будет сохранено в базе данных как обычное числовое значение без дополнительных настроек.
3. **Дополнительные замечания**:
    - Аннотация `@Basic` может использоваться вместе с другими аннотациями, такими как `@Column`, чтобы настроить дополнительные атрибуты поля (например, имя столбца, длину и т. д.).
    - Если вы не указываете аннотацию `@Basic` явно, JPA все равно будет считать поле базовым, если оно не помечено другими аннотациями (например, `@Temporal`, `@Enumerated` и др.).

**В общем, аннотация `@Basic` используется для простых полей, которые не требуют дополнительных настроек или специфического поведения при сохранении в базе данных.**

#### 34. Для чего нужна аннотация Column?
Аннотация говорит к какому именно столбцу в таблице БД мы привязываем поле класса.

Аннотация `@Column` сопоставляет поле класса столбцу таблицы, а её атрибуты 
определяют поведение в этом столбце, используется для генерации схемы базы данных.
Атрибут `nullable` аннотации `@Column` указывает, может ли соответствующий столбец в 
таблице быть null.

Аннотация `@Column` позволяет указать имя столбца в таблице и ряд других свойств: 
`insertable`/`updatable` – можно ли добавлять/изменять данные в колонке (by default = true);
`length` – длина, для строковых типов данных, по умолчанию 255 символов.

#### 35. Для чего нужна аннотация Access? 
Аннотация **определяет тип доступа (access type) для класса** entity, суперкласса, embeddable или отдельных атрибутов, то есть **как JPA будет обращаться к атрибутам entity**, как к полям класса (FIELD, по умолчанию) или как к свойствам класса (PROPERTY), имеющим гетеры (getter) и сеттеры (setter).

1. **FIELD Access Type**:
    - Преимущества:
        - Простота: доступ к полям класса напрямую через рефлексию.
        - Меньше бойлерплейта: не нужно писать геттеры и сеттеры для каждого поля.
    - Недостатки:
        - Не поддерживается наследование: доступ к приватным полям в суперклассах не наследуется.
        - Невозможность ленивой инициализации: Hibernate требует публичного доступа к полям для ленивой загрузки.
          
2. **PROPERTY Access Type**:
    - Преимущества:
        - Поддержка наследования: доступ к приватным полям в суперклассах наследуется.
        - Возможность использования ленивой инициализации: Hibernate может использовать геттеры и сеттеры для обеспечения ленивой загрузки.
    - Недостатки:
        - Больше кода: требуется написать геттеры и сеттеры для каждого поля.
        - Сложнее понимание: если класс имеет много полей, использование геттеров и сеттеров может сделать код менее читаемым

#### 36. Для чего нужна аннотация Cacheable?
**Cacheable** — позволяет включить или выключить использование кэша второго уровня (second-level cache) для данного Entity (если провайдер JPA поддерживает работу с кешированием и настройки кэша (second-level cache) стоят как ENABLE_SELECTIVE или DISABLE_SELECTIVE.

Аннотация @Cacheable размещается над классом Entity. Её действие распространяется на эту сущность и её наследников, если они не определили другое поведение.

#### 37. Каких провайдеров кэша второго уровня знаешь?
В Hibernate существует четыре стратегии одновременного доступа к объектам в кэше: 
- Read-only (только чтение) 
- Read-write (чтение-запись)
- Nonstrict-read-write (не строгое чтение-запись)
- Transactional (транзакционное)
  
Чем менее строгую стратегию для кэша вы выбираете, тем большая производительность у кэша второго уровня. Hibernate имеет стратегию кэша по умолчанию, для этого нужно использовать в файле настроек `hibernate.cfg.xml` свойство: `hibernate.cache.default_cache_concurrency_strategy`.

**Ehcache** и **Infinispan** — это две популярные библиотеки для кэширования данных в контексте Hibernate и Java.

1. **Ehcache**:
    - **Описание**: Ehcache — это библиотека для кэширования данных, которая предоставляет реплицированный кэш с ограниченной поддержкой долгосрочного хранения на диске.
    - **Особенность**: Основное внимание уделяется реплицированному кэшированию, где несколько копий одних и тех же данных хранятся на разных узлах кластера. Это обеспечивает высокую доступность и отказоустойчивость.
    - **Интеграция**: Ehcache может интегрироваться с Hibernate как кэш второго уровня. Он также может использоваться независимо от Hibernate.
    - **Поддержка дискового хранения**: Ehcache предоставляет ограниченную поддержку хранения данных на диске.
    - **Nonstrict-read-write стратегия** не является стандартной для Ehcache. Однако вы можете реализовать нестрогую стратегию чтения-записи, используя пользовательский код.
      
2. **Infinispan**:
    - **Описание**: Infinispan — это распределенное хранилище данных в памяти, предоставляющее гибкие варианты развертывания и мощные возможности для хранения, управления и обработки данных.
    - **Особенность**: Infinispan поддерживает более сложные стратегии распределения данных, включая разделение данных и их распределение по кластеру.
    - **Интеграция с Java EE**: Infinispan интегрируется с Java Enterprise Edition (Java EE), обеспечивая поддержку транзакций JTA, интеграцию с JPA и использование в качестве кэша второго уровня в Hibernate ORM.
    - **Поддержка дискового хранения**: Infinispan предоставляет более широкие возможности для хранения данных на разных типах носителей, таких как файлы, базы данных или облачные хранилища.
    - **Запросы**: Infinispan поддерживает встроенные запросы для поиска данных в кэше.
    - Поддерживает все стратегии одновременного доступа к кэшу.

В целом, выбор между Ehcache и Infinispan зависит от ваших конкретных требований. Если вам нужно простое реплицированное кэширование, Ehcache может быть хорошим выбором. Если же вам нужны более сложные возможности распределения данных и интеграция с Java EE, Infinispan может подойти лучше.

#### 38. Как смапить составной ключ?
Составной первичный ключ, также называемый составным ключом, представляет собой комбинацию из двух или более столбцов для формирования первичного ключа таблицы. В контексте JPA (Java Persistence API) допустимыми типами атрибутов для первичного ключа являются примитивные типы, их обертки, строки, `BigDecimal, BigInteger, java.util.Date и java.sql.Date` и т.д.
###### Существуют определенные требования к составному ключу:
1. Составной ключ должен быть представлен классом первичного ключа. Для этого можно использовать одну из двух аннотаций: `@IdClass` или `@EmbeddedId`.
2. Класс первичного ключа должен быть объявлен как `public` и иметь публичный конструктор без аргументов.
3. Класс первичного ключа должен реализовывать маркерный интерфейс `Serializable`.
4. В классе первичного ключа необходимо переопределить методы `equals()` и `hashCode().
5. Атрибуты, представляющие поля составного ключа, могут быть базовыми, составными или ассоциациями `@ManyToOne`, но не могут быть коллекциями или ассоциациями `@OneToOne`.

Однако следует отметить, что первое правило применяется только в JPA. Hibernate позволяет определять составные идентификаторы без создания отдельного “класса первичного ключа” с помощью нескольких атрибутов, аннотированных как `@Id`.

###### Рассмотрим два подхода:
1. **@IdClass**:
	- Создайте класс, например, `AccountId`, который будет представлять составной ключ. Этот класс должен быть аннотирован как `@IdClass`.
	- В сущности `Account` объявите поля, соответствующие составному ключу, и аннотируйте их как `@Id`.
```java
@Entity
@Table(name = "account")
@IdClass(AccountId.class)
public class Account {
    @Id
    private long accountNumber;
    @Id
    private String accountType;
}
```

2. **@EmbeddedId**:
	- Создайте класс, например, `BookId`, который будет представлять составной ключ. Этот класс должен быть аннотирован как `@Embeddable`.
	- В сущности `Book` встроить этот класс с помощью аннотации `@EmbeddedId`.
```java
@Embeddable
public class BookId implements Serializable {
    private String title;
    private String language;
}

@Entity
@Table(name = "book")
public class Book {
    @EmbeddedId
    private BookId bookId;
}
```

JPQL-запросы с использованием аннотации `@IdClass` более просты. Однако при использовании аннотации `@EmbeddedId` для доступа к полю составного ключа необходимо обращаться к встраиваемому классу и затем к его полю. Аннотация `@EmbeddedId` более подробна, так как позволяет получить доступ ко всему объекту первичного ключа через метод доступа к полю в классе-сущности. Это также дает четкое представление о полях, которые являются частью составного ключа, так как они агрегированы в классе, доступном только через метод доступа к полям.
###### Выбор между `@IdClass` и `@EmbeddedId` зависит от ситуации:
1. **@IdClass** может быть предпочтительным выбором, если:
    - Класс составного первичного ключа поступает из другого модуля или устаревшего кода.
    - Невозможно изменить класс составного ключа (например, чтобы установить аннотацию `@EmbeddedId`).
      
2. **@EmbeddedId** предпочтительнее, если:
    - Необходим доступ к частям составного ключа по отдельности.
    - В местах, где часто используется полный идентификатор в качестве объекта, аннотация `@EmbeddedId` удобнее.

#### 39. Для чего нужна аннотация ID?
`@Id` определяет простой (не составной) первичный ключ, состоящий из одного поля.

В соответствии с JPA, допустимые типы атрибутов для первичного ключа: 
- примитивные типы и их обертки 
- строки 
- BigDecimal и BigInteger 
- java.util.Date и java.sql.Date

#### 40. Какие @GeneratedValue вы знаете?
Аннотация `@GeneratedValue` используется для определения стратегии генерации первичных ключей (ID) для сущностей. Когда мы создаем сущность, у нее обычно есть поле, помеченное как `@Id`, которое представляет первичный ключ. Аннотация `@GeneratedValue` позволяет нам указать, каким образом этот первичный ключ будет автоматически генерироваться.

1. **IDENTITY**: В этой стратегии Hibernate делегирует базе данных генерацию ключей. В MySQL это обычно `AUTO_INCREMENT`, в PostgreSQL `SERIAL`. Эта стратегия имеет некоторые ограничения, например, Hibernate должен выполнить `INSERT`, чтобы узнать значение ключа, что может быть неэффективно при сохранении сразу нескольких объектов. Это противоречит стратегии Hibernate “транзакционная запись-после” (transactional write behind). (пытается максимально отложить сброс данных в БД из persistance context, чтобы не делать много обращений к БД).
   
   ###### Дополнительно:
   - При использовании генератора IDENTITY в Hibernate, пакетные вставки не могут быть применены, поскольку Hibernate должен выполнить операцию вставки, чтобы получить сгенерированный ID. Таким образом, он не может собирать несколько операций вставки в один пакет. Это противоречит идеологии транзакционной записи-после, потому что Hibernate не может предвидеть ID, которые будут сгенерированы базой данных.
   - Несмотря на отключение пакетных вставок для объектов, использующих генератор IDENTITY, пакетные обновления и удаления все еще поддерживаются, поскольку для них ID не является проблемой. Они могут быть оптимизированы и выполнены как часть одной транзакции для улучшения производительности.

2. **SEQUENCE** - стратегия генерации, использующая механизмы генерации последовательных значений в базе данных. Если база данных не поддерживает SEQUENCE, Hibernate переключается на TABLE.
	**Преимущества SEQUENCE:**
    - Гибкость: не ограничивает таблицы и позволяет использовать одну последовательность для нескольких столбцов или таблиц.
    - Предварительное распределение значений для улучшения производительности.
    - Возможность определения шага инкремента для использования алгоритма Hi/Lo.
    - Не ограничивает пакетные вставки и модели наследования Hibernate.
      
    Для работы с SEQUENCE Hibernate использует `SequenceStyleGenerator`.
    
    **@SequenceGenerator** позволяет настроить имя последовательности и другие параметры. Можно создавать разные SEQUENCE-генераторы для разных сущностей.
    
    **Пример:**
    - Можно установить имя последовательности и начальное значение, где генерация первичного ключа начнется с указанного числа.
    - Разные сущности могут использовать разные SEQUENCE.
      
    Важно знать, что SEQUENCE требует дополнительных операторов SELECT для получения следующего значения, но это обычно не влияет на производительность большинства приложений.

3. **TABLE:** используется для генерации уникальных идентификаторов (первичных ключей) для сущностей в базе данных. Основная идея заключается в том, что для каждой сущности создается специальная таблица, которая содержит счетчики значений идентификаторов. Эта стратегия не зависит от конкретной базы данных и обеспечивает гибкость и настраиваемость.
	**Как это работает:**
    - Вначале создается таблица (например, `hibernate_sequence`), которая будет хранить счетчики значений идентификаторов.
    - Затем для каждой сущности создается генератор, который связывается с идентификатором с помощью аннотации `@TableGenerator`.
    - Генератор использует значения из этой таблицы для создания уникальных идентификаторов.
      
    **Пример использования:**
    - Предположим, у нас есть сущность `Product`, для которой мы хотим генерировать уникальные идентификаторы.
    - Мы создаем таблицу `hibernate_sequence` и настраиваем генератор. Теперь каждый раз, когда мы сохраняем новый продукт, Hibernate автоматически обновляет значение идентификатора из таблицы `hibernate_sequence`.
    - `pkColumnName = "sequence_name"`: Имя столбца в таблице, которое будет хранить название последовательности идентификаторов.
	- `valueColumnName = "next_val"`: Имя столбца в таблице, которое будет хранить значение следующего идентификатора.
	- `allocationSize = 1`: Размер выделения (allocation size) - количество идентификаторов, которое будет выделяться за один запрос к базе данных.
``` java
@Entity
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "product_generator")
    @TableGenerator(name = "product_generator", table = "hibernate_sequence", pkColumnName = "sequence_name", valueColumnName = "next_val", allocationSize = 1)
    private Long id;
}
```

4. **AUTO:** позволяет Hibernate выбирать подходящую стратегию генерации идентификаторов в зависимости от диалекта конкретной базы данных. Поведение по умолчанию основано на типе поля идентификатора.
	**Как это работает:**
    - Hibernate анализирует диалект базы данных и определяет, какую стратегию использовать.
    - С версии Hibernate 5.0 для числовых значений (например, целых чисел) генерация основана на **SEQUENCE**, если база данных ее поддерживает. В противном случае используется стратегия **TABLE**.
    - Для строковых идентификаторов (например, UUID) используется стратегия **TABLE**.
      
>[!TIP]
>В Hibernate 5.0 также представлена **UUIDGenerator**, которая позволяет использовать UUID в качестве идентификаторов. Для этого необходимо объявить идентификатор типа UUID с аннотацией `@GeneratedValue`

##### Алгоритм Hi/Lo:
- **Алгоритм Hi/Lo** используется в основном для генерации идентификаторов базы данных.
- Он создает диапазон чисел, которые можно безопасно использовать в качестве идентификаторов.
- Для этого алгоритм использует три числовые переменные: **high**, **low** и **incrementSize**.
- **incrementSize** - это максимальное количество идентификаторов, которые можно сгенерировать за один раз. Это значение следует рассматривать как константу, заданную в начале работы алгоритма.
- **high** обычно получается из базы данных в виде последовательности (sequence). Таким образом, мы уверены, что никто не получит одно и то же число дважды.
- **low** хранит текущее присвоенное число в диапазоне `[0, incrementSize]`

**Шаги для генерации нового значения с использованием алгоритма Hi/Lo:**
1. Если **low** больше или равно **incrementSize**, присвойте новое значение **high** и сбросьте **low** на 0.
2. Сгенерируйте новое значение по формуле:
`(high − 1) * incrementSize + low`

3. Увеличьте **low** на 1.
4. Верните сгенерированное значение.

#### 41. Расскажите про аннотации @JoinColumn и @JoinTable? Где и для чего они используются?
Аннотация `@JoinColumn` используется для указания столбца, который будет использоваться в качестве внешнего ключа при установлении связей между сущностями или коллекциями.

1. **@JoinColumn**
	1. **@OneToOne**:
	    - Если вы используете аннотацию `@OneToOne`, то в таблице сущности-владельца связи (например, `Office`) появится столбец `addressId`. Этот столбец будет содержать внешний ключ, который ссылается на первичный ключ ведомой сущности (`Address`).
	    - Таким образом, каждый офис будет связан с одним адресом.
      
	2. **@OneToMany или @ManyToOne:**
	    - Если вы используете аннотации `@OneToMany` или `@ManyToOne`, вы можете указать атрибут `mappedBy`. Это позволяет определить, на какой стороне будет находиться столбец с внешними ключами.
	    - Например, в таблице `Email` (владелец связи) может быть столбец `employee_id`, который хранит значение идентификатора и ссылается на таблицу `Employee`. Если не указать `mappedBy`, будет создана сводная (третья) таблица с первичными ключами из двух основных таблиц.

2. **@JoinColumns**:
    - Аннотация `@JoinColumns` используется для группировки нескольких аннотаций `@JoinColumn`, которые используются при установлении связей между сущностями или коллекциями.
    - Это особенно полезно, когда у нас есть составной первичный ключ (например, состоящий из нескольких колонок), и нам нужно указать несколько колонок для внешнего ключа.
    - В каждой аннотации `@JoinColumn` должны быть указаны элементы `name` и `referencedColumnName`.
      
3. **@JoinTable**:
    - Аннотация `@JoinTable` используется для указания связывающей (сводной, третьей) таблицы между двумя другими таблицами.
    - Обычно она используется в случае, когда нам нужно создать дополнительную таблицу для связи между двумя сущностями.
    - Например, если у нас есть таблицы `Employee` и `Project`, и нам нужно создать связывающую таблицу для отслеживания, какие сотрудники работают над какими проектами, мы можем использовать аннотацию `@JoinTable`.

#### 42. Для чего нужны аннотации @OrderBy и @OrderColumn, чем они отличаются?
1. **@OrderBy**:
    - Аннотация `@OrderBy` добавляет к генерируемому SQL запросу фразу `ORDER BY`, чтобы упорядочить элементы извлеченной коллекции по определенному столбцу таблицы целевой сущности.
    - Например, если у нас есть коллекция `students` в классе, мы можем использовать аннотацию `@OrderBy("lastname ASC")`, чтобы упорядочить студентов по фамилии в алфавитном порядке.
    - Если коллекция относится к типу `@Embeddable`, то нотация с точкой `("city.country")` используется для ссылки на атрибут внутри встроенного атрибута. Тут адреса будут упорядочены по названиям стран.
      - Аннотация `@OrderBy` работает только с прямыми свойствами, то есть с полями текущей сущности.
      - Попытка использовать вложенное свойство через точку (например, `@OrderBy("supervisor.name"))` приведет к исключению во время выполнения.
      - Если элемент упорядочивания не указан для ассоциации объектов (то есть аннотация используется без какого-либо значения), предполагается упорядочивание по первичному ключу связанного объекта.
    
2. **@OrderColumn:**
	- Используется для добавления дополнительного столбца в таблицу базы данных, который будет хранить порядок элементов коллекции.
	- Обычно применяется к коллекциям, таким как `List`.
	- Указывает имя столбца, который будет хранить порядковый номер элемента в коллекции.
```java
@Entity
public class Department {
    @Id
    @GeneratedValue
    private Long id;

    @OneToMany(mappedBy = "department")
    @OrderColumn(name = "employee_order")
    private List<Employee> employees;
}
```

#### 43. Для чего нужна аннотация Transient?
Ключевое слово `transient` говорит о том, что объект нельзя сериализовать или десериализовать.

Это означает, что поле или свойство, помеченное как `@Transient`, **не будет сохранено** в базе данных при сохранении данных.

По умолчанию все поля и свойства сущности сохраняются в базе данных, когда сущность отображается на таблицу. Однако иногда бывает необходимо исключить определенные поля из сохранения. Вот несколько причин, почему вы можете использовать аннотацию `@Transient`:
1. **Вычисляемые поля**: Если у вас есть поле, которое вычисляется на лету (например, сумма других полей), и вы не хотите его сохранять в базе данных, вы можете пометить его как `@Transient`.
    
2. **Временные данные**: Иногда в классе сущности могут быть временные данные, которые не имеют отношения к базе данных. Например, поле для хранения временной метки или временного состояния.
    
3. **Сериализация**: При сериализации объектов (например, для передачи по сети или сохранения в файл) вы можете использовать `@Transient`, чтобы исключить ненужные поля из сериализации.

Важно понимать, что пометка поля как `@Transient` не означает, что оно не будет использоваться в коде. Это просто указание Hibernate не сохранять его в базе данных.

#### 44. Какие шесть видов блокировок (lock) описаны в спецификации JPA (или какие есть значения у enum LockModeType в JPA)?
Суть **оптимистичной блокировки**: к одному ресурсу вряд ли будут конкурирующие обращения и поэтому транзакции НЕ блокируют друг друга. Ставим тогда, когда к одним и тем же данным редко одновременно обращаются разные транзакции. ОПТИМИСТ. И версионность тут нужна, чтобы понимать, были ли изменения и если «да», то будет выброшено исключение. Дополнительный контроль. 

**Оптимистичное блокирование в JPA реализовано путём внедрения в сущность специального поля версии.**

Поле, аннотирование `@Version`, может быть целочисленным или временным. При завершении транзакции, если сущность была оптимистично заблокирована, будет проверено, не изменилось ли значение `@Version` кем-либо ещё, после того как данные были прочитаны, и, если изменилось, будет выкинуто `OptimisticLockException`. 

**Использование этого поля позволяет отказаться от блокировок на уровне базы данных и сделать всё на уровне JPA, улучшая уровень конкурентности.**

Суть **пессимистичной блокировки:** к одним и тем же данным возможны частые запросы и поэтому используется блокирующий подход. ПЕССИМИСТ.

1. **NONE**: Этот режим не выполняет блокировку. Сущность не блокируется, и другие транзакции могут свободно читать и изменять её.
2. **OPTIMISTIC**(устаревший READ, оставшийся от JPA 1): Этот режим блокировки используется для оптимистической блокировки. При этом не блокируется ни одна из записей в базе данных. Вместо этого JPA проверяет версию сущности перед обновлением. Если версия сущности изменилась с момента последнего чтения, обновление не выполняется. Это позволяет избежать конфликтов при параллельных изменениях.
3. **OPTIMISTIC_FORCE_INCREMENT**(устаревший WRITE, оставшийся от JPA 1): Аналогичен оптимистической блокировке, но также увеличивает версию объекта после его обновления, даже если само обновление не вызвало изменения объекта.
4. **PESSIMISTIC_READ**: пессимистичная блокировка на чтение. Этот тип блокировки предотвращает изменение данных, заблокированных для чтения другой транзакцией, но позволяет им читать данные.
5. **PESSIMISTIC_WRITE**: пессимистичная блокировка на запись (и чтение). Этот тип блокировки блокирует данные для чтения и записи другими транзакциями, предотвращая одновременное чтение и запись данных.
6. **PESSIMISTIC_FORCE_INCREMENT**: Этот режим аналогичен PESSIMISTIC_WRITE, но также автоматически увеличивает версию сущности при каждом обновлении.

Установка timeout'а для блокировок может быть полезным способом предотвращения зависаний и улучшения производительности приложения. Когда одна транзакция ждет, чтобы получить доступ к ресурсу, который заблокирован другой транзакцией, timeout может предотвратить бесконечное ожидание путем автоматического прерывания операции после определенного времени ожидания.

В JPA можно использовать подсказку (hint) для установки времени ожидания блокировки. Это можно сделать, например, с помощью подсказки `javax.persistence.lock.timeout`, которая указывает, сколько миллисекунд транзакция должна ждать, прежде чем будет выброшено исключение `TimeoutException`.

#### 45. Какие два вида кэшей (cache) вы знаете в JPA и для чего они нужны?
В **JPA** (Java Persistence API) существует два вида кэшей, оба помогают уменьшить количество запросов к базе данных и улучшить производительность приложения.
Однако, когда данные обновляются в базе данных, кэш может содержать устаревшие версии. Это может привести к некорректным результатам.

1. **Уровень 1 кэш (Level 1 Cache)**:
    - Также известен как **EntityManager кэш**.
    - Этот кэш находится на уровне **EntityManager** и представляет собой временное хранилище для сущностей, загруженных из базы данных.
    - Когда вы запрашиваете сущность по её идентификатору, она сначала ищется в этом кэше. Если она там есть, она возвращается без обращения к базе данных.
    - Этот кэш обеспечивает изоляцию транзакций, гарантируя, что изменения в одной транзакции не повлияют на другие транзакции, работающие с той же сущностью.
    - Структура памяти уровня 1 кэша обычно представляет собой Map (ассоциативный массив), где ключами являются идентификаторы сущностей, а значениями — сами сущности.

2. **Уровень 2 кэш (Level 2 Cache)**:
    - Также известен как **общий кэш (shared cache)**.
    - Этот кэш располагается на уровне **EntityManagerFactory** и предназначен для совместного использования между разными **EntityManager**.
    - Он хранит данные о сущностях, загруженных из базы данных, и позволяет избежать повторных запросов к базе данных для одних и тех же данных.
    - Разные поставщики JPA могут иметь разные настройки по умолчанию для этого кэша. 
    -  Например, EclipseLink включает кэширование по умолчанию, в то время как другие поставщики могут не включать его.
    - Структура памяти уровня 2 кэша может быть разной в зависимости от используемого поставщика JPA. Например, он может быть реализован с помощью Map, Set или других структур данных.

#### 46. Как работать с кэшем 2 уровня?
Как можно в коде работать с кэшем второго уровня, включая удаление всех или определенных сущностей из кэша и проверку, закэшировалась ли определенная сущность Entity и т.п.?

Для работы с кэшем второго уровня в JPA используется интерфейс `Cache`, который содержит множество методов для управления кэшем второго уровня. Однако, доступ к этому интерфейсу зависит от провайдера JPA. Объект интерфейса `Cache` можно получить с помощью метода `getCache()` у `EntityManagerFactory`.

JPA определяет пять значений shared-cache-mode из файла `persistence.xml`, которые определяют, как будет использоваться кэш второго уровня:

- **ALL:** все Entity могут кэшироваться в кэше второго уровня.
- **NONE:** кэширование отключено для всех Entity.
- **ENABLE_SELECTIVE:** кэширование работает только для сущностей, у которых установлена `@Cacheable(true)` или ее XML-эквивалент. Для всех остальных сущностей кэширование отключено.
- **DISABLE_SELECTIVE:** кэширование работает для всех Entity, за исключением тех, у которых установлена `@Cacheable(false)` или ее XML-эквивалент.
- **UNSPECIFIED:** кэширование не определено, и каждый провайдер JPA использует свое значение по умолчанию для кэширования.

#### 47. Что такое JPQL/HQL и чем он отличается от SQL?
**JPQL** (Java Persistence Query Language) и **HQL** (Hibernate Query Language) - это языки запросов, ориентированные на объектную модель, аналогичные SQL. Давайте рассмотрим их основные характеристики и различия:

1. **JPQL (Java Persistence Query Language)**:
    - **JPQL** - это язык запросов, используемый в **Java Persistence API (JPA)**.
    - Он позволяет разработчикам писать запросы, работая с Java-классами и их свойствами.
    - **JPQL** абстрагирует от структуры базы данных, что упрощает работу с объектами.
    - **Автоматический полиморфизм** в **JPQL** означает, что запросы автоматически включают в себя экземпляры подклассов, удовлетворяющие критериям запроса. Например, если у вас есть иерархия классов, состоящая из суперкласса `Person` и подклассов `Employee` и `Customer`, то запрос, направленный на `Person`, также вернет экземпляры `Employee` и `Customer`, если они соответствуют условиям запроса.
    - Кроме того, **JPQL** предоставляет дополнительные функции, такие как `KEY` (для доступа к ключам в Map), `VALUE` (для доступа к значениям в Map), `TREAT` (для приведения суперкласса к его объекту-наследнику, downcasting), `ENTRY` и другие.
      
2. **HQL (Hibernate Query Language)**:
	- **HQL** - это язык запросов, используемый в **Hibernate** (реализация JPA).
	- Он является расширением JPQL и предоставляет дополнительные возможности.
	- **HQL** также позволяет писать запросы, используя Java-классы и свойства.

###### Различия между JPQL/HQL и SQL:
- SQL напрямую работает с таблицами, записями и полями реляционной базы данных.
- JPQL/HQL работают с Java-классами и их экземплярами.
- JPQL/HQL абстрагируют от структуры базы данных, что позволяет получать объекты сущностей, а не наборы полей из базы данных

#### 48. Что означает полиморфизм (polymorphism) в запросах JPQL (Java Persistence query language) и как его «выключить»?
В отличии от SQL в запросах JPQL есть автоматический полиморфизм, то есть каждый запрос к Entity возвращает не только объекты этого Entity, но также объекты всех его классов-потомков, независимо от стратегии наследования (например, запрос `select * from Animal`, вернет не только объекты `Animal`, но и объекты классов `Cat` и `Dog`, которые унаследованы от `Animal`). 

Чтобы исключить такое поведение используется функция `TYPE` в `where` условии (например `select * from Animal a where TYPE(a) IN (Animal, Cat)` уже не вернет объекты класса `Dog`).

#### 49. Что такое Criteria API и для чего он используется?
**Criteria API** — это мощный инструмент в **Java Persistence API (JPA)**, который позволяет программно создавать запросы к базе данных без использования SQL. Вместо того чтобы писать статические запросы, вы можете динамически строить запросы на основе условий, фильтров и логических операций.

Вот некоторые ключевые моменты, связанные с Criteria API:
1. **Построение запросов**: С помощью Criteria API вы можете создавать запросы к сущностям (Entity) и их состоянию (persistent state) программно. Это позволяет вам гибко формировать запросы в зависимости от требований вашего приложения.
    
2. **Критерии и выражения**: Вы можете использовать CriteriaBuilder для создания выражений (Expressions), которые представляют условия, фильтры и операции. Например, вы можете создать выражение для выбора всех элементов с ценой выше 1000:
```java
class Main{
   public static void main(String[] args) {
      CriteriaBuilder cb = entityManager.getCriteriaBuilder();
      CriteriaQuery<Item> query = cb.createQuery(Item.class);
      Root<Item> root = query.from(Item.class);
      query.select(root).where(cb.gt(root.get("itemPrice"), 1000));
   }
}
```
3. **Сложные запросы**: Criteria API позволяет строить сложные запросы с использованием операторов JOIN, GROUP BY, ORDER BY и других. Вы можете объединять таблицы, фильтровать данные и сортировать результаты.
    
4. **Поддержка JPA и Hibernate**: Criteria API является частью JPA, но также поддерживается и Hibernate. С момента Hibernate 5.2, Hibernate Criteria API устарел, и разработка сосредоточена на JPA Criteria API.

Преимущество использования языка Criteria – это динамические запросы, написанные на Java. Это, пожалуй, единственное преимущество. В остальном трудно читаемый код. Чаще используется HQL, JPQL – интуитивно понятный (т.к. похож на SQL).

#### 50. В чем разница в требованиях к Entity в Hibernate, от требований к Entity, указанных в спецификации JPA?
1. Конструктор без аргументов в Hibernate НЕ обязан быть `public` или `protected`, рекомендуется чтобы он был хотя бы `package` видимости, однако это только рекомендация, если настройки безопасности Java позволяют доступ к приватным полям, то он может быть приватным. 
   
2. JPA категорически требует не использовать `final` классы, Hibernate лишь рекомендует не использовать такие классы чтобы он мог создавать прокси для ленивой загрузки, однако позволяет либо выключить прокси `Proxy(lazy=false)`, либо использовать в качестве прокси интерфейс, содержащий все методы маппинга для данного класса (аннотацией `Proxy(proxyClass = интерфейс.class)`.

#### 51. Расскажите про проблему N+1 Select и путях ее решения.
Вместо одного запроса мы получаем N запросов. При получении списка пользователей каждый из них инициализируется отдельным запросом на связанные сущности. Проблема N+1 связана с производительностью. Например, если мы выполняем запрос, чтобы получить информацию о пользователе, его платежах и компании, Hibernate может выполнить дополнительные SELECT запросы.

Рекомендуется использовать ленивую загрузку, где это возможно. Например, если установить загрузку EAGER для трех классов, может возникнуть исключение MultipleBagFetchException. Это связано с тем, что Hibernate не может одним запросом загрузить несколько ассоциаций, если они представлены в виде коллекции (Bag), которая не упорядочена и не поддерживает сортировку.

Если используется Set (который не гарантирует порядок), Hibernate выполнит Left Outer Join, что приведет к декартову произведению записей для трех сущностей. Это может привести к дублированию информации, которая не сортирована.

Кроме того, при использовании EAGER загрузки отсутствует возможность использовать LIMIT, OFFSET и агрегирующие функции.

**Решение N+1 проблемы**:
- **Join Fetch** - это хороший способ решения проблемы, когда у вас есть связанные объекты, и вы хотите избежать множественных запросов к базе данных (N+1 запросов). Join Fetch позволяет объединить основную сущность и связанные сущности в одном запросе.
- **JPQL запросы** также могут помочь решить проблему N+1, особенно если вы знаете, какие связанные объекты вам нужны, и можете написать явные запросы для извлечения всей необходимой информации.
- **Hibernate Specific Mapping** - это дополнительный вариант, который может быть полезен, если вы используете нативные запросы или хотите более точно настроить маппинг данных.
- **Entity Graph** - когда нужно получить много данных. С помощью Entity Graph вы можете явно указать, какие ассоциации должны быть загружены вместе с основной сущностью. Это позволяет избежать N+1 проблемы и снизить количество запросов к базе данных.
- **@BatchSize** - позволяет настроить размер пакета (batch size) для загрузки коллекций. Например, если вы знаете, что в вашем приложении часто будут использоваться определенные коллекции, вы можете установить оптимальный размер пакета для эффективной загрузки данных.

1. **JOIN FETCH**:
    - Опция “FETCH” может использоваться в операторах JOIN (INNER JOIN или LEFT JOIN) для выборки связанных объектов в одном запросе, вместо дополнительных запросов для каждого доступа к ленивым полям объекта.
    - При использовании `JOIN FETCH` с `FetchType.EAGER` или `FetchType.LAZY` в JPQL-запросах, связанные объекты будут загружены вместе с основной сущностью.
    - Например, если у вас есть сущность `Post` и связанная с ней сущность `PostComment`, вы можете использовать `JOIN FETCH` для загрузки всех комментариев к постам в одном запросе.
      
2. **EntityGraph**:
    - `EntityGraph` - это мощный инструмент для оптимизации запросов, особенно когда нужно получить большое количество данных.
    - С помощью `EntityGraph` вы можете явно указать, какие ассоциации должны быть загружены вместе с основной сущностью. Это позволяет избежать проблемы N+1 запросов.
      
3. **@Fetch(FetchMode.SUBSELECT)**:
    - Аннотация `@Fetch(FetchMode.SUBSELECT)` является частью Hibernate, но отсутствует в JPA.
    - Она может быть использована только с коллекциями.
    - При использовании `@Fetch(FetchMode.SUBSELECT)` будет выполнен один SQL-запрос для получения корневых сущностей, а при обращении к ленивым полям-коллекциям будет выполнен еще один запрос для получения связанных коллекций.
      
4. **HibernateSpecificMapping, SqlResultSetMapping**:
    - Для нативных запросов рекомендуется использовать именно эти аннотации.
    - `HibernateSpecificMapping` и `SqlResultSetMapping` позволяют настроить маппинг данных при работе с нативными запросами.
      
5. **Batch Fetching**:
    - Аннотация `@BatchSize` также является частью Hibernate, но отсутствует в JPA.
    - Она указывается над классом сущности или над полем коллекции с ленивой загрузкой.
    - При использовании `@BatchSize` будет выполнен один SQL-запрос для получения корневых сущностей, и при обращении к ленивым полям-коллекциям будет выполнен еще один запрос для получения связанных коллекций.
    - Это может быть полезно, если вы знаете примерное количество коллекций, которые будут использоваться в приложении.

В большинстве случаев использование DTO или `JOIN FETCH` является более предпочтительным, так как они позволяют получать необходимые данные одним запросом.

#### 52. Что такое EntityGraph? Как и для чего их использовать? 
Основная цель JPA Entity Graph заключается в улучшении производительности при загрузке связанных ассоциаций и основных полей сущности. Функция Entity Graph, введенная в JPA 2.1, представляет собой более сложный метод работы с нагрузкой на производительность.

Entity Graph позволяет определить шаблон, сгруппировав связанные поля сохраняемости, которые мы хотим получить, и дает возможность выбрать тип графа во время выполнения запроса. Это помогает избежать лишних запросов к базе данных и минимизировать объем передаваемых данных, что в свою очередь повышает производительность приложения.

КАК изменить настройки `fetch` стратегии любых атрибутов Entity для отдельных запросов (query) или методов поиска (find), если у Enity есть атрибут с `fetchType = LAZY`, но для конкретного запроса его требуется сделать `EAGER` или наоборот? 
Для этого существует EntityGraph API, используется он так: 
- С помощью аннотации `NamedEntityGraph` для Entity, создаются именованные EntityGraph объекты, которые содержат список атрибутов, у которых нужно поменять `fetchType` на `EAGER`, а потом данное имя указывается в `hints` запросов или метода `find()`. В результате `fetchType` атрибутов Entity меняется, но только для этого запроса.

```java
import javax.persistence.*;

@Entity
@Table(name = "product")
@NamedEntityGraph(name = "product-with-category", attributeNodes = @NamedAttributeNode("category"))
public class Product {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToOne(fetch = FetchType.LAZY)
    private Category category;
}

@Entity
@Table(name = "category")
public class Category {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
}
```

В этом примере у нас есть две сущности: `Product` и `Category`. Мы использовали аннотацию `@NamedEntityGraph`, чтобы создать именованный EntityGraph с именем `product-with-category`, включая атрибут `category`. Это означает, что при использовании этого именованного графа, атрибут `category` сущности `Product` будет загружаться немедленно (`fetchType` изменяется на `EAGER`).

Как можно использовать этот именованный EntityGraph в запросе:
```java
class Main {
    public static void main(String[] args) {
        EntityManagerFactory entityManagerFactory = Persistence
                .createEntityManagerFactory("my-persistence-unit");

        EntityManager entityManager = entityManagerFactory.createEntityManager();

        EntityGraph<Product> entityGraph = entityManager
                .getEntityGraph("product-with-category");

        List<Product> products = entityManager.createQuery("SELECT p FROM Product p")
                .setHint("javax.persistence.fetchgraph", entityGraph)
                .getResultList();

        for (Product product : products) {
            System.out.println("Product: " + product.getName() +
                               ", Category: " + product.getCategory().getName());
        }

        entityManager.close();
        entityManagerFactory.close();
    }
}
```
#### 53. Можно ли в JDBC реализовать кэш?
Нет, т.к. JDBC пишет запросы сразу в БД и другой функции у него нет.

#### 54. Какие интерфейсы, классы есть в JDBC?
1. **`DriverManager`**: Этот класс является менеджером драйверов JDBC. Он используется для регистрации и получения экземпляра драйвера JDBC.
    
2. **`Connection`**: Этот интерфейс представляет соединение с базой данных. После получения соединения можно создавать объекты типа `Statement`, которые служат для выполнения SQL-запросов.
    
3. **`Statement`**: Этот интерфейс используется для выполнения SQL-запросов. Существуют различные виды `Statement`, включая:
    - `java.sql.Statement`: Statement общего назначения.
    - `java.sql.PreparedStatement`: Statement, служащий для выполнения запросов, содержащих подставляемые параметры (обозначаются символом ‘?’ в теле запроса).
    - `java.sql.CallableStatement`: Statement, предназначенный для вызова хранимых процедур.
      
4. **`ResultSet`**: Этот интерфейс позволяет легко обрабатывать результаты запроса.
    
5. **`SQLException`**: Это исключение, которое может возникнуть при работе с JDBC.

![image](images/Pasted image 20240503063442.png)

#### 55. Если установить стратегию генерации ключа AUTO, то какую из типов стратеги Hibernate САМ никогда не выберет и почему?
Hibernate для работы с Entity нужно знать их id -шник. А чтобы id узнать, нужно обратиться в базу. А Hibernate ленивый, он «не хочет» лишний раз ходить в БД, поэтому IDENTITY он никогда не выберет.
